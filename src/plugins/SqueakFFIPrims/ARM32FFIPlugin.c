/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-nice.2763 uuid: 685e3e10-e9d5-4dab-acf0-188b5a543315
   from
	ThreadedARM32FFIPlugin VMMaker.oscog-nice.2763 uuid: 685e3e10-e9d5-4dab-acf0-188b5a543315
 */
static char __buildInfo[] = "ThreadedARM32FFIPlugin VMMaker.oscog-nice.2763 uuid: 685e3e10-e9d5-4dab-acf0-188b5a543315 " __DATE__ ;



#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif

#include "sqMemoryAccess.h"


/* ThreadedFFIPlugin class>>preambleCCode */

#include "sqAssert.h" /* for assert */
#define ThreadedFFIPlugin 1 /* to filter-out unwanted declarations from sqFFI.h */
#include "sqFFI.h" /* for logging and surface functions */
#include "sqCogStackAlignment.h" /* for STACK_ALIGN_BYTES and getsp() */

#ifdef _MSC_VER
# define alloca _alloca
#endif
#if defined(__GNUC__) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
# define setsp(sp) asm volatile ("movl %0,%%esp" : : "m"(sp))
# elif defined(__GNUC__) && (defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64))
# define setsp(sp) asm volatile ("movq %0,%%rsp" : : "m"(sp))
# elif defined(__arm64__) || defined(__aarch64__) || defined(ARM64)
        /* https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm
         * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/index.html
         */
#  if __GNUC__
#   define getfp() ({ usqIntptr_t fp;                                                           \
                                          asm volatile ("mov x0, x29" : "=r"(x29) : );  \
                                          fp; })
#   define getsp() ({ usqIntptr_t sp;                                                           \
                                          asm volatile ("mov x0, sp" : "=r"(sp) : );    \
                                          sp; })
# define setsp(sp) asm volatile ("ldr x16, %0 \n\t" "mov sp, x16"  : : "m"(sp) )
#  endif
# elif defined(__GNUC__) && (defined(__arm__))
# define setsp(sp) asm volatile ("ldr %%sp, %0" : : "m"(sp))
#endif
#if !defined(getsp)
# define getsp() 0
#endif 
#if !defined(setsp)
# define setsp(ignored) 0
#endif 

#if !defined(STACK_ALIGN_BYTES)
#  define STACK_ALIGN_BYTES 0
#endif /* !defined(STACK_ALIGN_BYTES) */

/* For ABI that require stack alignment greater than natural word size */
#define MUST_ALIGN_STACK (STACK_ALIGN_BYTES > sizeof(void*))

#if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
/* Both Mac OS X x86 and Win32 x86 return structs of a power of two in size
 * less than or equal to eight bytes in length in registers. Linux never does so.
 */
# if __linux__
#	define WIN32_X86_STRUCT_RETURN 0
# else
#	define WIN32_X86_STRUCT_RETURN 1
# endif
# if _WIN32
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
# elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
# if _WIN32 | _WIN64
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
#endif /* defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__) */

#if !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL)
# if defined(__MINGW32__) && !defined(__clang__) && (__GNUC__ >= 3) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
    /*
     * cygwin -mno-cygwin (MinGW) gcc 3.4.x's alloca is a library routine that answers
     * %esp + xx, so the outgoing stack is offset by one or more word if uncorrected.
     * Grab the actual stack pointer to correct.
     */
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 1
# else
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 0
# endif
#endif /* !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL) */

#if !defined(PLATFORM_API_USES_CALLEE_POPS_CONVENTION)
# define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 0
#endif

/* This alignment stuff is a hack for integerAt:put:size:signed:/primitiveFFIIntegerAt[Put].
 * The assumption right now is that all processors support unaligned access.  That only
 * holds true for x86, x86-64 & ARMv6 & later.  But this keeps us going until we can address
 * it properly.
 */
#define unalignedShortAt(a) shortAt(a)
#define unalignedShortAtput(a,v) shortAtput(a,v)
#define unalignedLong32At(a) long32At(a)
#define unalignedLong32Atput(a,v) long32Atput(a,v)
#define unalignedLong64At(a) long64At(a)
#define unalignedLong64Atput(a,v) long64Atput(a,v)

/* The dispatchOn:in:with:with: generates an unwanted call on error.  Just squash it. */
#define error(foo) 0
#ifndef SQUEAK_BUILTIN_PLUGIN
/* but print assert failures. */
void
warning(char *s) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}
#endif

/* sanitize */
#ifdef SQUEAK_BUILTIN_PLUGIN
# define EXTERN 
#else
# define EXTERN extern
#endif

/* end ThreadedFFIPlugin class>>preambleCCode */


/*** Constants ***/
#define DefaultMaxStackSize 16384
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define ExternalFunctionArgTypesIndex 2
#define ExternalFunctionFlagsIndex 1
#define ExternalFunctionStackSizeIndex 3
#define FFIAtomicTypeMask 0xF000000
#define FFIAtomicTypeShift 24
#define FFICallFlagThreaded 0x100
#define FFICallTypeApi 1
#define FFICallTypeCDecl 0
#define FFICallTypesMask 0xFF
#define FFIErrorAddressNotFound 13
#define FFIErrorAttemptToPassVoid 14
#define FFIErrorBadAddress 11
#define FFIErrorBadArg 3
#define FFIErrorBadArgs 2
#define FFIErrorBadAtomicType 5
#define FFIErrorBadExternalFunction 17
#define FFIErrorBadExternalLibrary 16
#define FFIErrorBadReturn 10
#define FFIErrorCallFrameTooBig 19
#define FFIErrorCallType 9
#define FFIErrorCoercionFailed 6
#define FFIErrorInvalidPointer 18
#define FFIErrorModuleNotFound 15
#define FFIErrorNoModule 12
#define FFIErrorNotFunction 1
#define FFIErrorStructSize 8
#define FFIErrorWrongType 7
#define FFIFlagAtomic 0x40000
#define FFIFlagPointer 0x20000
#define FFIFlagStructure 0x10000
#define FFINoCalloutAvailable -1
#define FFIStructSizeMask 0xFFFF
#define FFITypeBool 1
#define FFITypeDoubleFloat 13
#define FFITypeSignedByte 3
#define FFITypeSignedChar 11
#define FFITypeSignedInt 7
#define FFITypeSignedLongLong 9
#define FFITypeSignedShort 5
#define FFITypeSingleFloat 12
#define FFITypeUnsignedByte 2
#define FFITypeUnsignedInt 6
#define FFITypeUnsignedLongLong 8
#define FFITypeUnsignedShort 4
#define FFITypeVoid 0
#define MaxNumArgs 15
#define NumFloatRegArgs 16
#define NumIntRegArgs 4
#define PluginVersionInfo " VMMaker.oscog-nice.2763"
#define PrimErrBadArgument 3
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrFFIException 22
#define PrimErrNoCMemory 10
#define PrimErrNotFound 11
#define PrimErrObjectMayMove 14
#if !defined(SPURVM) /* Allow this to be overridden on the compiler command line */
# define SPURVM 0
#endif

typedef struct {
	char *argVector;
	char *currentArg;
	char *limit;
	sqInt	structReturnSize;
	sqInt	structReturnType;
	sqInt	callFlags;
	void *ffiArgSpec;
	sqInt	ffiArgSpecSize;
	sqInt	ffiArgHeader;
	sqInt	ffiRetHeader;
	sqInt	ffiRetSpec;
	sqInt	stringArgIndex;
	char *stringArgs [MaxNumArgs];
	sqInt	integerRegisterIndex;
	sqInt		integerRegisters [NumIntRegArgs];
	sqInt	floatRegisterIndex;
	sqInt	backfillFloatRegisterIndex;
	float		floatRegisters [NumFloatRegArgs];
 } CalloutState;

#define ThreadedFFICalloutStateForARM32 CalloutState
#define ThreadedFFICalloutState CalloutState


typedef struct { char pad_to_misalgnment; char element; } structByte;

typedef struct { char pad_to_misalgnment; short element; } structShort;

typedef struct { char pad_to_misalgnment; int element; } structInt;

typedef struct { char pad_to_misalgnment; long long element; } structLongLong;

typedef struct { char pad_to_misalgnment; float element; } structFloat;

typedef struct { char pad_to_misalgnment; double element; } structDouble;

typedef struct { char pad_to_misalgnment; struct {char c; } element; } structStruct;




/*** Function Prototypes ***/
static sqInt alignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, unsigned int *indexPtr);
static sqInt atomicTypeOf(sqInt typeSpec);
static sqInt canReturnInRegistersStructOfSize(sqInt returnStructSize);
static sqInt checkAlignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static sqInt checkAlignmentOfUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static void cleanupCalloutState(CalloutState *calloutState);
static sqInt encodeStructReturnTypeIn(CalloutState *calloutState);
static sqInt externalFunctionHasStackSizeSlot(void);
static void * ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize);
static sqInt ffiArgByValuein(sqInt oop, CalloutState *calloutState);
static sqInt ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState);
static sqInt ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState);
static sqInt ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs);
static sqInt ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState);
static sqInt ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode);
static sqInt ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState);
static sqInt ffiFail(sqInt reason);
static double ffiFloatValueOf(sqInt oop);
static sqInt ffiHasPermissiveArgCheck(void);
static sqInt ffiIntegerValueOf(sqInt oop);
static sqInt ffiLoadCalloutAddressFrom(sqInt oop);
static sqInt ffiLoadCalloutAddress(sqInt lit);
static sqInt ffiLoadCalloutModule(sqInt module);
static void ffiLogCallout(sqInt lit);
EXPORT(sqInt) ffiLogCallsTo(char *fileName);
static sqInt ffiPassAtomicArgumentByReferenceClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState);
static sqInt ffiPassAtomicArgumentByReferenceClassIn(sqInt oop, sqInt oopClass, CalloutState *calloutState);
static sqInt ffiPassAtomicArgumentByValueClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState);
static sqInt ffiPassAtomicArgumentByValueClassIn(sqInt oop, sqInt oopClass, CalloutState *calloutState);
static sqInt ffiPassStructureArgumentByReferenceClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState);
static sqInt ffiPassStructureArgumentByValueClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState);
static sqInt ffiPushDereferenceDoubleFloatin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSignedBytein(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSignedCharin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSignedIntin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSignedLongLongin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSignedShortin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceSingleFloatin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceUnsignedBytein(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceUnsignedCharin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceUnsignedIntin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceUnsignedLongLongin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceUnsignedShortin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushDereferenceVoidin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushPointerin(void *pointer, CalloutState *calloutState);
static sqInt ffiPushSignedBytein(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedCharin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedIntin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushSignedLongLongin(sqLong value, CalloutState *calloutState);
static sqInt ffiPushSignedShortin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState);
static sqInt ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState);
static sqInt ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState);
static sqInt ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState);
static sqInt ffiPushVoidin(sqInt ignored, CalloutState *calloutState);
static sqInt ffiReturnCStringFrom(sqInt cPointer);
static sqInt ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState);
static sqInt ffiReturnStructofTypein(void *longLongRetPtr, sqInt ffiRetType, CalloutState *calloutState);
static sqInt ffiReturnType(sqInt specOnStack);
static sqInt ffiSupportsCallingConvention(sqInt aCallingConvention);
static sqInt ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType);
EXPORT(const char *) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isAlien(sqInt anOop);
static sqInt isAtomicType(sqInt typeSpec);
static sqInt isDirectAlien(sqInt oop);
static sqInt isUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static sqInt msg(char *s);
static sqInt nonRegisterStructReturnIsViaImplicitFirstArgument(void);
EXPORT(void) primitiveCallout(void);
EXPORT(void) primitiveCalloutWithArgs(void);
EXPORT(sqInt) primitiveCreateManualSurface(void);
EXPORT(sqInt) primitiveDestroyManualSurface(void);
EXPORT(sqInt) primitiveFFIAllocate(void);
EXPORT(sqInt) primitiveFFIDoubleAt(void);
EXPORT(sqInt) primitiveFFIDoubleAtPut(void);
EXPORT(sqInt) primitiveFFIFloatAt(void);
EXPORT(sqInt) primitiveFFIFloatAtPut(void);
EXPORT(sqInt) primitiveFFIFree(void);
EXPORT(sqInt) primitiveFFIGetLastError(void);
EXPORT(sqInt) primitiveFFIIntegerAt(void);
EXPORT(sqInt) primitiveFFIIntegerAtPut(void);
EXPORT(sqInt) primitiveForceLoad(void);
EXPORT(sqInt) primitiveLoadSymbolFromModule(void);
EXPORT(sqInt) primitiveLogCallsTo(void);
EXPORT(sqInt) primitiveSetManualSurfacePointer(void);
EXPORT(sqInt) primitiveStructureElementAlignment(void);
static sqInt returnStructInRegisters(CalloutState *calloutState);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sizeField(sqInt oop);
static sqInt startOfData(sqInt oop);


/*** Variables ***/
static sqInt externalFunctionInstSize;
static sqInt ffiLastError;
static sqInt ffiLogEnabled;

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop) ((oop) & 1)
# define integerObjectOf(value) ((((usqInt) value) << NumSmallIntegerTagBits) | 1)
# define integerValueOf(oop) ((oop) >> NumSmallIntegerTagBits)

# if SPURVM
extern sqInt classIndexOf(sqInt);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop) ((oop) & 3)
#	else
#	  define isImmediate(oop) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop) (isImmediate(oop) ? isIntegerObject(oop) : (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop) (!isImmediate(oop) && (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop) (fetchClassOf(oop) == classLargeNegativeInteger())
# define isLargePositiveIntegerObject(oop) (fetchClassOf(oop) == classLargePositiveInteger())
# define isLargeIntegerObject(oop) (isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
# define isKindOfInteger(oop) (isIntegerObject(oop) || isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*characterObjectOf)(sqInt characterCode);
static sqInt (*characterValueOf)(sqInt aCharacter);
static sqInt (*classAlien)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classExternalAddress)(void);
static sqInt (*classExternalData)(void);
static sqInt (*classExternalFunction)(void);
static sqInt (*classExternalLibrary)(void);
static sqInt (*classExternalStructure)(void);
static sqInt (*classLargePositiveInteger)(void);
static sqInt (*classString)(void);
static sqInt (*disownVM)(sqInt flags);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchLong32ofObject)(sqInt fieldIndex, sqInt oop);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*floatObjectOf)(double aFloat);
static double (*floatValueOf)(sqInt oop);
static sqInt (*includesBehaviorThatOf)(sqInt aClass, sqInt aSuperclass);
static sqInt (*instanceSizeOf)(sqInt classObj);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
static sqInt (*integerObjectOf)(sqInt value);
#endif
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static void * (*ioLoadModuleOfLength)(sqInt moduleNameIndex, sqInt moduleLength);
static void * (*ioLoadSymbolOfLengthFromModule)(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
static sqInt (*isKindOfClass)(sqInt oop, sqInt aClass);
static sqInt (*isArray)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isCharacterObject)(sqInt oop);
static sqInt (*isFloatObject)(sqInt oop);
static sqInt (*isInMemory)(sqInt address);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isLong64s)(sqInt oop);
static sqInt (*isPointers)(sqInt oop);
static sqInt (*isShorts)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*isYoung)(sqInt anOop);
static sqInt (*literalofMethod)(sqInt offset, sqInt methodPointer);
static sqInt (*literalCountOf)(sqInt methodPointer);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*ownVM)(sqInt flags);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static usqLong (*positive64BitValueOf)(sqInt oop);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop);
static sqInt (*primitiveErrorTable)(void);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*primitiveMethod)(void);
static sqInt (*pushFloat)(double f);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqLong (*signed64BitValueOf)(sqInt oop);
static sqIntptr_t (*signedMachineIntegerValueOf)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static void (*tenuringIncrementalGC)(void);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt byteSizeOf(sqInt oop);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterObjectOf(sqInt characterCode);
#else
# define characterObjectOf(characterCode) 0
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterValueOf(sqInt aCharacter);
#else
# define characterValueOf(aCharacter) 0
#endif
extern sqInt classAlien(void);
extern sqInt classByteArray(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classString(void);
extern sqInt disownVM(sqInt flags);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
extern sqInt integerObjectOf(sqInt value);
#endif
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern void * ioLoadModuleOfLength(sqInt moduleNameIndex, sqInt moduleLength);
extern void * ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionLength, sqInt moduleHandle);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isCharacterObject(sqInt oop);
#else
# define isCharacterObject(oop) 0
#endif
extern sqInt isFloatObject(sqInt oop);
extern sqInt isInMemory(sqInt address);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 17)
extern sqInt isLong64s(sqInt oop);
#else
# define isLong64s(oop) 0
#endif
extern sqInt isPointers(sqInt oop);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 17)
extern sqInt isShorts(sqInt oop);
#else
# define isShorts(oop) 0
#endif
extern sqInt isWords(sqInt oop);
extern sqInt isYoung(sqInt anOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt literalCountOf(sqInt methodPointer);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt nilObject(void);
extern sqInt ownVM(sqInt flags);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
extern sqInt primitiveErrorTable(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveMethod(void);
extern sqInt pushFloat(double f);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern void tenuringIncrementalGC(void);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "ARM32FFIPlugin VMMaker.oscog-nice.2763 " INT_EXT;


/*** Macros ***/
#define allocaLiesSoSetSpBeforeCall() ALLOCA_LIES_SO_SETSP_BEFORE_CALL
#define cStackAlignment() STACK_ALIGN_BYTES
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define dispatchFunctionPointerwithwithwithwith(aFunctionPointer, int1, int2, int3, int4) (aFunctionPointer)(int1, int2, int3, int4)
#define dispatchFunctionPointerwithwithwithwithwithwith(aFunctionPointer, int1, int2, int3, int4, int5, int6) (aFunctionPointer)(int1, int2, int3, int4, int5, int6)
#define dispatchFunctionPointerwithwithwithwithwithwithwithwith(aFunctionPointer, int1, int2, int3, int4, int5, int6, int7, int8) (aFunctionPointer)(int1, int2, int3, int4, int5, int6, int7, int8)
#define ffiAlloc(bytes) (usqInt)malloc(bytes)
#define ffiFree(pointer) free((void *)(pointer))
#define isCalleePopsConvention(callType) (PLATFORM_API_USES_CALLEE_POPS_CONVENTION && (callType) == FFICallTypeApi)
#define mustAlignStack() MUST_ALIGN_STACK



/*	Answer with the alignment requirement for a structure/union.
	Note that indexPtr is a pointer so as to be changed on return.
	On input, the index points to the structure header (the one with
	FFIFlagStructure + structSize).
	On output, the index points the the structure trailer (the
	FFIFlagStructure). 
 */

	/* ThreadedFFIPlugin>>#alignmentOfStructSpec:OfLength:StartingAt: */
static sqInt
alignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, unsigned int *indexPtr)
{
    sqInt byteAlignment;
    unsigned int spec;
    sqInt thisAlignment;

	spec = specs[indexPtr[0]];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	byteAlignment = 1;
	while (1) {
		indexPtr[0] = ((indexPtr[0]) + 1);
		if (!((indexPtr[0]) < specSize)) break;
		spec = specs[indexPtr[0]];
		if (spec == FFIFlagStructure) {
			return byteAlignment;
		}
		thisAlignment = (spec & FFIFlagPointer
			? BytesPerWord
			: (spec & FFIFlagStructure
					? alignmentOfStructSpecOfLengthStartingAt(specs, specSize, indexPtr)
					: spec & FFIStructSizeMask));
		byteAlignment = ((byteAlignment < thisAlignment) ? thisAlignment : byteAlignment);
	}
	assert(0);
	return byteAlignment;
}

	/* ThreadedFFIPlugin>>#atomicTypeOf: */
static sqInt
atomicTypeOf(sqInt typeSpec)
{
	return ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
}


/*	Answer if a struct result of a given size is returned in registers or not. */

	/* ThreadedARM32FFIPlugin>>#canReturnInRegistersStructOfSize: */
static sqInt
canReturnInRegistersStructOfSize(sqInt returnStructSize)
{
	return returnStructSize <= BytesPerWord;
}


/*	Check the alignment of a structure and return true if correctly aligned.
	If computed size = declared size, then the struct is assumed correctly
	aligned. 
 */

	/* ThreadedFFIPlugin>>#checkAlignmentOfStructSpec:OfLength:StartingAt: */
static sqInt
checkAlignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt computedSize;
    unsigned int declaredSize;
    sqInt fieldAlignment;
    sqInt fieldSize;
    sqInt index;
    sqInt maxAlignment;
    unsigned int spec;

	index = startIndex;
	spec = specs[index];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	if (isUnionSpecOfLengthStartingAt(specs, specSize, index)) {
		return checkAlignmentOfUnionSpecOfLengthStartingAt(specs, specSize, startIndex);
	}
	declaredSize = spec & FFIStructSizeMask;
	computedSize = 0;
	maxAlignment = 1;
	while (1) {
		index += 1;
		if (!(index < specSize)) break;
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return (((computedSize - 1) | (maxAlignment - 1)) + 1) == declaredSize;
		}
		if (spec & FFIFlagPointer) {
			fieldSize = BytesPerWord;
			fieldAlignment = fieldSize;
		}
		else {
			fieldSize = spec & FFIStructSizeMask;
			if (spec & FFIFlagStructure) {
				if (!(checkAlignmentOfStructSpecOfLengthStartingAt(specs, specSize, index))) {
					return 0;
				}
				fieldAlignment = alignmentOfStructSpecOfLengthStartingAt(specs, specSize, (&index));
			}
			else {
				fieldAlignment = fieldSize;
			}
		}
		maxAlignment = ((maxAlignment < fieldAlignment) ? fieldAlignment : maxAlignment);
		computedSize = ((computedSize - 1) | (fieldAlignment - 1)) + 1;
		computedSize += fieldSize;
	}
	return (((computedSize - 1) | (maxAlignment - 1)) + 1) == declaredSize;
}


/*	Check the alignment of a union and return true if correctly aligned.
	Union are correctly aligned, but a sub-structure might not. */

	/* ThreadedFFIPlugin>>#checkAlignmentOfUnionSpec:OfLength:StartingAt: */
static sqInt
checkAlignmentOfUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt index;
    unsigned int spec;

	index = startIndex;
	spec = specs[index];
	while (1) {
		index += 1;
		if (!(index < specSize)) break;
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return 1;
		}
		if (!(spec & FFIFlagPointer)) {
			if (spec & FFIFlagStructure) {
				if (!(checkAlignmentOfStructSpecOfLengthStartingAt(specs, specSize, index))) {
					return 0;
				}
			}
		}
	}
	return 1;
}


/*	Free any temporary arg strings. */

	/* ThreadedFFIPlugin>>#cleanupCalloutState: */
static void
cleanupCalloutState(CalloutState *calloutState)
{
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
}


/*	Set the return type to true if returning the struct via register */

	/* ThreadedARM32FFIPlugin>>#encodeStructReturnTypeIn: */
static sqInt
encodeStructReturnTypeIn(CalloutState *calloutState)
{
	(calloutState->structReturnType = ((calloutState->structReturnSize)) <= BytesPerWord);
	return 0;
}

	/* ThreadedFFIPlugin>>#externalFunctionHasStackSizeSlot */
static sqInt
externalFunctionHasStackSizeSlot(void)
{
	return externalFunctionInstSize > ExternalFunctionStackSizeIndex;
}


/*	Answer a long of the address of the byteSize slot (byte, short, int,
	whatever) at byteOffset in rcvr.
	Nominally intended for use with ExternalAddress objects, this code will
	work (for obscure historical
	reasons) with plain Byte or Word Arrays as well. Answer 0 on error. */

	/* ThreadedFFIPlugin>>#ffiAddressOf:startingAt:size: */
static void *
ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize)
{
    sqInt addr;
    sqInt rcvrClass;
    sqInt rcvrSize;

	if (!(isBytes(rcvr))) {
		return 0;
	}
	if (!(byteOffset > 0)) {
		return 0;
	}
	rcvrClass = fetchClassOf(rcvr);
	rcvrSize = byteSizeOf(rcvr);
	if (rcvrClass == (classExternalAddress())) {
		if (!(rcvrSize == BytesPerWord)) {
			return 0;
		}

		/* Hack!! */
		/* don't you dare to read from object memory (unless is pinned)! */
		addr = fetchPointerofObject(0, rcvr);
		if (addr == 0) {

			/* or: [(interpreterProxy isInMemory: addr) or: [(interpreterProxy isPinned: rcvr) not]] */
			return 0;
		}
	}
	else {
		if (!(((byteOffset + byteSize) - 1) <= rcvrSize)) {
			return 0;
		}
		addr = ((sqIntptr_t) (firstIndexableField(rcvr)));
	}
	addr = (addr + byteOffset) - 1;
	return ((void *)addr);
}


/*	Support for generic callout. Prepare an argument by value for a callout. */

	/* ThreadedFFIPlugin>>#ffiArgByValue:in: */
static sqInt
ffiArgByValuein(sqInt oop, CalloutState *calloutState)
{
    sqInt atomicType;
    double floatValue;
    sqInt intValue;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((atomicType < 0)
	 || (atomicType > FFITypeDoubleFloat)) {
		return FFIErrorBadAtomicType;
	}
	if (atomicType < FFITypeSingleFloat) {

		/* integer types */
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

			/* ffi support code must coerce longlong */
			intValue = oop;
		}
		else {
			/* begin ffiIntegerValueOf: */
			if (oop & (BytesPerWord - 1)) {
				if (isIntegerObject(oop)) {
					intValue = integerValueOf(oop);
					goto l2;
				}
				
#        if SPURVM
				if (isCharacterObject(oop)) {

					/* Immediate in Spur */
					intValue = characterValueOf(oop);
					goto l2;
				}
				if (isFloatObject(oop)) {

					/* Immediate in 64-bit Spur */
					intValue = floatValueOf(oop);
					goto l2;
				}
#        endif /* SPURVM */
			}
			else {
				
#        if SPURVM

				/* No non-immediate characters in Spur */
#        else /* SPURVM */
				if (isCharacterObject(oop)) {
					intValue = characterValueOf(oop);
					goto l2;
				}
#        endif /* SPURVM */
				if (isFloatObject(oop)) {
					intValue = floatValueOf(oop);
					goto l2;
				}
				if (oop == (nilObject())) {
					intValue = 0;
					goto l2;
				}
				if (oop == (falseObject())) {
					intValue = 0;
					goto l2;
				}
				if (oop == (trueObject())) {
					intValue = 1;
					goto l2;
				}
				if (isLargePositiveIntegerObject(oop)) {
					
#          if BytesPerWord == 8

					/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
					intValue = positive64BitValueOf(oop);
					goto l2;
#          else /* BytesPerWord == 8 */
					intValue = positive32BitValueOf(oop);
					goto l2;
#          endif /* BytesPerWord == 8 */
				}
			}
			intValue = signedMachineIntegerValueOf(oop);
	l2:	/* end ffiIntegerValueOf: */;
		}
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushUnsignedIntin(intValue, calloutState);
		case 2:
			return ffiPushUnsignedBytein(intValue, calloutState);
		case 3:
			return ffiPushSignedBytein(intValue, calloutState);
		case 4:
			return ffiPushUnsignedShortin(intValue, calloutState);
		case 5:
			return ffiPushSignedShortin(intValue, calloutState);
		case 6:
			return ffiPushUnsignedIntin(intValue, calloutState);
		case 7:
			return ffiPushSignedIntin(intValue, calloutState);
		case 8:
			return ffiPushUnsignedLongLongOopin(intValue, calloutState);
		case 9:
			return ffiPushSignedLongLongOopin(intValue, calloutState);
		case 10:
			return ffiPushUnsignedCharin(intValue, calloutState);
		case 11:
			return ffiPushSignedCharin(intValue, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	/* begin ffiFloatValueOf: */
	if (isFloatObject(oop)) {
		floatValue = floatValueOf(oop);
		goto l3;
	}
	floatValue = ((double) (ffiIntegerValueOf(oop)) );
	l3:	/* end ffiFloatValueOf: */;
	if (failed()) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType == FFITypeSingleFloat) {
		/* begin ffiPushSingleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			if (((calloutState->backfillFloatRegisterIndex)) > 0) {
				((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
				(calloutState->backfillFloatRegisterIndex = 0);
			}
			else {
				((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	else {
		/* begin ffiPushDoubleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
			if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
				(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
			(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
		}
		else {
			if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			(calloutState->floatRegisterIndex = NumFloatRegArgs);
			storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
			(calloutState->currentArg = ((calloutState->currentArg)) + 8);
		}
		return 0;
	}
}


/*	Fetch and check the contents of the compiled spec */

	/* ThreadedFFIPlugin>>#ffiArgument:Spec:Class:in: */
static sqInt
ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState)
{
    sqInt *argSpec1;
    sqInt *argSpec11;
    sqInt *argSpec2;
    sqInt *argSpec3;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt argSpecSize11;
    sqInt argSpecSize2;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType2;
    sqInt atomicType21;
    sqInt atomicType3;
    sqInt atomicType31;
    sqInt atomicType4;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt availableRegisterSpace11;
    sqInt availableRegisterSpace2;
    char *copy;
    double floatValue;
    double floatValue1;
    double floatValue11;
    double floatValue2;
    double floatValue3;
    sqInt handle;
    sqInt handle1;
    sqInt handle2;
    sqInt handle3;
    sqInt handle4;
    sqInt handle5;
    sqInt intValue;
    sqInt intValue1;
    sqInt intValue11;
    sqInt intValue2;
    sqInt intValue3;
    sqInt length;
    sqInt nilOop;
    sqInt oopClass;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void *pointer5;
    void *pointer6;
    void * ptrAddress;
    void * ptrAddress1;
    void * ptrAddress2;
    sqInt ptrClass;
    sqInt ptrClass1;
    sqInt ptrClass11;
    sqInt ptrClass2;
    sqInt ptrClass3;
    sqInt ptrType;
    sqInt ptrType1;
    sqInt referentClass;
    sqInt referentClass1;
    sqInt referentClass2;
    sqInt referentClass3;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt roundedSize11;
    sqInt roundedSize2;
    sqInt spec;
    sqInt spec1;
    sqInt specOop;
    sqInt specOop1;
    sqInt specType;
    sqInt specType1;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt stackPartSize11;
    sqInt stackPartSize2;
    sqInt structSize;
    sqInt structSize1;
    sqInt structSize11;
    sqInt structSize2;
    sqInt type;
    sqInt type1;
    sqInt type2;
    sqInt type3;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec2;
    sqInt typeSpec21;
    sqInt typeSpec3;
    sqInt typeSpec31;
    sqInt typeSpec4;

	pointer5 = ((void *) 0);
	pointer6 = ((void *) 0);
	if (!(isWords(argSpec))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpecSize = slotSizeOf(argSpec));
	if (((calloutState->ffiArgSpecSize)) == 0) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpec = firstIndexableField(argSpec));
	(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));

	/* Prefetch class (we'll need it) */
	oopClass = fetchClassOf(oop);
	nilOop = nilObject();
	if (nilOop == argClass) {
		
		switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
		case FFIFlagAtomic:
			/* begin ffiPassAtomicArgumentByValue:Class:In: */
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Fetch the type specification and check: we handle pointer to an atomic type */
				/* begin atomicTypeOf: */
				typeSpec3 = (calloutState->ffiArgHeader);
				atomicType3 = ((usqInt)((typeSpec3 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				/* begin ffiValidateExternalData:AtomicType: */
				ptrType1 = fetchPointerofObject(1, oop);
				if (!((isPointers(ptrType1))
					 && ((slotSizeOf(ptrType1)) >= 2))) {
					goto l11;
				}
				specOop1 = fetchPointerofObject(0, ptrType1);
				if (!((isWords(specOop1))
					 && ((slotSizeOf(specOop1)) > 0))) {
					goto l11;
				}
				spec1 = fetchPointerofObject(0, specOop1);
				if (!(spec1 & FFIFlagAtomic)) {
					goto l11;
				}
				/* begin atomicTypeOf: */
				specType1 = ((usqInt)((spec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if (specType1 != atomicType3) {

					/* Allow for signed/unsigned conversion but nothing else.
					   See FFIConstants class>>#initializeTypeConstants */
					if (!((atomicType3 >= FFITypeUnsignedByte)
						 && ((atomicType3 <= FFITypeSignedChar)
						 && ((((usqInt)(atomicType3)) >> 1) == (((usqInt)(specType1)) >> 1))))) {
						goto l11;
					}
				}
	l11:	/* end ffiValidateExternalData:AtomicType: */;
				if (failed()) {
					return null;
				}
				handle3 = fetchPointerofObject(0, oop);
				ptrClass1 = fetchClassOf(handle3);
				if (ptrClass1 == (classExternalAddress())) {

					/* Don't you dare to pass pointers into object memory */
					pointer5 = fetchPointerofObject(0, handle3);
					if (isInMemory(pointer5)) {
						return FFIErrorInvalidPointer;
					}
				}
				else {
					if (ptrClass1 == (classByteArray())) {
						pointer5 = ((void *) (firstIndexableField(handle3)));
					}
					else {
						return FFIErrorBadArg;
					}
				}
				
				switch (atomicType3) {
				case 0:
					return FFIErrorAttemptToPassVoid;
				case 1:
					return ffiPushDereferenceUnsignedIntin(pointer5, calloutState);
				case 2:
					return ffiPushDereferenceUnsignedBytein(pointer5, calloutState);
				case 3:
					return ffiPushDereferenceSignedBytein(pointer5, calloutState);
				case 4:
					return ffiPushDereferenceUnsignedShortin(pointer5, calloutState);
				case 5:
					return ffiPushDereferenceSignedShortin(pointer5, calloutState);
				case 6:
					return ffiPushDereferenceUnsignedIntin(pointer5, calloutState);
				case 7:
					return ffiPushDereferenceSignedIntin(pointer5, calloutState);
				case 8:
					return ffiPushDereferenceUnsignedLongLongin(pointer5, calloutState);
				case 9:
					return ffiPushDereferenceSignedLongLongin(pointer5, calloutState);
				case 10:
					return ffiPushDereferenceUnsignedCharin(pointer5, calloutState);
				case 11:
					return ffiPushDereferenceSignedCharin(pointer5, calloutState);
				case 12:
					return ffiPushDereferenceSingleFloatin(pointer5, calloutState);
				case 13:
					return ffiPushDereferenceDoubleFloatin(pointer5, calloutState);

				default:
					error("Case not found");
					return -1;
				}
			}
			if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

				/* We do not have any type specification easily available.
				   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
				handle3 = fetchPointerofObject(0, oop);
				/* begin ffiArgByValue:in: */
				typeSpec1 = (calloutState->ffiArgHeader);
				atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType1 < 0)
				 || (atomicType1 > FFITypeDoubleFloat)) {
					return FFIErrorBadAtomicType;
				}
				if (atomicType1 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue = handle3;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (handle3 & (BytesPerWord - 1)) {
							if (isIntegerObject(handle3)) {
								intValue = integerValueOf(handle3);
								goto l6;
							}
							
#              if SPURVM
							if (isCharacterObject(handle3)) {

								/* Immediate in Spur */
								intValue = characterValueOf(handle3);
								goto l6;
							}
							if (isFloatObject(handle3)) {

								/* Immediate in 64-bit Spur */
								intValue = floatValueOf(handle3);
								goto l6;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(handle3)) {
								intValue = characterValueOf(handle3);
								goto l6;
							}
#              endif /* SPURVM */
							if (isFloatObject(handle3)) {
								intValue = floatValueOf(handle3);
								goto l6;
							}
							if (handle3 == (nilObject())) {
								intValue = 0;
								goto l6;
							}
							if (handle3 == (falseObject())) {
								intValue = 0;
								goto l6;
							}
							if (handle3 == (trueObject())) {
								intValue = 1;
								goto l6;
							}
							if (isLargePositiveIntegerObject(handle3)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue = positive64BitValueOf(handle3);
								goto l6;
#                else /* BytesPerWord == 8 */
								intValue = positive32BitValueOf(handle3);
								goto l6;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue = signedMachineIntegerValueOf(handle3);
	l6:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						return FFIErrorCoercionFailed;
					}
					
					switch (atomicType1) {
					case 0:
						return FFIErrorAttemptToPassVoid;
					case 1:
						return ffiPushUnsignedIntin(intValue, calloutState);
					case 2:
						return ffiPushUnsignedBytein(intValue, calloutState);
					case 3:
						return ffiPushSignedBytein(intValue, calloutState);
					case 4:
						return ffiPushUnsignedShortin(intValue, calloutState);
					case 5:
						return ffiPushSignedShortin(intValue, calloutState);
					case 6:
						return ffiPushUnsignedIntin(intValue, calloutState);
					case 7:
						return ffiPushSignedIntin(intValue, calloutState);
					case 8:
						return ffiPushUnsignedLongLongOopin(intValue, calloutState);
					case 9:
						return ffiPushSignedLongLongOopin(intValue, calloutState);
					case 10:
						return ffiPushUnsignedCharin(intValue, calloutState);
					case 11:
						return ffiPushSignedCharin(intValue, calloutState);

					default:
						error("Case not found");
						return -1;
					}
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(handle3)) {
					floatValue = floatValueOf(handle3);
					goto l4;
				}
				floatValue = ((double) (ffiIntegerValueOf(handle3)) );
	l4:	/* end ffiFloatValueOf: */;
				if (failed()) {
					return FFIErrorCoercionFailed;
				}
				if (atomicType1 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState->backfillFloatRegisterIndex)) > 0) {
							((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
							(calloutState->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
							(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						(calloutState->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
						(calloutState->currentArg = ((calloutState->currentArg)) + 8);
					}
					return 0;
				}
			}
			/* begin ffiArgByValue:in: */
			typeSpec2 = (calloutState->ffiArgHeader);
			atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
			if ((atomicType2 < 0)
			 || (atomicType2 > FFITypeDoubleFloat)) {
				return FFIErrorBadAtomicType;
			}
			if (atomicType2 < FFITypeSingleFloat) {

				/* integer types */
				if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

					/* ffi support code must coerce longlong */
					intValue1 = oop;
				}
				else {
					/* begin ffiIntegerValueOf: */
					if (oop & (BytesPerWord - 1)) {
						if (isIntegerObject(oop)) {
							intValue1 = integerValueOf(oop);
							goto l9;
						}
						
#            if SPURVM
						if (isCharacterObject(oop)) {

							/* Immediate in Spur */
							intValue1 = characterValueOf(oop);
							goto l9;
						}
						if (isFloatObject(oop)) {

							/* Immediate in 64-bit Spur */
							intValue1 = floatValueOf(oop);
							goto l9;
						}
#            endif /* SPURVM */
					}
					else {
						
#            if SPURVM

						/* No non-immediate characters in Spur */
#            else /* SPURVM */
						if (isCharacterObject(oop)) {
							intValue1 = characterValueOf(oop);
							goto l9;
						}
#            endif /* SPURVM */
						if (isFloatObject(oop)) {
							intValue1 = floatValueOf(oop);
							goto l9;
						}
						if (oop == (nilObject())) {
							intValue1 = 0;
							goto l9;
						}
						if (oop == (falseObject())) {
							intValue1 = 0;
							goto l9;
						}
						if (oop == (trueObject())) {
							intValue1 = 1;
							goto l9;
						}
						if (isLargePositiveIntegerObject(oop)) {
							
#              if BytesPerWord == 8

							/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
							intValue1 = positive64BitValueOf(oop);
							goto l9;
#              else /* BytesPerWord == 8 */
							intValue1 = positive32BitValueOf(oop);
							goto l9;
#              endif /* BytesPerWord == 8 */
						}
					}
					intValue1 = signedMachineIntegerValueOf(oop);
	l9:	/* end ffiIntegerValueOf: */;
				}
				if (failed()) {
					return FFIErrorCoercionFailed;
				}
				
				switch (atomicType2) {
				case 0:
					return FFIErrorAttemptToPassVoid;
				case 1:
					return ffiPushUnsignedIntin(intValue1, calloutState);
				case 2:
					return ffiPushUnsignedBytein(intValue1, calloutState);
				case 3:
					return ffiPushSignedBytein(intValue1, calloutState);
				case 4:
					return ffiPushUnsignedShortin(intValue1, calloutState);
				case 5:
					return ffiPushSignedShortin(intValue1, calloutState);
				case 6:
					return ffiPushUnsignedIntin(intValue1, calloutState);
				case 7:
					return ffiPushSignedIntin(intValue1, calloutState);
				case 8:
					return ffiPushUnsignedLongLongOopin(intValue1, calloutState);
				case 9:
					return ffiPushSignedLongLongOopin(intValue1, calloutState);
				case 10:
					return ffiPushUnsignedCharin(intValue1, calloutState);
				case 11:
					return ffiPushSignedCharin(intValue1, calloutState);

				default:
					error("Case not found");
					return -1;
				}
			}
			/* begin ffiFloatValueOf: */
			if (isFloatObject(oop)) {
				floatValue1 = floatValueOf(oop);
				goto l7;
			}
			floatValue1 = ((double) (ffiIntegerValueOf(oop)) );
	l7:	/* end ffiFloatValueOf: */;
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
			if (atomicType2 == FFITypeSingleFloat) {
				/* begin ffiPushSingleFloat:in: */
				if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
					if (((calloutState->backfillFloatRegisterIndex)) > 0) {
						((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
						(calloutState->backfillFloatRegisterIndex = 0);
					}
					else {
						((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
					}
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			else {
				/* begin ffiPushDoubleFloat:in: */
				if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
					if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
						(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
					}
					(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
				}
				else {
					if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					(calloutState->floatRegisterIndex = NumFloatRegArgs);
					storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
					(calloutState->currentArg = ((calloutState->currentArg)) + 8);
				}
				return 0;
			}

		case FFIFlagAtomic + FFIFlagPointer:
			/* begin ffiPassAtomicArgumentByReference:Class:In: */
			typeSpec = (calloutState->ffiArgHeader);
			atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Check: we handle pointer to an atomic type */
				/* no type checks for void pointers */
				if (atomicType != FFITypeVoid) {
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType = fetchPointerofObject(1, oop);
					if (!((isPointers(ptrType))
						 && ((slotSizeOf(ptrType)) >= 2))) {
						goto l3;
					}
					specOop = fetchPointerofObject(0, ptrType);
					if (!((isWords(specOop))
						 && ((slotSizeOf(specOop)) > 0))) {
						goto l3;
					}
					spec = fetchPointerofObject(0, specOop);
					if (!(spec & FFIFlagAtomic)) {
						goto l3;
					}
					/* begin atomicTypeOf: */
					specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (specType != atomicType) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType >= FFITypeUnsignedByte)
							 && ((atomicType <= FFITypeSignedChar)
							 && ((((usqInt)(atomicType)) >> 1) == (((usqInt)(specType)) >> 1))))) {
							goto l3;
						}
					}
	l3:	/* end ffiValidateExternalData:AtomicType: */;
				}
				if (failed()) {
					return null;
				}
				handle = fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(handle, calloutState);
			}
			if (oop == (nilObject())) {
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), null);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

				/* note: the only types allowed for passing into char* types are
				   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
				   (e.g., CompiledMethod, LargeInteger). We only check for strings
				   here and fall through to the byte* check otherwise. */
				if (includesBehaviorThatOf(oopClass, classString())) {
					/* begin ffiPushString:OfLength:in: */
					pointer = ((char *) (firstIndexableField(oop)));
					length = byteSizeOf(oop);
					if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
						return -PrimErrBadNumArgs;
					}
					copy = malloc(length + 1);
					if (copy == null) {
						return -PrimErrNoCMemory;
					}
					memcpy(copy, pointer, length);
					copy[length] = 0;
					((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
					(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), copy);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				atomicType = FFITypeUnsignedByte;
			}
			ptrClass = fetchClassOf(oop);
			if (ptrClass == (classExternalAddress())) {

				/* Don't you dare to pass pointers into object memory */
				ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
				if (isInMemory(ptrAddress)) {
					return FFIErrorInvalidPointer;
				}
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ptrAddress);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if (includesBehaviorThatOf(ptrClass, classAlien())) {
				
#        if COGMTVM
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (((assert(isAlien(oop)),
				(longAt(oop + BaseHeaderSize)) > 0))
				 && (isYoung(oop)))) {
					return -PrimErrObjectMayMove;
				}
#        endif /* COGMTVM */
				ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
					? (oop + BaseHeaderSize) + BytesPerOop
					: longAt((oop + BaseHeaderSize) + BytesPerOop));
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ptrAddress);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			
#      if COGMTVM

			/* Since all the following pass the address of the first indexable field we need to fail
			   the call if it is threaded and the object is young, since it may move during the call. */
			if ((((calloutState->callFlags)) & FFICallFlagThreaded)
			 && (isYoung(oop))) {
				return -PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			if ((ptrClass == (classByteArray()))
			 && ((atomicType == FFITypeVoid)
			 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
				/* begin ffiPushPointer:in: */
				pointer1 = ((void *) (firstIndexableField(oop)));
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), pointer1);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if ((isShorts(oop))
			 && ((atomicType == FFITypeVoid)
			 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
				/* begin ffiPushPointer:in: */
				pointer2 = ((void *) (firstIndexableField(oop)));
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), pointer2);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if ((isWords(oop))
			 && ((atomicType == FFITypeVoid)
			 || ((atomicType == FFITypeSingleFloat)
			 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
				/* begin ffiPushPointer:in: */
				pointer3 = ((void *) (firstIndexableField(oop)));
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), pointer3);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if ((isLong64s(oop))
			 && ((atomicType == FFITypeVoid)
			 || ((atomicType == FFITypeDoubleFloat)
			 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
				/* begin ffiPushPointer:in: */
				pointer4 = ((void *) (firstIndexableField(oop)));
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), pointer4);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			return FFIErrorCoercionFailed;

		default:
			return FFIErrorWrongType;

		}
	}
	else {

		/* If specified, the required class of the argument shall be subclass of ExternalStructure */
		if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
			return FFIErrorWrongType;
		}
		
		switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
		case FFIFlagAtomic:
			/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
			if (includesBehaviorThatOf(oopClass, argClass)) {

				/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
				handle4 = fetchPointerofObject(0, oop);
				/* begin ffiArgByValue:in: */
				typeSpec11 = (calloutState->ffiArgHeader);
				atomicType11 = ((usqInt)((typeSpec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType11 < 0)
				 || (atomicType11 > FFITypeDoubleFloat)) {
					return FFIErrorBadAtomicType;
				}
				if (atomicType11 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType11)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue3 = handle4;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (handle4 & (BytesPerWord - 1)) {
							if (isIntegerObject(handle4)) {
								intValue3 = integerValueOf(handle4);
								goto l14;
							}
							
#              if SPURVM
							if (isCharacterObject(handle4)) {

								/* Immediate in Spur */
								intValue3 = characterValueOf(handle4);
								goto l14;
							}
							if (isFloatObject(handle4)) {

								/* Immediate in 64-bit Spur */
								intValue3 = floatValueOf(handle4);
								goto l14;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(handle4)) {
								intValue3 = characterValueOf(handle4);
								goto l14;
							}
#              endif /* SPURVM */
							if (isFloatObject(handle4)) {
								intValue3 = floatValueOf(handle4);
								goto l14;
							}
							if (handle4 == (nilObject())) {
								intValue3 = 0;
								goto l14;
							}
							if (handle4 == (falseObject())) {
								intValue3 = 0;
								goto l14;
							}
							if (handle4 == (trueObject())) {
								intValue3 = 1;
								goto l14;
							}
							if (isLargePositiveIntegerObject(handle4)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue3 = positive64BitValueOf(handle4);
								goto l14;
#                else /* BytesPerWord == 8 */
								intValue3 = positive32BitValueOf(handle4);
								goto l14;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue3 = signedMachineIntegerValueOf(handle4);
	l14:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						return FFIErrorCoercionFailed;
					}
					
					switch (atomicType11) {
					case 0:
						return FFIErrorAttemptToPassVoid;
					case 1:
						return ffiPushUnsignedIntin(intValue3, calloutState);
					case 2:
						return ffiPushUnsignedBytein(intValue3, calloutState);
					case 3:
						return ffiPushSignedBytein(intValue3, calloutState);
					case 4:
						return ffiPushUnsignedShortin(intValue3, calloutState);
					case 5:
						return ffiPushSignedShortin(intValue3, calloutState);
					case 6:
						return ffiPushUnsignedIntin(intValue3, calloutState);
					case 7:
						return ffiPushSignedIntin(intValue3, calloutState);
					case 8:
						return ffiPushUnsignedLongLongOopin(intValue3, calloutState);
					case 9:
						return ffiPushSignedLongLongOopin(intValue3, calloutState);
					case 10:
						return ffiPushUnsignedCharin(intValue3, calloutState);
					case 11:
						return ffiPushSignedCharin(intValue3, calloutState);

					default:
						error("Case not found");
						return -1;
					}
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(handle4)) {
					floatValue3 = floatValueOf(handle4);
					goto l17;
				}
				floatValue3 = ((double) (ffiIntegerValueOf(handle4)) );
	l17:	/* end ffiFloatValueOf: */;
				if (failed()) {
					return FFIErrorCoercionFailed;
				}
				if (atomicType11 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState->backfillFloatRegisterIndex)) > 0) {
							((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue3;
							(calloutState->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue3;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue3);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
							(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue3;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						(calloutState->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState->currentArg), floatValue3);
						(calloutState->currentArg = ((calloutState->currentArg)) + 8);
					}
					return 0;
				}
			}
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Fetch the type specification and check against expectedClass */
				type2 = fetchPointerofObject(1, oop);
				if (!((isPointers(type2))
					 && ((slotSizeOf(type2)) >= 2))) {
					return FFIErrorWrongType;
				}
				referentClass2 = fetchPointerofObject(1, type2);
				if (!(includesBehaviorThatOf(referentClass2, argClass))) {
					return FFIErrorCoercionFailed;
				}
				handle4 = fetchPointerofObject(0, oop);
				ptrClass2 = fetchClassOf(handle4);
				if (ptrClass2 == (classExternalAddress())) {

					/* Don't you dare to pass pointers into object memory */
					pointer6 = fetchPointerofObject(0, handle4);
					if (isInMemory(pointer6)) {
						return FFIErrorInvalidPointer;
					}
				}
				else {
					if (ptrClass2 == (classByteArray())) {
						pointer6 = ((void *) (firstIndexableField(handle4)));
					}
					else {
						return FFIErrorBadArg;
					}
				}
				/* begin atomicTypeOf: */
				typeSpec4 = (calloutState->ffiArgHeader);
				atomicType4 = ((usqInt)((typeSpec4 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				
				switch (atomicType4) {
				case 0:
					return FFIErrorAttemptToPassVoid;
				case 1:
					return ffiPushDereferenceUnsignedIntin(pointer6, calloutState);
				case 2:
					return ffiPushDereferenceUnsignedBytein(pointer6, calloutState);
				case 3:
					return ffiPushDereferenceSignedBytein(pointer6, calloutState);
				case 4:
					return ffiPushDereferenceUnsignedShortin(pointer6, calloutState);
				case 5:
					return ffiPushDereferenceSignedShortin(pointer6, calloutState);
				case 6:
					return ffiPushDereferenceUnsignedIntin(pointer6, calloutState);
				case 7:
					return ffiPushDereferenceSignedIntin(pointer6, calloutState);
				case 8:
					return ffiPushDereferenceUnsignedLongLongin(pointer6, calloutState);
				case 9:
					return ffiPushDereferenceSignedLongLongin(pointer6, calloutState);
				case 10:
					return ffiPushDereferenceUnsignedCharin(pointer6, calloutState);
				case 11:
					return ffiPushDereferenceSignedCharin(pointer6, calloutState);
				case 12:
					return ffiPushDereferenceSingleFloatin(pointer6, calloutState);
				case 13:
					return ffiPushDereferenceDoubleFloatin(pointer6, calloutState);

				default:
					error("Case not found");
					return -1;
				}
			}
			if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

				/* We do not have any type specification easily available.
				   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
				handle4 = fetchPointerofObject(0, oop);
				/* begin ffiArgByValue:in: */
				typeSpec21 = (calloutState->ffiArgHeader);
				atomicType21 = ((usqInt)((typeSpec21 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType21 < 0)
				 || (atomicType21 > FFITypeDoubleFloat)) {
					return FFIErrorBadAtomicType;
				}
				if (atomicType21 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType21)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue11 = handle4;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (handle4 & (BytesPerWord - 1)) {
							if (isIntegerObject(handle4)) {
								intValue11 = integerValueOf(handle4);
								goto l13;
							}
							
#              if SPURVM
							if (isCharacterObject(handle4)) {

								/* Immediate in Spur */
								intValue11 = characterValueOf(handle4);
								goto l13;
							}
							if (isFloatObject(handle4)) {

								/* Immediate in 64-bit Spur */
								intValue11 = floatValueOf(handle4);
								goto l13;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(handle4)) {
								intValue11 = characterValueOf(handle4);
								goto l13;
							}
#              endif /* SPURVM */
							if (isFloatObject(handle4)) {
								intValue11 = floatValueOf(handle4);
								goto l13;
							}
							if (handle4 == (nilObject())) {
								intValue11 = 0;
								goto l13;
							}
							if (handle4 == (falseObject())) {
								intValue11 = 0;
								goto l13;
							}
							if (handle4 == (trueObject())) {
								intValue11 = 1;
								goto l13;
							}
							if (isLargePositiveIntegerObject(handle4)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue11 = positive64BitValueOf(handle4);
								goto l13;
#                else /* BytesPerWord == 8 */
								intValue11 = positive32BitValueOf(handle4);
								goto l13;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue11 = signedMachineIntegerValueOf(handle4);
	l13:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						return FFIErrorCoercionFailed;
					}
					
					switch (atomicType21) {
					case 0:
						return FFIErrorAttemptToPassVoid;
					case 1:
						return ffiPushUnsignedIntin(intValue11, calloutState);
					case 2:
						return ffiPushUnsignedBytein(intValue11, calloutState);
					case 3:
						return ffiPushSignedBytein(intValue11, calloutState);
					case 4:
						return ffiPushUnsignedShortin(intValue11, calloutState);
					case 5:
						return ffiPushSignedShortin(intValue11, calloutState);
					case 6:
						return ffiPushUnsignedIntin(intValue11, calloutState);
					case 7:
						return ffiPushSignedIntin(intValue11, calloutState);
					case 8:
						return ffiPushUnsignedLongLongOopin(intValue11, calloutState);
					case 9:
						return ffiPushSignedLongLongOopin(intValue11, calloutState);
					case 10:
						return ffiPushUnsignedCharin(intValue11, calloutState);
					case 11:
						return ffiPushSignedCharin(intValue11, calloutState);

					default:
						error("Case not found");
						return -1;
					}
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(handle4)) {
					floatValue11 = floatValueOf(handle4);
					goto l15;
				}
				floatValue11 = ((double) (ffiIntegerValueOf(handle4)) );
	l15:	/* end ffiFloatValueOf: */;
				if (failed()) {
					return FFIErrorCoercionFailed;
				}
				if (atomicType21 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState->backfillFloatRegisterIndex)) > 0) {
							((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue11;
							(calloutState->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue11;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue11);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
							(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue11;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						(calloutState->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState->currentArg), floatValue11);
						(calloutState->currentArg = ((calloutState->currentArg)) + 8);
					}
					return 0;
				}
			}
			if (!0) {
				return FFIErrorCoercionFailed;
			}
			/* begin ffiArgByValue:in: */
			typeSpec31 = (calloutState->ffiArgHeader);
			atomicType31 = ((usqInt)((typeSpec31 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
			if ((atomicType31 < 0)
			 || (atomicType31 > FFITypeDoubleFloat)) {
				return FFIErrorBadAtomicType;
			}
			if (atomicType31 < FFITypeSingleFloat) {

				/* integer types */
				if ((((usqInt)(atomicType31)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

					/* ffi support code must coerce longlong */
					intValue2 = oop;
				}
				else {
					/* begin ffiIntegerValueOf: */
					if (oop & (BytesPerWord - 1)) {
						if (isIntegerObject(oop)) {
							intValue2 = integerValueOf(oop);
							goto l18;
						}
						
#            if SPURVM
						if (isCharacterObject(oop)) {

							/* Immediate in Spur */
							intValue2 = characterValueOf(oop);
							goto l18;
						}
						if (isFloatObject(oop)) {

							/* Immediate in 64-bit Spur */
							intValue2 = floatValueOf(oop);
							goto l18;
						}
#            endif /* SPURVM */
					}
					else {
						
#            if SPURVM

						/* No non-immediate characters in Spur */
#            else /* SPURVM */
						if (isCharacterObject(oop)) {
							intValue2 = characterValueOf(oop);
							goto l18;
						}
#            endif /* SPURVM */
						if (isFloatObject(oop)) {
							intValue2 = floatValueOf(oop);
							goto l18;
						}
						if (oop == (nilObject())) {
							intValue2 = 0;
							goto l18;
						}
						if (oop == (falseObject())) {
							intValue2 = 0;
							goto l18;
						}
						if (oop == (trueObject())) {
							intValue2 = 1;
							goto l18;
						}
						if (isLargePositiveIntegerObject(oop)) {
							
#              if BytesPerWord == 8

							/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
							intValue2 = positive64BitValueOf(oop);
							goto l18;
#              else /* BytesPerWord == 8 */
							intValue2 = positive32BitValueOf(oop);
							goto l18;
#              endif /* BytesPerWord == 8 */
						}
					}
					intValue2 = signedMachineIntegerValueOf(oop);
	l18:	/* end ffiIntegerValueOf: */;
				}
				if (failed()) {
					return FFIErrorCoercionFailed;
				}
				
				switch (atomicType31) {
				case 0:
					return FFIErrorAttemptToPassVoid;
				case 1:
					return ffiPushUnsignedIntin(intValue2, calloutState);
				case 2:
					return ffiPushUnsignedBytein(intValue2, calloutState);
				case 3:
					return ffiPushSignedBytein(intValue2, calloutState);
				case 4:
					return ffiPushUnsignedShortin(intValue2, calloutState);
				case 5:
					return ffiPushSignedShortin(intValue2, calloutState);
				case 6:
					return ffiPushUnsignedIntin(intValue2, calloutState);
				case 7:
					return ffiPushSignedIntin(intValue2, calloutState);
				case 8:
					return ffiPushUnsignedLongLongOopin(intValue2, calloutState);
				case 9:
					return ffiPushSignedLongLongOopin(intValue2, calloutState);
				case 10:
					return ffiPushUnsignedCharin(intValue2, calloutState);
				case 11:
					return ffiPushSignedCharin(intValue2, calloutState);

				default:
					error("Case not found");
					return -1;
				}
			}
			/* begin ffiFloatValueOf: */
			if (isFloatObject(oop)) {
				floatValue2 = floatValueOf(oop);
				goto l16;
			}
			floatValue2 = ((double) (ffiIntegerValueOf(oop)) );
	l16:	/* end ffiFloatValueOf: */;
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
			if (atomicType31 == FFITypeSingleFloat) {
				/* begin ffiPushSingleFloat:in: */
				if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
					if (((calloutState->backfillFloatRegisterIndex)) > 0) {
						((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue2;
						(calloutState->backfillFloatRegisterIndex = 0);
					}
					else {
						((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue2;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
					}
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue2);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			else {
				/* begin ffiPushDoubleFloat:in: */
				if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
					if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
						(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
					}
					(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue2;
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
				}
				else {
					if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					(calloutState->floatRegisterIndex = NumFloatRegArgs);
					storeFloatAtPointerfrom((calloutState->currentArg), floatValue2);
					(calloutState->currentArg = ((calloutState->currentArg)) + 8);
				}
				return 0;
			}

		case FFIFlagAtomic + FFIFlagPointer:
			/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Fetch the type specification and check against expectedClass */
				type = fetchPointerofObject(1, oop);
				if (!((isPointers(type))
					 && ((slotSizeOf(type)) >= 2))) {
					return FFIErrorWrongType;
				}
				referentClass = fetchPointerofObject(1, type);
				if (!(includesBehaviorThatOf(referentClass, argClass))) {
					return FFIErrorCoercionFailed;
				}
				handle1 = fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(handle1, calloutState);
			}
			if (oop == (nilObject())) {
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), null);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			return FFIErrorCoercionFailed;

		case FFIFlagStructure:
			/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
			if (includesBehaviorThatOf(oopClass, argClass)) {

				/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
				handle5 = fetchPointerofObject(0, oop);
				/* begin ffiPushStructureContentsOf:in: */
				ptrClass3 = fetchClassOf(handle5);
				if (ptrClass3 == (classExternalAddress())) {

					/* ExternalAddress is bytes */

					/* There is no way we can make sure the structure is valid.
					   But we can at least check for attempts to pass pointers to ST memory. */
					ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
					if (isInMemory(ptrAddress2)) {
						return FFIErrorInvalidPointer;
					}
					/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
					structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
					argSpec3 = (calloutState->ffiArgSpec);
					argSpecSize = (calloutState->ffiArgSpecSize);
					availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
					stackPartSize = structSize;
					if (availableRegisterSpace > 0) {
						if (structSize <= availableRegisterSpace) {

							/* all in registers */
							stackPartSize = 0;
							memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize);
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
						}
						else {

							/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
							   Otherwise push entire struct on stack. */
							if (((calloutState->currentArg)) == ((calloutState->argVector))) {
								stackPartSize = structSize - availableRegisterSpace;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace);
							}
							else {
								availableRegisterSpace = 0;
							}
							(calloutState->integerRegisterIndex = NumIntRegArgs);
						}
					}
					if (stackPartSize > 0) {
						roundedSize = (((stackPartSize + 3) | 3) - 3);
						if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace])), stackPartSize);
						(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
					}
					return 0;
				}
				if (ptrClass3 == (classByteArray())) {

					/* The following is a somewhat pessimistic test but I like being sure... */
					if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
						return FFIErrorStructSize;
					}
					ptrAddress2 = firstIndexableField(handle5);
					if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

						/* Since this involves passing the address of the first indexable field we need to fail
						   the call if it is threaded and the object is young, since it may move during the call. */
						
#            if COGMTVM
						if ((((calloutState->callFlags)) & FFICallFlagThreaded)
						 && (isYoung(handle5))) {
							return -PrimErrObjectMayMove;
						}
#            endif /* COGMTVM */
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
						argSpec1 = (calloutState->ffiArgSpec);
						argSpecSize1 = (calloutState->ffiArgSpecSize);
						availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
						stackPartSize1 = structSize1;
						if (availableRegisterSpace1 > 0) {
							if (structSize1 <= availableRegisterSpace1) {

								/* all in registers */
								stackPartSize1 = 0;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize1);
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState->currentArg)) == ((calloutState->argVector))) {
									stackPartSize1 = structSize1 - availableRegisterSpace1;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace1);
								}
								else {
									availableRegisterSpace1 = 0;
								}
								(calloutState->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize1 > 0) {
							roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
							if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace1])), stackPartSize1);
							(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
						}
						return 0;
					}
					if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
						return FFIErrorStructSize;
					}
					ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
					if (isInMemory(ptrAddress2)) {
						return FFIErrorInvalidPointer;
					}
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress2));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), ptrAddress2);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				return FFIErrorBadArg;
			}
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Fetch the type specification and check against expectedClass */
				type3 = fetchPointerofObject(1, oop);
				if (!((isPointers(type3))
					 && ((slotSizeOf(type3)) >= 2))) {
					return FFIErrorWrongType;
				}
				referentClass3 = fetchPointerofObject(1, type3);
				if (!(includesBehaviorThatOf(referentClass3, argClass))) {
					return FFIErrorCoercionFailed;
				}
				handle5 = fetchPointerofObject(0, oop);
				/* begin ffiPushStructureContentsOf:in: */
				ptrClass11 = fetchClassOf(handle5);
				if (ptrClass11 == (classExternalAddress())) {

					/* ExternalAddress is bytes */

					/* There is no way we can make sure the structure is valid.
					   But we can at least check for attempts to pass pointers to ST memory. */
					ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
					if (isInMemory(ptrAddress1)) {
						return FFIErrorInvalidPointer;
					}
					/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
					structSize2 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
					argSpec2 = (calloutState->ffiArgSpec);
					argSpecSize2 = (calloutState->ffiArgSpecSize);
					availableRegisterSpace2 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
					stackPartSize2 = structSize2;
					if (availableRegisterSpace2 > 0) {
						if (structSize2 <= availableRegisterSpace2) {

							/* all in registers */
							stackPartSize2 = 0;
							memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize2);
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize2 + 3))) >> 2)));
						}
						else {

							/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
							   Otherwise push entire struct on stack. */
							if (((calloutState->currentArg)) == ((calloutState->argVector))) {
								stackPartSize2 = structSize2 - availableRegisterSpace2;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace2);
							}
							else {
								availableRegisterSpace2 = 0;
							}
							(calloutState->integerRegisterIndex = NumIntRegArgs);
						}
					}
					if (stackPartSize2 > 0) {
						roundedSize2 = (((stackPartSize2 + 3) | 3) - 3);
						if ((((calloutState->currentArg)) + roundedSize2) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace2])), stackPartSize2);
						(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize2);
					}
					return 0;
				}
				if (ptrClass11 == (classByteArray())) {

					/* The following is a somewhat pessimistic test but I like being sure... */
					if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
						return FFIErrorStructSize;
					}
					ptrAddress1 = firstIndexableField(handle5);
					if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

						/* Since this involves passing the address of the first indexable field we need to fail
						   the call if it is threaded and the object is young, since it may move during the call. */
						
#            if COGMTVM
						if ((((calloutState->callFlags)) & FFICallFlagThreaded)
						 && (isYoung(handle5))) {
							return -PrimErrObjectMayMove;
						}
#            endif /* COGMTVM */
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize11 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
						argSpec11 = (calloutState->ffiArgSpec);
						argSpecSize11 = (calloutState->ffiArgSpecSize);
						availableRegisterSpace11 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
						stackPartSize11 = structSize11;
						if (availableRegisterSpace11 > 0) {
							if (structSize11 <= availableRegisterSpace11) {

								/* all in registers */
								stackPartSize11 = 0;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize11);
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize11 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState->currentArg)) == ((calloutState->argVector))) {
									stackPartSize11 = structSize11 - availableRegisterSpace11;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace11);
								}
								else {
									availableRegisterSpace11 = 0;
								}
								(calloutState->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize11 > 0) {
							roundedSize11 = (((stackPartSize11 + 3) | 3) - 3);
							if ((((calloutState->currentArg)) + roundedSize11) > ((calloutState->limit))) {
								return FFIErrorCallFrameTooBig;
							}
							memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace11])), stackPartSize11);
							(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize11);
						}
						return 0;
					}
					if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
						return FFIErrorStructSize;
					}
					ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
					if (isInMemory(ptrAddress1)) {
						return FFIErrorInvalidPointer;
					}
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress1));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), ptrAddress1);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				return FFIErrorBadArg;
			}
			return FFIErrorCoercionFailed;

		case FFIFlagStructure + FFIFlagPointer:
			/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
			if (includesBehaviorThatOf(oopClass, argClass)) {

				/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
				handle2 = fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(handle2, calloutState);
			}
			if (includesBehaviorThatOf(oopClass, classExternalData())) {

				/* Fetch the type specification and check against expectedClass */
				type1 = fetchPointerofObject(1, oop);
				if (!((isPointers(type1))
					 && ((slotSizeOf(type1)) >= 2))) {
					return FFIErrorWrongType;
				}
				referentClass1 = fetchPointerofObject(1, type1);
				if (!(includesBehaviorThatOf(referentClass1, argClass))) {
					return FFIErrorCoercionFailed;
				}
				handle2 = fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(handle2, calloutState);
			}
			if (oop == (nilObject())) {
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), null);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			return FFIErrorCoercionFailed;

		default:
			return FFIErrorWrongType;

		}
	}
	return 0;
}


/*	Go out, call this guy and create the return value. This *must* be inlined
	because of
	the alloca of the outgoing stack frame in
	ffiCall:WithFlags:NumArgs:Args:AndTypes: 
 */

	/* ThreadedARM32FFIPlugin>>#ffiCalloutTo:SpecOnStack:in: */
static sqInt
ffiCalloutToSpecOnStackin(void *procAddr, sqInt specOnStack, CalloutState *calloutState)
{
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt byteSize;
    sqInt cPointer;
    char *cString;
    sqInt ffiRetType;
    double floatRet;
    sqInt i;
    usqLong intRet;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    usqLong mask;
    sqInt myThreadIndex;
    sqInt oop;
    sqInt oop1;
    sqInt *ptr;
    sqInt retClass;
    sqInt retClass1;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    sqInt shift;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;
    sqInt typeSpec1;
    usqLong value;

	myThreadIndex = disownVM(
#  if COGMTVM
		(((calloutState->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		);
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs((((double *) ((&(((calloutState->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState->floatRegisters))[14])))))[0]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType == FFITypeSingleFloat) {
			floatRet = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		}
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(myThreadIndex);
		return floatObjectOf(floatRet);
	}

	/* undo any callee argument pops because it may confuse stack management with the alloca. */
	intRet = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) procAddr), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	ownVM(myThreadIndex);
	if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			specLiteral = (specOnStack
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
			retType = fetchPointerofObject(0, argTypes);
			retClass = fetchPointerofObject(1, retType);
			if (retClass == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec1 = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer = ((usqInt) intRet);
					if (!(cPointer)) {
						retOop = nilObject();
						goto l3;
					}
					cString = ((char *) cPointer);
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(), strLen);
					strPtr = firstIndexableField(strOop);
					for (i = 0; i < strLen; i += 1) {
						strPtr[i] = (cString[i]);
					}
					retOop = strOop;
	l3:	/* end ffiReturnCStringFrom: */;
					return retOop;
				}
			}
			
#if SPURVM
			oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr = firstIndexableField(oop);
			ptr[0] = (((sqInt) intRet));
			retOop = instantiateClassindexableSize(classExternalData(), 0);
			storePointerofObjectwithValue(0, retOop, oop);

#else /* SPURVM */
			pushRemappableOop(retType);
			oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr = firstIndexableField(oop);
			ptr[0] = (((sqInt) intRet));
						pushRemappableOop(oop);
			retOop = instantiateClassindexableSize(classExternalData(), 0);
			oop = popRemappableOop();
			storePointerofObjectwithValue(0, retOop, oop);
			retType = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(1, retOop, retType);
			return retOop;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr = (&intRet);
		/* begin ffiReturnType: */
		specLiteral1 = (specOnStack
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		ffiRetType = fetchPointerofObject(0, argTypes1);
		retClass1 = fetchPointerofObject(1, ffiRetType);
		retOop1 = instantiateClassindexableSize(retClass1, 0);
		
#if SPURVM
		oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));

#else /* SPURVM */
		pushRemappableOop(retOop1);
		oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop1 = popRemappableOop()
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop1), ((calloutState->structReturnType)
			? longLongRetPtr
			: (calloutState->limit)), (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop1, oop1);
		return retOop1;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(intRet))
			? intRet
			: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		return (value == 0
			? falseObject()
			: trueObject());
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt)(atomicType)) >> 1) * 8);
			value = intRet & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			return integerObjectOf(value);
		}
		return (atomicType & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(intRet)
					: signed32BitIntegerFor(intRet))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(intRet)
					: positive32BitIntegerFor(intRet)));
	}
	return ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)
		? (atomicType & 1
				? signed64BitIntegerFor(intRet)
				: positive64BitIntegerFor(intRet))
		: characterObjectOf(intRet & 0xFF));
}


/*	Generic callout. Does the actual work. If argArrayOrNil is nil it takes
	args from the stack
	and the spec from the method. If argArrayOrNil is not nil takes args from
	argArrayOrNil and the spec from the receiver. */

	/* ThreadedFFIPlugin>>#ffiCall:ArgArrayOrNil:NumArgs: */
static sqInt
ffiCallArgArrayOrNilNumArgs(sqInt externalFunction, sqInt argArrayOrNil, sqInt nArgs)
{
    sqInt address;
    sqInt address1;
    sqInt addressPtr;
    sqInt alias;
    char *allocation;
    sqInt argClass;
    sqInt argSpec;
    sqInt *argSpec1;
    sqInt *argSpec11;
    sqInt *argSpec2;
    sqInt *argSpec3;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt argSpecSize11;
    sqInt argSpecSize2;
    sqInt argType;
    sqInt argTypeArray;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType12;
    sqInt atomicType2;
    sqInt atomicType21;
    sqInt atomicType3;
    sqInt atomicType31;
    sqInt atomicType4;
    sqInt atomicType5;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt availableRegisterSpace11;
    sqInt availableRegisterSpace2;
    sqInt byteSize;
    CalloutState *calloutState;
    char *copy;
    sqInt cPointer;
    char *cString;
    sqInt err;
    sqInt ffiRetType;
    sqInt flags;
    double floatRet;
    double floatValue;
    double floatValue1;
    double floatValue11;
    double floatValue2;
    double floatValue3;
    sqInt functionName;
    sqInt handle;
    sqInt handle1;
    sqInt handle2;
    sqInt handle3;
    sqInt handle4;
    sqInt handle5;
    sqInt i;
    sqInt i1;
    usqLong intRet;
    sqInt intValue;
    sqInt intValue1;
    sqInt intValue11;
    sqInt intValue2;
    sqInt intValue3;
    sqInt length;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    usqLong mask;
    sqInt myThreadIndex;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oopClass;
    void *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void *pointer5;
    void *pointer6;
    char *pointer7;
    sqInt primNumArgs;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    void * ptrAddress;
    void * ptrAddress1;
    void * ptrAddress2;
    sqInt ptrClass;
    sqInt ptrClass1;
    sqInt ptrClass11;
    sqInt ptrClass2;
    sqInt ptrClass3;
    sqInt ptrType;
    sqInt ptrType1;
    sqInt referentClass;
    sqInt referentClass1;
    sqInt referentClass2;
    sqInt referentClass3;
    sqInt requiredStackSize;
    sqInt result;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass2;
    sqInt retOop;
    sqInt retOop1;
    sqInt retType;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt roundedSize11;
    sqInt roundedSize2;
    sqInt shift;
    sqInt spec;
    sqInt spec1;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specOop;
    sqInt specOop1;
    sqInt specType;
    sqInt specType1;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt stackPartSize11;
    sqInt stackPartSize2;
    sqInt stackSize;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt structSize;
    sqInt structSize1;
    sqInt structSize11;
    sqInt structSize2;
    CalloutState theCalloutState;
    sqInt type;
    sqInt type1;
    sqInt type2;
    sqInt type3;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec12;
    sqInt typeSpec2;
    sqInt typeSpec21;
    sqInt typeSpec3;
    sqInt typeSpec31;
    sqInt typeSpec4;
    sqInt typeSpec5;
    usqLong value;

	pointer5 = ((void *) 0);
	pointer6 = ((void *) 0);
	primNumArgs = methodArgumentCount();
	if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
		return ffiFail(FFIErrorNotFunction);
	}
	flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (failed()) {
		return ffiFail(FFIErrorBadArgs);
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, externalFunction);
	if (!((isBytes(addressPtr))
		 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l1;
	}
	address1 = fetchPointerofObject(0, addressPtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		address = 0;
		goto l2;
	}
	if (address1 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1));
		}
		if ((slotSizeOf(externalFunction)) < 5) {
			address = ffiFail(FFIErrorNoModule);
			goto l2;
		}
		address1 = ffiLoadCalloutAddressFrom(externalFunction);
		if (failed()) {
			address = 0;
			goto l2;
		}
		ptr = firstIndexableField(addressPtr);
		ptr[0] = address1;
	}
	address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
	if (failed()) {
		return 0;
	}

	/* must be array of arg types */
	argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((isArray(argTypeArray))
		 && ((slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
		return ffiFail(FFIErrorBadArgs);
	}
	
#  if COGMTVM
	if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
		return ffiFail(FFIErrorCallType);
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags == FFICallTypeCDecl)
		 || (flags == FFICallTypeApi))) {
		return ffiFail(FFIErrorCallType);
	}
#  endif /* COGMTVM */
	if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
		requiredStackSize = fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction);
	}
	else {
		requiredStackSize = -1;
	}
	if (failed()) {
		return primitiveFailFor((argArrayOrNil == null
			? PrimErrBadMethod
			: PrimErrBadReceiver));
	}
	stackSize = (requiredStackSize < 0
		? DefaultMaxStackSize
		: requiredStackSize);
	calloutState = (&theCalloutState);
	memset(calloutState, 0, sizeof(CalloutState));
	(calloutState->callFlags = flags);
	argType = fetchPointerofObject(0, argTypeArray);
	argSpec = fetchPointerofObject(0, argType);
	retClass = fetchPointerofObject(1, argType);
	if (((err = ffiCheckReturnWithin(argSpec, retClass, calloutState))) != 0) {
		return ffiFail(err);
	}
	allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState->argVector = allocation);
	(calloutState->currentArg = allocation);
	(calloutState->limit = allocation + stackSize);
	if ((((calloutState->structReturnSize)) > 0)
	 && (1
	 && (!((calloutState->structReturnType))))) {
		/* begin ffiPushPointer:in: */
		pointer = (calloutState->limit);
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				err = FFIErrorCallFrameTooBig;
				goto l4;
			}
			longAtput((calloutState->currentArg), pointer);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		err = 0;
	l4:	/* end ffiPushPointer:in: */;
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				return PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			return ffiFail(err);
		}
	}
	for (i = 1; i <= nArgs; i += 1) {
		argType = fetchPointerofObject(i, argTypeArray);
		argSpec = fetchPointerofObject(0, argType);
		argClass = fetchPointerofObject(1, argType);
		oop = (argArrayOrNil == null
			? stackValue(nArgs - i)
			: fetchPointerofObject(i - 1, argArrayOrNil));
		/* begin ffiArgument:Spec:Class:in: */
		if (!(isWords(argSpec))) {
			err = FFIErrorWrongType;
			goto l33;
		}
		(calloutState->ffiArgSpecSize = slotSizeOf(argSpec));
		if (((calloutState->ffiArgSpecSize)) == 0) {
			err = FFIErrorWrongType;
			goto l33;
		}
		(calloutState->ffiArgSpec = firstIndexableField(argSpec));
		(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));

		/* Prefetch class (we'll need it) */
		oopClass = fetchClassOf(oop);
		nilOop = nilObject();
		if (nilOop == argClass) {
			
			switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:In: */
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Fetch the type specification and check: we handle pointer to an atomic type */
					/* begin atomicTypeOf: */
					typeSpec3 = (calloutState->ffiArgHeader);
					atomicType3 = ((usqInt)((typeSpec3 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType1 = fetchPointerofObject(1, oop);
					if (!((isPointers(ptrType1))
						 && ((slotSizeOf(ptrType1)) >= 2))) {
						goto l11;
					}
					specOop1 = fetchPointerofObject(0, ptrType1);
					if (!((isWords(specOop1))
						 && ((slotSizeOf(specOop1)) > 0))) {
						goto l11;
					}
					spec1 = fetchPointerofObject(0, specOop1);
					if (!(spec1 & FFIFlagAtomic)) {
						goto l11;
					}
					/* begin atomicTypeOf: */
					specType1 = ((usqInt)((spec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (specType1 != atomicType3) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType3 >= FFITypeUnsignedByte)
							 && ((atomicType3 <= FFITypeSignedChar)
							 && ((((usqInt)(atomicType3)) >> 1) == (((usqInt)(specType1)) >> 1))))) {
							goto l11;
						}
					}
	l11:	/* end ffiValidateExternalData:AtomicType: */;
					if (failed()) {
						err = null;
						goto l33;
					}
					handle3 = fetchPointerofObject(0, oop);
					ptrClass1 = fetchClassOf(handle3);
					if (ptrClass1 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer5 = fetchPointerofObject(0, handle3);
						if (isInMemory(pointer5)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
					}
					else {
						if (ptrClass1 == (classByteArray())) {
							pointer5 = ((void *) (firstIndexableField(handle3)));
						}
						else {
							err = FFIErrorBadArg;
							goto l33;
						}
					}
					switch (atomicType3) {
					case 0:
						err = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err = ffiPushDereferenceUnsignedIntin(pointer5, calloutState);
						break;
					case 2:
						err = ffiPushDereferenceUnsignedBytein(pointer5, calloutState);
						break;
					case 3:
						err = ffiPushDereferenceSignedBytein(pointer5, calloutState);
						break;
					case 4:
						err = ffiPushDereferenceUnsignedShortin(pointer5, calloutState);
						break;
					case 5:
						err = ffiPushDereferenceSignedShortin(pointer5, calloutState);
						break;
					case 7:
						err = ffiPushDereferenceSignedIntin(pointer5, calloutState);
						break;
					case 8:
						err = ffiPushDereferenceUnsignedLongLongin(pointer5, calloutState);
						break;
					case 9:
						err = ffiPushDereferenceSignedLongLongin(pointer5, calloutState);
						break;
					case 10:
						err = ffiPushDereferenceUnsignedCharin(pointer5, calloutState);
						break;
					case 11:
						err = ffiPushDereferenceSignedCharin(pointer5, calloutState);
						break;
					case 12:
						err = ffiPushDereferenceSingleFloatin(pointer5, calloutState);
						break;
					case 13:
						err = ffiPushDereferenceDoubleFloatin(pointer5, calloutState);
						break;

					default:
						error("Case not found");
					}
					goto l33;
				}
				if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle3 = fetchPointerofObject(0, oop);
					/* begin ffiArgByValue:in: */
					typeSpec12 = (calloutState->ffiArgHeader);
					atomicType12 = ((usqInt)((typeSpec12 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType12 < 0)
					 || (atomicType12 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType12 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType12)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue = handle3;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle3 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle3)) {
									intValue = integerValueOf(handle3);
									goto l29;
								}
								
#                if SPURVM
								if (isCharacterObject(handle3)) {

									/* Immediate in Spur */
									intValue = characterValueOf(handle3);
									goto l29;
								}
								if (isFloatObject(handle3)) {

									/* Immediate in 64-bit Spur */
									intValue = floatValueOf(handle3);
									goto l29;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle3)) {
									intValue = characterValueOf(handle3);
									goto l29;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle3)) {
									intValue = floatValueOf(handle3);
									goto l29;
								}
								if (handle3 == (nilObject())) {
									intValue = 0;
									goto l29;
								}
								if (handle3 == (falseObject())) {
									intValue = 0;
									goto l29;
								}
								if (handle3 == (trueObject())) {
									intValue = 1;
									goto l29;
								}
								if (isLargePositiveIntegerObject(handle3)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue = positive64BitValueOf(handle3);
									goto l29;
#                  else /* BytesPerWord == 8 */
									intValue = positive32BitValueOf(handle3);
									goto l29;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue = signedMachineIntegerValueOf(handle3);
	l29:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType12) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle3)) {
						floatValue = floatValueOf(handle3);
						goto l32;
					}
					floatValue = ((double) (ffiIntegerValueOf(handle3)) );
	l32:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType12 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
				}
				/* begin ffiArgByValue:in: */
				typeSpec2 = (calloutState->ffiArgHeader);
				atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType2 < 0)
				 || (atomicType2 > FFITypeDoubleFloat)) {
					err = FFIErrorBadAtomicType;
					goto l33;
				}
				if (atomicType2 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue1 = oop;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop & (BytesPerWord - 1)) {
							if (isIntegerObject(oop)) {
								intValue1 = integerValueOf(oop);
								goto l30;
							}
							
#              if SPURVM
							if (isCharacterObject(oop)) {

								/* Immediate in Spur */
								intValue1 = characterValueOf(oop);
								goto l30;
							}
							if (isFloatObject(oop)) {

								/* Immediate in 64-bit Spur */
								intValue1 = floatValueOf(oop);
								goto l30;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop)) {
								intValue1 = characterValueOf(oop);
								goto l30;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop)) {
								intValue1 = floatValueOf(oop);
								goto l30;
							}
							if (oop == (nilObject())) {
								intValue1 = 0;
								goto l30;
							}
							if (oop == (falseObject())) {
								intValue1 = 0;
								goto l30;
							}
							if (oop == (trueObject())) {
								intValue1 = 1;
								goto l30;
							}
							if (isLargePositiveIntegerObject(oop)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue1 = positive64BitValueOf(oop);
								goto l30;
#                else /* BytesPerWord == 8 */
								intValue1 = positive32BitValueOf(oop);
								goto l30;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue1 = signedMachineIntegerValueOf(oop);
	l30:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					switch (atomicType2) {
					case 0:
						err = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err = ffiPushUnsignedIntin(intValue1, calloutState);
						break;
					case 2:
						err = ffiPushUnsignedBytein(intValue1, calloutState);
						break;
					case 3:
						err = ffiPushSignedBytein(intValue1, calloutState);
						break;
					case 4:
						err = ffiPushUnsignedShortin(intValue1, calloutState);
						break;
					case 5:
						err = ffiPushSignedShortin(intValue1, calloutState);
						break;
					case 7:
						err = ffiPushSignedIntin(intValue1, calloutState);
						break;
					case 8:
						err = ffiPushUnsignedLongLongOopin(intValue1, calloutState);
						break;
					case 9:
						err = ffiPushSignedLongLongOopin(intValue1, calloutState);
						break;
					case 10:
						err = ffiPushUnsignedCharin(intValue1, calloutState);
						break;
					case 11:
						err = ffiPushSignedCharin(intValue1, calloutState);
						break;

					default:
						error("Case not found");
					}
					goto l33;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop)) {
					floatValue1 = floatValueOf(oop);
					goto l23;
				}
				floatValue1 = ((double) (ffiIntegerValueOf(oop)) );
	l23:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err = FFIErrorCoercionFailed;
					goto l33;
				}
				if (atomicType2 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState->backfillFloatRegisterIndex)) > 0) {
							((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
							(calloutState->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
							(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						(calloutState->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
						(calloutState->currentArg = ((calloutState->currentArg)) + 8);
					}
					err = 0;
					goto l33;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:In: */
				typeSpec5 = (calloutState->ffiArgHeader);
				atomicType5 = ((usqInt)((typeSpec5 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Check: we handle pointer to an atomic type */
					/* no type checks for void pointers */
					if (atomicType5 != FFITypeVoid) {
						/* begin ffiValidateExternalData:AtomicType: */
						ptrType = fetchPointerofObject(1, oop);
						if (!((isPointers(ptrType))
							 && ((slotSizeOf(ptrType)) >= 2))) {
							goto l27;
						}
						specOop = fetchPointerofObject(0, ptrType);
						if (!((isWords(specOop))
							 && ((slotSizeOf(specOop)) > 0))) {
							goto l27;
						}
						spec = fetchPointerofObject(0, specOop);
						if (!(spec & FFIFlagAtomic)) {
							goto l27;
						}
						/* begin atomicTypeOf: */
						specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if (specType != atomicType5) {

							/* Allow for signed/unsigned conversion but nothing else.
							   See FFIConstants class>>#initializeTypeConstants */
							if (!((atomicType5 >= FFITypeUnsignedByte)
								 && ((atomicType5 <= FFITypeSignedChar)
								 && ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(specType)) >> 1))))) {
								goto l27;
							}
						}
	l27:	/* end ffiValidateExternalData:AtomicType: */;
					}
					if (failed()) {
						err = null;
						goto l33;
					}
					handle = fetchPointerofObject(0, oop);
					err = ffiPushPointerContentsOfin(handle, calloutState);
					goto l33;
				}
				if (oop == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), null);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				if ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* note: the only types allowed for passing into char* types are
					   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
					   (e.g., CompiledMethod, LargeInteger). We only check for strings
					   here and fall through to the byte* check otherwise. */
					if (includesBehaviorThatOf(oopClass, classString())) {
						/* begin ffiPushString:OfLength:in: */
						pointer7 = ((char *) (firstIndexableField(oop)));
						length = byteSizeOf(oop);
						if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
							err = -PrimErrBadNumArgs;
							goto l33;
						}
						copy = malloc(length + 1);
						if (copy == null) {
							err = -PrimErrNoCMemory;
							goto l33;
						}
						memcpy(copy, pointer7, length);
						copy[length] = 0;
						((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
						(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), copy);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					atomicType5 = FFITypeUnsignedByte;
				}
				ptrClass = fetchClassOf(oop);
				if (ptrClass == (classExternalAddress())) {

					/* Don't you dare to pass pointers into object memory */
					ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
					if (isInMemory(ptrAddress)) {
						err = FFIErrorInvalidPointer;
						goto l33;
					}
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), ptrAddress);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				if (includesBehaviorThatOf(ptrClass, classAlien())) {
					
#          if COGMTVM
					if ((((calloutState->callFlags)) & FFICallFlagThreaded)
					 && (((assert(isAlien(oop)),
					(longAt(oop + BaseHeaderSize)) > 0))
					 && (isYoung(oop)))) {
						err = -PrimErrObjectMayMove;
						goto l33;
					}
#          endif /* COGMTVM */
					ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
						? (oop + BaseHeaderSize) + BytesPerOop
						: longAt((oop + BaseHeaderSize) + BytesPerOop));
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), ptrAddress);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				
#        if COGMTVM

				/* Since all the following pass the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(oop))) {
					err = -PrimErrObjectMayMove;
					goto l33;
				}
#        endif /* COGMTVM */
				if ((ptrClass == (classByteArray()))
				 && ((atomicType5 == FFITypeVoid)
				 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer1 = ((void *) (firstIndexableField(oop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), pointer1);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				if ((isShorts(oop))
				 && ((atomicType5 == FFITypeVoid)
				 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer2 = ((void *) (firstIndexableField(oop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), pointer2);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				if ((isWords(oop))
				 && ((atomicType5 == FFITypeVoid)
				 || ((atomicType5 == FFITypeSingleFloat)
				 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer3 = ((void *) (firstIndexableField(oop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), pointer3);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				if ((isLong64s(oop))
				 && ((atomicType5 == FFITypeVoid)
				 || ((atomicType5 == FFITypeDoubleFloat)
				 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer4 = ((void *) (firstIndexableField(oop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), pointer4);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				err = FFIErrorCoercionFailed;
				goto l33;
				break;
			default:
				err = FFIErrorWrongType;
				goto l33;

			}
		}
		else {

			/* If specified, the required class of the argument shall be subclass of ExternalStructure */
			if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
				err = FFIErrorWrongType;
				goto l33;
			}
			
			switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass, argClass)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle4 = fetchPointerofObject(0, oop);
					/* begin ffiArgByValue:in: */
					typeSpec11 = (calloutState->ffiArgHeader);
					atomicType11 = ((usqInt)((typeSpec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType11 < 0)
					 || (atomicType11 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType11 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType11)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue3 = handle4;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle4 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle4)) {
									intValue3 = integerValueOf(handle4);
									goto l14;
								}
								
#                if SPURVM
								if (isCharacterObject(handle4)) {

									/* Immediate in Spur */
									intValue3 = characterValueOf(handle4);
									goto l14;
								}
								if (isFloatObject(handle4)) {

									/* Immediate in 64-bit Spur */
									intValue3 = floatValueOf(handle4);
									goto l14;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle4)) {
									intValue3 = characterValueOf(handle4);
									goto l14;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle4)) {
									intValue3 = floatValueOf(handle4);
									goto l14;
								}
								if (handle4 == (nilObject())) {
									intValue3 = 0;
									goto l14;
								}
								if (handle4 == (falseObject())) {
									intValue3 = 0;
									goto l14;
								}
								if (handle4 == (trueObject())) {
									intValue3 = 1;
									goto l14;
								}
								if (isLargePositiveIntegerObject(handle4)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue3 = positive64BitValueOf(handle4);
									goto l14;
#                  else /* BytesPerWord == 8 */
									intValue3 = positive32BitValueOf(handle4);
									goto l14;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue3 = signedMachineIntegerValueOf(handle4);
	l14:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType11) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue3, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue3, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue3, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue3, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue3, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue3, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue3, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue3, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue3, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue3, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle4)) {
						floatValue3 = floatValueOf(handle4);
						goto l17;
					}
					floatValue3 = ((double) (ffiIntegerValueOf(handle4)) );
	l17:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType11 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue3;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue3;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue3);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue3;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue3);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
				}
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type2 = fetchPointerofObject(1, oop);
					if (!((isPointers(type2))
						 && ((slotSizeOf(type2)) >= 2))) {
						err = FFIErrorWrongType;
						goto l33;
					}
					referentClass2 = fetchPointerofObject(1, type2);
					if (!(includesBehaviorThatOf(referentClass2, argClass))) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					handle4 = fetchPointerofObject(0, oop);
					ptrClass2 = fetchClassOf(handle4);
					if (ptrClass2 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer6 = fetchPointerofObject(0, handle4);
						if (isInMemory(pointer6)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
					}
					else {
						if (ptrClass2 == (classByteArray())) {
							pointer6 = ((void *) (firstIndexableField(handle4)));
						}
						else {
							err = FFIErrorBadArg;
							goto l33;
						}
					}
					/* begin atomicTypeOf: */
					typeSpec4 = (calloutState->ffiArgHeader);
					atomicType4 = ((usqInt)((typeSpec4 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					switch (atomicType4) {
					case 0:
						err = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err = ffiPushDereferenceUnsignedIntin(pointer6, calloutState);
						break;
					case 2:
						err = ffiPushDereferenceUnsignedBytein(pointer6, calloutState);
						break;
					case 3:
						err = ffiPushDereferenceSignedBytein(pointer6, calloutState);
						break;
					case 4:
						err = ffiPushDereferenceUnsignedShortin(pointer6, calloutState);
						break;
					case 5:
						err = ffiPushDereferenceSignedShortin(pointer6, calloutState);
						break;
					case 7:
						err = ffiPushDereferenceSignedIntin(pointer6, calloutState);
						break;
					case 8:
						err = ffiPushDereferenceUnsignedLongLongin(pointer6, calloutState);
						break;
					case 9:
						err = ffiPushDereferenceSignedLongLongin(pointer6, calloutState);
						break;
					case 10:
						err = ffiPushDereferenceUnsignedCharin(pointer6, calloutState);
						break;
					case 11:
						err = ffiPushDereferenceSignedCharin(pointer6, calloutState);
						break;
					case 12:
						err = ffiPushDereferenceSingleFloatin(pointer6, calloutState);
						break;
					case 13:
						err = ffiPushDereferenceDoubleFloatin(pointer6, calloutState);
						break;

					default:
						error("Case not found");
					}
					goto l33;
				}
				if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle4 = fetchPointerofObject(0, oop);
					/* begin ffiArgByValue:in: */
					typeSpec21 = (calloutState->ffiArgHeader);
					atomicType21 = ((usqInt)((typeSpec21 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType21 < 0)
					 || (atomicType21 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType21 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType21)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue11 = handle4;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle4 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle4)) {
									intValue11 = integerValueOf(handle4);
									goto l13;
								}
								
#                if SPURVM
								if (isCharacterObject(handle4)) {

									/* Immediate in Spur */
									intValue11 = characterValueOf(handle4);
									goto l13;
								}
								if (isFloatObject(handle4)) {

									/* Immediate in 64-bit Spur */
									intValue11 = floatValueOf(handle4);
									goto l13;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle4)) {
									intValue11 = characterValueOf(handle4);
									goto l13;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle4)) {
									intValue11 = floatValueOf(handle4);
									goto l13;
								}
								if (handle4 == (nilObject())) {
									intValue11 = 0;
									goto l13;
								}
								if (handle4 == (falseObject())) {
									intValue11 = 0;
									goto l13;
								}
								if (handle4 == (trueObject())) {
									intValue11 = 1;
									goto l13;
								}
								if (isLargePositiveIntegerObject(handle4)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue11 = positive64BitValueOf(handle4);
									goto l13;
#                  else /* BytesPerWord == 8 */
									intValue11 = positive32BitValueOf(handle4);
									goto l13;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue11 = signedMachineIntegerValueOf(handle4);
	l13:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType21) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue11, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue11, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue11, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue11, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue11, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue11, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue11, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue11, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue11, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue11, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle4)) {
						floatValue11 = floatValueOf(handle4);
						goto l15;
					}
					floatValue11 = ((double) (ffiIntegerValueOf(handle4)) );
	l15:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType21 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue11;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue11;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue11);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue11;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue11);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
				}
				if (!0) {
					err = FFIErrorCoercionFailed;
					goto l33;
				}
				/* begin ffiArgByValue:in: */
				typeSpec31 = (calloutState->ffiArgHeader);
				atomicType31 = ((usqInt)((typeSpec31 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType31 < 0)
				 || (atomicType31 > FFITypeDoubleFloat)) {
					err = FFIErrorBadAtomicType;
					goto l33;
				}
				if (atomicType31 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType31)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue2 = oop;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop & (BytesPerWord - 1)) {
							if (isIntegerObject(oop)) {
								intValue2 = integerValueOf(oop);
								goto l18;
							}
							
#              if SPURVM
							if (isCharacterObject(oop)) {

								/* Immediate in Spur */
								intValue2 = characterValueOf(oop);
								goto l18;
							}
							if (isFloatObject(oop)) {

								/* Immediate in 64-bit Spur */
								intValue2 = floatValueOf(oop);
								goto l18;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop)) {
								intValue2 = characterValueOf(oop);
								goto l18;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop)) {
								intValue2 = floatValueOf(oop);
								goto l18;
							}
							if (oop == (nilObject())) {
								intValue2 = 0;
								goto l18;
							}
							if (oop == (falseObject())) {
								intValue2 = 0;
								goto l18;
							}
							if (oop == (trueObject())) {
								intValue2 = 1;
								goto l18;
							}
							if (isLargePositiveIntegerObject(oop)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue2 = positive64BitValueOf(oop);
								goto l18;
#                else /* BytesPerWord == 8 */
								intValue2 = positive32BitValueOf(oop);
								goto l18;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue2 = signedMachineIntegerValueOf(oop);
	l18:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					switch (atomicType31) {
					case 0:
						err = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err = ffiPushUnsignedIntin(intValue2, calloutState);
						break;
					case 2:
						err = ffiPushUnsignedBytein(intValue2, calloutState);
						break;
					case 3:
						err = ffiPushSignedBytein(intValue2, calloutState);
						break;
					case 4:
						err = ffiPushUnsignedShortin(intValue2, calloutState);
						break;
					case 5:
						err = ffiPushSignedShortin(intValue2, calloutState);
						break;
					case 7:
						err = ffiPushSignedIntin(intValue2, calloutState);
						break;
					case 8:
						err = ffiPushUnsignedLongLongOopin(intValue2, calloutState);
						break;
					case 9:
						err = ffiPushSignedLongLongOopin(intValue2, calloutState);
						break;
					case 10:
						err = ffiPushUnsignedCharin(intValue2, calloutState);
						break;
					case 11:
						err = ffiPushSignedCharin(intValue2, calloutState);
						break;

					default:
						error("Case not found");
					}
					goto l33;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop)) {
					floatValue2 = floatValueOf(oop);
					goto l16;
				}
				floatValue2 = ((double) (ffiIntegerValueOf(oop)) );
	l16:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err = FFIErrorCoercionFailed;
					goto l33;
				}
				if (atomicType31 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState->backfillFloatRegisterIndex)) > 0) {
							((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue2;
							(calloutState->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue2;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue2);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
							(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue2;
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						(calloutState->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState->currentArg), floatValue2);
						(calloutState->currentArg = ((calloutState->currentArg)) + 8);
					}
					err = 0;
					goto l33;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type = fetchPointerofObject(1, oop);
					if (!((isPointers(type))
						 && ((slotSizeOf(type)) >= 2))) {
						err = FFIErrorWrongType;
						goto l33;
					}
					referentClass = fetchPointerofObject(1, type);
					if (!(includesBehaviorThatOf(referentClass, argClass))) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					handle1 = fetchPointerofObject(0, oop);
					err = ffiPushPointerContentsOfin(handle1, calloutState);
					goto l33;
				}
				if (oop == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), null);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				err = FFIErrorCoercionFailed;
				goto l33;
				break;
			case FFIFlagStructure:
				/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass, argClass)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle5 = fetchPointerofObject(0, oop);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass3 = fetchClassOf(handle5);
					if (ptrClass3 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
						if (isInMemory(ptrAddress2)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
						argSpec3 = (calloutState->ffiArgSpec);
						argSpecSize = (calloutState->ffiArgSpecSize);
						availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
						stackPartSize = structSize;
						if (availableRegisterSpace > 0) {
							if (structSize <= availableRegisterSpace) {

								/* all in registers */
								stackPartSize = 0;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize);
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState->currentArg)) == ((calloutState->argVector))) {
									stackPartSize = structSize - availableRegisterSpace;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace);
								}
								else {
									availableRegisterSpace = 0;
								}
								(calloutState->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize > 0) {
							roundedSize = (((stackPartSize + 3) | 3) - 3);
							if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace])), stackPartSize);
							(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
						}
						err = 0;
						goto l33;
					}
					if (ptrClass3 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
							err = FFIErrorStructSize;
							goto l33;
						}
						ptrAddress2 = firstIndexableField(handle5);
						if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle5))) {
								err = -PrimErrObjectMayMove;
								goto l33;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec1 = (calloutState->ffiArgSpec);
							argSpecSize1 = (calloutState->ffiArgSpecSize);
							availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize1 = structSize1;
							if (availableRegisterSpace1 > 0) {
								if (structSize1 <= availableRegisterSpace1) {

									/* all in registers */
									stackPartSize1 = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize1);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize1 = structSize1 - availableRegisterSpace1;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace1);
									}
									else {
										availableRegisterSpace1 = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize1 > 0) {
								roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace1])), stackPartSize1);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
							}
							err = 0;
							goto l33;
						}
						if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err = FFIErrorStructSize;
							goto l33;
						}
						ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
						if (isInMemory(ptrAddress2)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress2));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress2);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorBadArg;
					goto l33;
				}
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type3 = fetchPointerofObject(1, oop);
					if (!((isPointers(type3))
						 && ((slotSizeOf(type3)) >= 2))) {
						err = FFIErrorWrongType;
						goto l33;
					}
					referentClass3 = fetchPointerofObject(1, type3);
					if (!(includesBehaviorThatOf(referentClass3, argClass))) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					handle5 = fetchPointerofObject(0, oop);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass11 = fetchClassOf(handle5);
					if (ptrClass11 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
						if (isInMemory(ptrAddress1)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize2 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
						argSpec2 = (calloutState->ffiArgSpec);
						argSpecSize2 = (calloutState->ffiArgSpecSize);
						availableRegisterSpace2 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
						stackPartSize2 = structSize2;
						if (availableRegisterSpace2 > 0) {
							if (structSize2 <= availableRegisterSpace2) {

								/* all in registers */
								stackPartSize2 = 0;
								memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize2);
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize2 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState->currentArg)) == ((calloutState->argVector))) {
									stackPartSize2 = structSize2 - availableRegisterSpace2;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace2);
								}
								else {
									availableRegisterSpace2 = 0;
								}
								(calloutState->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize2 > 0) {
							roundedSize2 = (((stackPartSize2 + 3) | 3) - 3);
							if ((((calloutState->currentArg)) + roundedSize2) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace2])), stackPartSize2);
							(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize2);
						}
						err = 0;
						goto l33;
					}
					if (ptrClass11 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
							err = FFIErrorStructSize;
							goto l33;
						}
						ptrAddress1 = firstIndexableField(handle5);
						if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle5))) {
								err = -PrimErrObjectMayMove;
								goto l33;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize11 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec11 = (calloutState->ffiArgSpec);
							argSpecSize11 = (calloutState->ffiArgSpecSize);
							availableRegisterSpace11 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize11 = structSize11;
							if (availableRegisterSpace11 > 0) {
								if (structSize11 <= availableRegisterSpace11) {

									/* all in registers */
									stackPartSize11 = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize11);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize11 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize11 = structSize11 - availableRegisterSpace11;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace11);
									}
									else {
										availableRegisterSpace11 = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize11 > 0) {
								roundedSize11 = (((stackPartSize11 + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize11) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace11])), stackPartSize11);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize11);
							}
							err = 0;
							goto l33;
						}
						if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err = FFIErrorStructSize;
							goto l33;
						}
						ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
						if (isInMemory(ptrAddress1)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress1));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress1);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorBadArg;
					goto l33;
				}
				err = FFIErrorCoercionFailed;
				goto l33;
				break;
			case FFIFlagStructure + FFIFlagPointer:
				/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass, argClass)) {

					/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
					handle2 = fetchPointerofObject(0, oop);
					err = ffiPushPointerContentsOfin(handle2, calloutState);
					goto l33;
				}
				if (includesBehaviorThatOf(oopClass, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type1 = fetchPointerofObject(1, oop);
					if (!((isPointers(type1))
						 && ((slotSizeOf(type1)) >= 2))) {
						err = FFIErrorWrongType;
						goto l33;
					}
					referentClass1 = fetchPointerofObject(1, type1);
					if (!(includesBehaviorThatOf(referentClass1, argClass))) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					handle2 = fetchPointerofObject(0, oop);
					err = ffiPushPointerContentsOfin(handle2, calloutState);
					goto l33;
				}
				if (oop == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							err = FFIErrorCallFrameTooBig;
							goto l33;
						}
						longAtput((calloutState->currentArg), null);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					err = 0;
					goto l33;
				}
				err = FFIErrorCoercionFailed;
				goto l33;
				break;
			default:
				err = FFIErrorWrongType;
				goto l33;

			}
		}
	l33:	/* end ffiArgument:Spec:Class:in: */;
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				return PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			return ffiFail(err);
		}
	}
	assert(!(failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction);
		if (!(isBytes(functionName))) {
			goto l3;
		}
		ffiLogCallOfLength(firstIndexableField(functionName), byteSizeOf(functionName));
	}
	l3:	/* end ffiLogCallout: */;
	if ((requiredStackSize < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex = disownVM(
#  if COGMTVM
		(((calloutState->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		);
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs((((double *) ((&(((calloutState->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState->floatRegisters))[14])))))[0]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiRetHeader);
	atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType == FFITypeSingleFloat) {
			floatRet = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		}
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(myThreadIndex);
		result = floatObjectOf(floatRet);
		goto l9;
	}

	/* undo any callee argument pops because it may confuse stack management with the alloca. */
	intRet = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	ownVM(myThreadIndex);
	if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			specLiteral = (argArrayOrNil != null
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
			retType = fetchPointerofObject(0, argTypes);
			retClass2 = fetchPointerofObject(1, retType);
			if (retClass2 == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec1 = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer = ((usqInt) intRet);
					if (!(cPointer)) {
						retOop = nilObject();
						goto l5;
					}
					cString = ((char *) cPointer);
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(), strLen);
					strPtr = firstIndexableField(strOop);
					for (i1 = 0; i1 < strLen; i1 += 1) {
						strPtr[i1] = (cString[i1]);
					}
					retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
					result = retOop;
					goto l9;
				}
			}
			
#if SPURVM
			oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr1 = firstIndexableField(oop2);
			ptr1[0] = (((sqInt) intRet));
			retOop = instantiateClassindexableSize(classExternalData(), 0);
			storePointerofObjectwithValue(0, retOop, oop2);

#else /* SPURVM */
			pushRemappableOop(retType);
			oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr1 = firstIndexableField(oop2);
			ptr1[0] = (((sqInt) intRet));
						pushRemappableOop(oop2);
			retOop = instantiateClassindexableSize(classExternalData(), 0);
			oop2 = popRemappableOop();
			storePointerofObjectwithValue(0, retOop, oop2);
			retType = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(1, retOop, retType);
			result = retOop;
			goto l9;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr = (&intRet);
		/* begin ffiReturnType: */
		specLiteral1 = (argArrayOrNil != null
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		ffiRetType = fetchPointerofObject(0, argTypes1);
		retClass1 = fetchPointerofObject(1, ffiRetType);
		retOop1 = instantiateClassindexableSize(retClass1, 0);
		
#if SPURVM
		oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));

#else /* SPURVM */
		pushRemappableOop(retOop1);
		oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop1 = popRemappableOop()
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop1), ((calloutState->structReturnType)
			? longLongRetPtr
			: (calloutState->limit)), (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop1, oop1);
		result = retOop1;
		goto l9;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(intRet))
			? intRet
			: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		if (value == 0) {
			result = falseObject();
		}
		else {
			result = trueObject();
		}
		goto l9;
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt)(atomicType)) >> 1) * 8);
			value = intRet & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			result = integerObjectOf(value);
			goto l9;
		}
		if (atomicType & 1) {
			if (BytesPerWord == 8) {
				result = signed64BitIntegerFor(intRet);
			}
			else {
				result = signed32BitIntegerFor(intRet);
			}
		}
		else {
			if (BytesPerWord == 8) {
				result = positive64BitIntegerFor(intRet);
			}
			else {
				result = positive32BitIntegerFor(intRet);
			}
		}
		goto l9;
	}
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {
		if (atomicType & 1) {
			result = signed64BitIntegerFor(intRet);
		}
		else {
			result = positive64BitIntegerFor(intRet);
		}
	}
	else {
		result = characterObjectOf(intRet & 0xFF);
	}
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
	if (!(retClass == (nilObject()))) {
		if ((((calloutState->ffiRetHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) == FFIFlagAtomic) {
			
#if SPURVM
			alias = instantiateClassindexableSize(retClass, 0);

#else /* SPURVM */
			pushRemappableOop(result);
			alias = instantiateClassindexableSize(retClass, 0);
			result = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, alias, result);
			result = alias;
		}
	}
	/* begin cleanupCalloutState: */
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs + 1, result);
	return result;
}


/*	Make sure we can return an object of the given type */

	/* ThreadedFFIPlugin>>#ffiCheckReturn:With:in: */
static sqInt
ffiCheckReturnWithin(sqInt retSpec, sqInt retClass, CalloutState *calloutState)
{
	if (!(retClass == (nilObject()))) {
		if (!(includesBehaviorThatOf(retClass, classExternalStructure()))) {
			return FFIErrorBadReturn;
		}
	}
	if (!((isWords(retSpec))
		 && ((slotSizeOf(retSpec)) > 0))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiRetSpec = retSpec);
	(calloutState->ffiRetHeader = fetchLong32ofObject(0, retSpec));
	if (!(((calloutState->ffiRetHeader)) & FFIFlagAtomic)) {
		if (retClass == (nilObject())) {
			return FFIErrorBadReturn;
		}
	}
	if ((((calloutState->ffiRetHeader)) & (FFIFlagPointer | FFIFlagStructure)) == FFIFlagStructure) {
		(calloutState->structReturnSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask);
		/* begin encodeStructReturnTypeIn: */
		(calloutState->structReturnType = ((calloutState->structReturnSize)) <= BytesPerWord);
	}
	return 0;
}


/*	Make sure that the given oop is a valid external handle */

	/* ThreadedFFIPlugin>>#ffiContentsOfHandle:errCode: */
static sqInt
ffiContentsOfHandleerrCode(sqInt oop, sqInt errCode)
{
	if (!((isBytes(oop))
		 && ((byteSizeOf(oop)) == (sizeof(sqInt))))) {
		return ffiFail(errCode);
	}
	return fetchPointerofObject(0, oop);
}


/*	Callout support. Return the appropriate oop for the given atomic type */

	/* ThreadedFFIPlugin>>#ffiCreateIntegralResultOop:ofAtomicType:in: */
static sqInt
ffiCreateIntegralResultOopofAtomicTypein(usqLong retVal, sqInt atomicType, CalloutState *calloutState)
{
    sqInt byteSize;
    usqLong mask;
    sqInt shift;
    usqLong value;

	assert(atomicType < FFITypeSingleFloat);
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(retVal))
			? retVal
			: retVal & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		return (value == 0
			? falseObject()
			: trueObject());
	}
	if (atomicType <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift = ((BytesPerWord == 8)
			 && (atomicType >= FFITypeUnsignedInt)
				? 32
				: (((usqInt)(atomicType)) >> 1) * 8);
			value = retVal & (((((unsigned long long)1)) << shift) - 1);
			if (atomicType & 1) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			return integerObjectOf(value);
		}
		return (atomicType & 1
			? (BytesPerWord == 8
					? signed64BitIntegerFor(retVal)
					: signed32BitIntegerFor(retVal))
			: (BytesPerWord == 8
					? positive64BitIntegerFor(retVal)
					: positive32BitIntegerFor(retVal)));
	}
	return ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)
		? (atomicType & 1
				? signed64BitIntegerFor(retVal)
				: positive64BitIntegerFor(retVal))
		: characterObjectOf(retVal & 0xFF));
}


/*	Map the FFI error code into a primitive error code. If reason is negative
	it encodes one of the
	standard PrimErr... codes, negated to distinguish it from the FFIError
	codes. If it is an FFIError...
	code then add the size of the primitive error table + 2 to disambiguate it
	from the PrimErr... codes.
	For historic reasons the FFIError codes range from -1 on up hence adding
	size + 2 maps them to
	size of table + 1 on up. This OFFSET IS undone by ExternalFunction
	class>>externalCallFailedWith:. Thus we can communicate back both
	PrimErr.. and FFIError codes. Complex but necessary. */

	/* ThreadedFFIPlugin>>#ffiFail: */
static sqInt
ffiFail(sqInt reason)
{
	ffiLastError = reason;
	return primitiveFailFor((reason >= FFINoCalloutAvailable
		? (reason + 2) + (slotSizeOf(primitiveErrorTable()))
		: -reason));
}


/*	Support for generic callout. Return a float value that is coerced as C
	would do.
 */

	/* ThreadedFFIPlugin>>#ffiFloatValueOf: */
static double
ffiFloatValueOf(sqInt oop)
{
	if (isFloatObject(oop)) {
		return floatValueOf(oop);
	}
	return ((double) (ffiIntegerValueOf(oop)) );
}


/*	answer true if FFI type checking is permissive.
	answer false if FFI type checking is strict.
	By now, hardcode the preference */

	/* ThreadedFFIPlugin>>#ffiHasPermissiveArgCheck */
static sqInt
ffiHasPermissiveArgCheck(void)
{
	return 0;
}


/*	Support for generic callout. Answer an integer value that is coerced as C
	would do.
 */
/*	Cheat with a tag test */

	/* ThreadedFFIPlugin>>#ffiIntegerValueOf: */
static sqInt
ffiIntegerValueOf(sqInt oop)
{
	if (oop & (BytesPerWord - 1)) {
		if (isIntegerObject(oop)) {
			return integerValueOf(oop);
		}
		
#    if SPURVM
		if (isCharacterObject(oop)) {

			/* Immediate in Spur */
			return characterValueOf(oop);
		}
		if (isFloatObject(oop)) {

			/* Immediate in 64-bit Spur */
			return floatValueOf(oop);
		}
#    endif /* SPURVM */
	}
	else {
		
#    if SPURVM

		/* No non-immediate characters in Spur */
#    else /* SPURVM */
		if (isCharacterObject(oop)) {
			return characterValueOf(oop);
		}
#    endif /* SPURVM */
		if (isFloatObject(oop)) {
			return floatValueOf(oop);
		}
		if (oop == (nilObject())) {
			return 0;
		}
		if (oop == (falseObject())) {
			return 0;
		}
		if (oop == (trueObject())) {
			return 1;
		}
		if (isLargePositiveIntegerObject(oop)) {
			
#      if BytesPerWord == 8

			/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
			return positive64BitValueOf(oop);
#      else /* BytesPerWord == 8 */
			return positive32BitValueOf(oop);
#      endif /* BytesPerWord == 8 */
		}
	}
	return signedMachineIntegerValueOf(oop);
}


/*	Load the function address for a call out to an external function */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutAddressFrom: */
static sqInt
ffiLoadCalloutAddressFrom(sqInt oop)
{
    sqInt address;
    sqInt functionName;
    sqInt module;
    sqInt moduleHandle;


	/* First find and load the module */
	module = fetchPointerofObject(externalFunctionInstSize + 1, oop);
	moduleHandle = ffiLoadCalloutModule(module);
	if (failed()) {
		return 0;
	}
	functionName = fetchPointerofObject(externalFunctionInstSize, oop);
	if (!(isBytes(functionName))) {
		return ffiFail(FFIErrorBadExternalFunction);
	}
	address = ((sqInt)(ioLoadSymbolOfLengthFromModule(((sqInt)(firstIndexableField(functionName))), byteSizeOf(functionName), moduleHandle)));
	if ((failed())
	 || (address == 0)) {
		return ffiFail(FFIErrorAddressNotFound);
	}
	return address;
}


/*	Load the address of the foreign function from the given object */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutAddress: */
static sqInt
ffiLoadCalloutAddress(sqInt lit)
{
    sqInt address;
    sqInt addressPtr;
    sqIntptr_t *ptr;


	/* Lookup the address */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, lit);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(addressPtr))
		 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
		address = ffiFail(FFIErrorBadAddress);
		goto l1;
	}
	address = fetchPointerofObject(0, addressPtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		return 0;
	}
	if (address == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, lit, integerObjectOf(-1));
		}
		if ((slotSizeOf(lit)) < 5) {
			return ffiFail(FFIErrorNoModule);
		}
		address = ffiLoadCalloutAddressFrom(lit);
		if (failed()) {
			return 0;
		}
		ptr = firstIndexableField(addressPtr);
		ptr[0] = address;
	}
	return address;
}


/*	Load the given module and return its handle */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutModule: */
static sqInt
ffiLoadCalloutModule(sqInt module)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt moduleLength;
    sqInt *ptr;
    sqInt rcvr;

	if (isBytes(module)) {

		/* plain module name */
		ffiModuleName = module;
		moduleLength = byteSizeOf(ffiModuleName);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), moduleLength)));
		if ((failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		return moduleHandle;
	}
	rcvr = stackValue(methodArgumentCount());
	if (!(isKindOfClass(rcvr, classExternalLibrary()))) {
		return ffiFail(FFIErrorNoModule);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr))
		 && ((byteSizeOf(moduleHandlePtr)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		return 0;
	}
	if (moduleHandle == 0) {

		/* need to reload module */
		ffiModuleName = fetchPointerofObject(1, rcvr);
		if (!(isBytes(ffiModuleName))) {
			return ffiFail(FFIErrorBadExternalLibrary);
		}
		moduleLength = byteSizeOf(ffiModuleName);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), moduleLength)));
		if ((failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		ptr = firstIndexableField(moduleHandlePtr);
		ptr[0] = moduleHandle;
	}
	return moduleHandle;
}


/*	fetch the function name */

	/* ThreadedFFIPlugin>>#ffiLogCallout: */
static void
ffiLogCallout(sqInt lit)
{
    sqInt functionName;

	if (ffiLogEnabled) {
		functionName = fetchPointerofObject(externalFunctionInstSize, lit);
		if (!(isBytes(functionName))) {
			return;
		}
		ffiLogCallOfLength(firstIndexableField(functionName), byteSizeOf(functionName));
	}
}


/*	This is a special entry point exposed such that client code can 
	enable and disable logging of FFI calls. */

	/* ThreadedFFIPlugin>>#ffiLogCallsTo: */
EXPORT(sqInt)
ffiLogCallsTo(char *fileName)
{
    sqInt ok;

	if (fileName == null) {

		/* disable logging */
		ok = ffiLogFileNameOfLength(null, 0);
		if (!ok) {
			return 0;
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		ok = ffiLogFileNameOfLength(fileName, strlen(fileName));
		if (!ok) {
			return 0;
		}
		ffiLogEnabled = 1;
	}
	return 1;
}


/*	So we want to pass a reference to an ExternalTypeAlias, which is possible
	from: - ExternalData if type referentClass is matching expected argClass
	- nil (representing NULL pointer)
	direct use of ExternalAddress or ByteArray memory zone is considered
	unsafe. They have to be explicitely wrapped into an ExternalData and
	dressed with appropriate type
 */

	/* ThreadedFFIPlugin>>#ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
static sqInt
ffiPassAtomicArgumentByReferenceClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState)
{
    sqInt handle;
    sqInt referentClass;
    sqInt type;

	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Fetch the type specification and check against expectedClass */
		type = fetchPointerofObject(1, oop);
		if (!((isPointers(type))
			 && ((slotSizeOf(type)) >= 2))) {
			return FFIErrorWrongType;
		}
		referentClass = fetchPointerofObject(1, type);
		if (!(includesBehaviorThatOf(referentClass, argClass))) {
			return FFIErrorCoercionFailed;
		}
		handle = fetchPointerofObject(0, oop);
		return ffiPushPointerContentsOfin(handle, calloutState);
	}
	if (oop == (nilObject())) {
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), null);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorCoercionFailed;
}


/*	So we want to pass a reference to immediate value, which is possible from:
	- ExternalData
	- nil (representing NULL pointer)
	- String in case of (unsigned) char * - we then pass a copy
	- ByteArray/ExternalAddress/Alien in case of (unsigned) char *, (unsigned)
	byte *, void *
	- DoubleByteArray in case of (unsigned) short *
	- WordArray in case of (unsigned) int *, float *
	- DoubleWordArray in case of (unsigned) long long *, double *
	direct use of ExternalAddress or ByteArray memory zone might be considered
	unsafe. They may have to be explicitely wrapped into an ExternalData and
	dressed with appropriate type in the future
 */

	/* ThreadedFFIPlugin>>#ffiPassAtomicArgumentByReference:Class:In: */
static sqInt
ffiPassAtomicArgumentByReferenceClassIn(sqInt oop, sqInt oopClass, CalloutState *calloutState)
{
    sqInt atomicType;
    char *copy;
    sqInt handle;
    sqInt length;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void * ptrAddress;
    sqInt ptrClass;
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt typeSpec;

	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Check: we handle pointer to an atomic type */
		/* no type checks for void pointers */
		if (atomicType != FFITypeVoid) {
			/* begin ffiValidateExternalData:AtomicType: */
			ptrType = fetchPointerofObject(1, oop);
			if (!((isPointers(ptrType))
				 && ((slotSizeOf(ptrType)) >= 2))) {
				goto l3;
			}
			specOop = fetchPointerofObject(0, ptrType);
			if (!((isWords(specOop))
				 && ((slotSizeOf(specOop)) > 0))) {
				goto l3;
			}
			spec = fetchPointerofObject(0, specOop);
			if (!(spec & FFIFlagAtomic)) {
				goto l3;
			}
			/* begin atomicTypeOf: */
			specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
			if (specType != atomicType) {

				/* Allow for signed/unsigned conversion but nothing else.
				   See FFIConstants class>>#initializeTypeConstants */
				if (!((atomicType >= FFITypeUnsignedByte)
					 && ((atomicType <= FFITypeSignedChar)
					 && ((((usqInt)(atomicType)) >> 1) == (((usqInt)(specType)) >> 1))))) {
					goto l3;
				}
			}
	l3:	/* end ffiValidateExternalData:AtomicType: */;
		}
		if (failed()) {
			return null;
		}
		handle = fetchPointerofObject(0, oop);
		return ffiPushPointerContentsOfin(handle, calloutState);
	}
	if (oop == (nilObject())) {
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), null);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

		/* note: the only types allowed for passing into char* types are
		   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
		   (e.g., CompiledMethod, LargeInteger). We only check for strings
		   here and fall through to the byte* check otherwise. */
		if (includesBehaviorThatOf(oopClass, classString())) {
			/* begin ffiPushString:OfLength:in: */
			pointer = ((char *) (firstIndexableField(oop)));
			length = byteSizeOf(oop);
			if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
				return -PrimErrBadNumArgs;
			}
			copy = malloc(length + 1);
			if (copy == null) {
				return -PrimErrNoCMemory;
			}
			memcpy(copy, pointer, length);
			copy[length] = 0;
			((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
			(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), copy);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		atomicType = FFITypeUnsignedByte;
	}
	ptrClass = fetchClassOf(oop);
	if (ptrClass == (classExternalAddress())) {

		/* Don't you dare to pass pointers into object memory */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (includesBehaviorThatOf(ptrClass, classAlien())) {
		
#    if COGMTVM
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (((assert(isAlien(oop)),
		(longAt(oop + BaseHeaderSize)) > 0))
		 && (isYoung(oop)))) {
			return -PrimErrObjectMayMove;
		}
#    endif /* COGMTVM */
		ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
			? (oop + BaseHeaderSize) + BytesPerOop
			: longAt((oop + BaseHeaderSize) + BytesPerOop));
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	
#  if COGMTVM

	/* Since all the following pass the address of the first indexable field we need to fail
	   the call if it is threaded and the object is young, since it may move during the call. */
	if ((((calloutState->callFlags)) & FFICallFlagThreaded)
	 && (isYoung(oop))) {
		return -PrimErrObjectMayMove;
	}
#  endif /* COGMTVM */
	if ((ptrClass == (classByteArray()))
	 && ((atomicType == FFITypeVoid)
	 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
		/* begin ffiPushPointer:in: */
		pointer1 = ((void *) (firstIndexableField(oop)));
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer1);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if ((isShorts(oop))
	 && ((atomicType == FFITypeVoid)
	 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
		/* begin ffiPushPointer:in: */
		pointer2 = ((void *) (firstIndexableField(oop)));
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer2);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if ((isWords(oop))
	 && ((atomicType == FFITypeVoid)
	 || ((atomicType == FFITypeSingleFloat)
	 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
		/* begin ffiPushPointer:in: */
		pointer3 = ((void *) (firstIndexableField(oop)));
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer3);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if ((isLong64s(oop))
	 && ((atomicType == FFITypeVoid)
	 || ((atomicType == FFITypeDoubleFloat)
	 || ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
		/* begin ffiPushPointer:in: */
		pointer4 = ((void *) (firstIndexableField(oop)));
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), pointer4);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorCoercionFailed;
}


/*	So we want to pass an immediate value, if a given type alias
	- ExternalTypeAlias of expectedClass (or eventually a subclass)
	- ExternalData (dereferencing the pointer) typically case of a global
	variable 
	We do not handle ExternalAddress or RawBitsArray, here...
	They shall be de-referenced at image side */

	/* ThreadedFFIPlugin>>#ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
static sqInt
ffiPassAtomicArgumentByValueClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState)
{
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType2;
    sqInt atomicType3;
    double floatValue;
    double floatValue1;
    double floatValue2;
    sqInt handle;
    sqInt intValue;
    sqInt intValue1;
    sqInt intValue2;
    void *pointer;
    sqInt ptrClass;
    sqInt referentClass;
    sqInt type;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec2;
    sqInt typeSpec3;

	pointer = ((void *) 0);
	if (includesBehaviorThatOf(oopClass, argClass)) {

		/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
		handle = fetchPointerofObject(0, oop);
		/* begin ffiArgByValue:in: */
		typeSpec1 = (calloutState->ffiArgHeader);
		atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((atomicType1 < 0)
		 || (atomicType1 > FFITypeDoubleFloat)) {
			return FFIErrorBadAtomicType;
		}
		if (atomicType1 < FFITypeSingleFloat) {

			/* integer types */
			if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

				/* ffi support code must coerce longlong */
				intValue = handle;
			}
			else {
				/* begin ffiIntegerValueOf: */
				if (handle & (BytesPerWord - 1)) {
					if (isIntegerObject(handle)) {
						intValue = integerValueOf(handle);
						goto l2;
					}
					
#          if SPURVM
					if (isCharacterObject(handle)) {

						/* Immediate in Spur */
						intValue = characterValueOf(handle);
						goto l2;
					}
					if (isFloatObject(handle)) {

						/* Immediate in 64-bit Spur */
						intValue = floatValueOf(handle);
						goto l2;
					}
#          endif /* SPURVM */
				}
				else {
					
#          if SPURVM

					/* No non-immediate characters in Spur */
#          else /* SPURVM */
					if (isCharacterObject(handle)) {
						intValue = characterValueOf(handle);
						goto l2;
					}
#          endif /* SPURVM */
					if (isFloatObject(handle)) {
						intValue = floatValueOf(handle);
						goto l2;
					}
					if (handle == (nilObject())) {
						intValue = 0;
						goto l2;
					}
					if (handle == (falseObject())) {
						intValue = 0;
						goto l2;
					}
					if (handle == (trueObject())) {
						intValue = 1;
						goto l2;
					}
					if (isLargePositiveIntegerObject(handle)) {
						
#            if BytesPerWord == 8

						/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
						intValue = positive64BitValueOf(handle);
						goto l2;
#            else /* BytesPerWord == 8 */
						intValue = positive32BitValueOf(handle);
						goto l2;
#            endif /* BytesPerWord == 8 */
					}
				}
				intValue = signedMachineIntegerValueOf(handle);
	l2:	/* end ffiIntegerValueOf: */;
			}
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
			
			switch (atomicType1) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 2:
				return ffiPushUnsignedBytein(intValue, calloutState);
			case 3:
				return ffiPushSignedBytein(intValue, calloutState);
			case 4:
				return ffiPushUnsignedShortin(intValue, calloutState);
			case 5:
				return ffiPushSignedShortin(intValue, calloutState);
			case 6:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 7:
				return ffiPushSignedIntin(intValue, calloutState);
			case 8:
				return ffiPushUnsignedLongLongOopin(intValue, calloutState);
			case 9:
				return ffiPushSignedLongLongOopin(intValue, calloutState);
			case 10:
				return ffiPushUnsignedCharin(intValue, calloutState);
			case 11:
				return ffiPushSignedCharin(intValue, calloutState);

			default:
				error("Case not found");
				return -1;
			}
		}
		/* begin ffiFloatValueOf: */
		if (isFloatObject(handle)) {
			floatValue = floatValueOf(handle);
			goto l3;
		}
		floatValue = ((double) (ffiIntegerValueOf(handle)) );
	l3:	/* end ffiFloatValueOf: */;
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType1 == FFITypeSingleFloat) {
			/* begin ffiPushSingleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				if (((calloutState->backfillFloatRegisterIndex)) > 0) {
					((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
					(calloutState->backfillFloatRegisterIndex = 0);
				}
				else {
					((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		else {
			/* begin ffiPushDoubleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
				if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
					(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
				(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
			}
			else {
				if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				(calloutState->floatRegisterIndex = NumFloatRegArgs);
				storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + 8);
			}
			return 0;
		}
	}
	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Fetch the type specification and check against expectedClass */
		type = fetchPointerofObject(1, oop);
		if (!((isPointers(type))
			 && ((slotSizeOf(type)) >= 2))) {
			return FFIErrorWrongType;
		}
		referentClass = fetchPointerofObject(1, type);
		if (!(includesBehaviorThatOf(referentClass, argClass))) {
			return FFIErrorCoercionFailed;
		}
		handle = fetchPointerofObject(0, oop);
		ptrClass = fetchClassOf(handle);
		if (ptrClass == (classExternalAddress())) {

			/* Don't you dare to pass pointers into object memory */
			pointer = fetchPointerofObject(0, handle);
			if (isInMemory(pointer)) {
				return FFIErrorInvalidPointer;
			}
		}
		else {
			if (ptrClass == (classByteArray())) {
				pointer = ((void *) (firstIndexableField(handle)));
			}
			else {
				return FFIErrorBadArg;
			}
		}
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiArgHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushDereferenceUnsignedIntin(pointer, calloutState);
		case 2:
			return ffiPushDereferenceUnsignedBytein(pointer, calloutState);
		case 3:
			return ffiPushDereferenceSignedBytein(pointer, calloutState);
		case 4:
			return ffiPushDereferenceUnsignedShortin(pointer, calloutState);
		case 5:
			return ffiPushDereferenceSignedShortin(pointer, calloutState);
		case 6:
			return ffiPushDereferenceUnsignedIntin(pointer, calloutState);
		case 7:
			return ffiPushDereferenceSignedIntin(pointer, calloutState);
		case 8:
			return ffiPushDereferenceUnsignedLongLongin(pointer, calloutState);
		case 9:
			return ffiPushDereferenceSignedLongLongin(pointer, calloutState);
		case 10:
			return ffiPushDereferenceUnsignedCharin(pointer, calloutState);
		case 11:
			return ffiPushDereferenceSignedCharin(pointer, calloutState);
		case 12:
			return ffiPushDereferenceSingleFloatin(pointer, calloutState);
		case 13:
			return ffiPushDereferenceDoubleFloatin(pointer, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

		/* We do not have any type specification easily available.
		   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
		handle = fetchPointerofObject(0, oop);
		/* begin ffiArgByValue:in: */
		typeSpec2 = (calloutState->ffiArgHeader);
		atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((atomicType2 < 0)
		 || (atomicType2 > FFITypeDoubleFloat)) {
			return FFIErrorBadAtomicType;
		}
		if (atomicType2 < FFITypeSingleFloat) {

			/* integer types */
			if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

				/* ffi support code must coerce longlong */
				intValue1 = handle;
			}
			else {
				/* begin ffiIntegerValueOf: */
				if (handle & (BytesPerWord - 1)) {
					if (isIntegerObject(handle)) {
						intValue1 = integerValueOf(handle);
						goto l7;
					}
					
#          if SPURVM
					if (isCharacterObject(handle)) {

						/* Immediate in Spur */
						intValue1 = characterValueOf(handle);
						goto l7;
					}
					if (isFloatObject(handle)) {

						/* Immediate in 64-bit Spur */
						intValue1 = floatValueOf(handle);
						goto l7;
					}
#          endif /* SPURVM */
				}
				else {
					
#          if SPURVM

					/* No non-immediate characters in Spur */
#          else /* SPURVM */
					if (isCharacterObject(handle)) {
						intValue1 = characterValueOf(handle);
						goto l7;
					}
#          endif /* SPURVM */
					if (isFloatObject(handle)) {
						intValue1 = floatValueOf(handle);
						goto l7;
					}
					if (handle == (nilObject())) {
						intValue1 = 0;
						goto l7;
					}
					if (handle == (falseObject())) {
						intValue1 = 0;
						goto l7;
					}
					if (handle == (trueObject())) {
						intValue1 = 1;
						goto l7;
					}
					if (isLargePositiveIntegerObject(handle)) {
						
#            if BytesPerWord == 8

						/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
						intValue1 = positive64BitValueOf(handle);
						goto l7;
#            else /* BytesPerWord == 8 */
						intValue1 = positive32BitValueOf(handle);
						goto l7;
#            endif /* BytesPerWord == 8 */
					}
				}
				intValue1 = signedMachineIntegerValueOf(handle);
	l7:	/* end ffiIntegerValueOf: */;
			}
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
			
			switch (atomicType2) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				return ffiPushUnsignedIntin(intValue1, calloutState);
			case 2:
				return ffiPushUnsignedBytein(intValue1, calloutState);
			case 3:
				return ffiPushSignedBytein(intValue1, calloutState);
			case 4:
				return ffiPushUnsignedShortin(intValue1, calloutState);
			case 5:
				return ffiPushSignedShortin(intValue1, calloutState);
			case 6:
				return ffiPushUnsignedIntin(intValue1, calloutState);
			case 7:
				return ffiPushSignedIntin(intValue1, calloutState);
			case 8:
				return ffiPushUnsignedLongLongOopin(intValue1, calloutState);
			case 9:
				return ffiPushSignedLongLongOopin(intValue1, calloutState);
			case 10:
				return ffiPushUnsignedCharin(intValue1, calloutState);
			case 11:
				return ffiPushSignedCharin(intValue1, calloutState);

			default:
				error("Case not found");
				return -1;
			}
		}
		/* begin ffiFloatValueOf: */
		if (isFloatObject(handle)) {
			floatValue1 = floatValueOf(handle);
			goto l5;
		}
		floatValue1 = ((double) (ffiIntegerValueOf(handle)) );
	l5:	/* end ffiFloatValueOf: */;
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType2 == FFITypeSingleFloat) {
			/* begin ffiPushSingleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				if (((calloutState->backfillFloatRegisterIndex)) > 0) {
					((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
					(calloutState->backfillFloatRegisterIndex = 0);
				}
				else {
					((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		else {
			/* begin ffiPushDoubleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
				if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
					(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
				(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
			}
			else {
				if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				(calloutState->floatRegisterIndex = NumFloatRegArgs);
				storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
				(calloutState->currentArg = ((calloutState->currentArg)) + 8);
			}
			return 0;
		}
	}
	if (!0) {
		return FFIErrorCoercionFailed;
	}
	/* begin ffiArgByValue:in: */
	typeSpec3 = (calloutState->ffiArgHeader);
	atomicType3 = ((usqInt)((typeSpec3 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((atomicType3 < 0)
	 || (atomicType3 > FFITypeDoubleFloat)) {
		return FFIErrorBadAtomicType;
	}
	if (atomicType3 < FFITypeSingleFloat) {

		/* integer types */
		if ((((usqInt)(atomicType3)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

			/* ffi support code must coerce longlong */
			intValue2 = oop;
		}
		else {
			/* begin ffiIntegerValueOf: */
			if (oop & (BytesPerWord - 1)) {
				if (isIntegerObject(oop)) {
					intValue2 = integerValueOf(oop);
					goto l10;
				}
				
#        if SPURVM
				if (isCharacterObject(oop)) {

					/* Immediate in Spur */
					intValue2 = characterValueOf(oop);
					goto l10;
				}
				if (isFloatObject(oop)) {

					/* Immediate in 64-bit Spur */
					intValue2 = floatValueOf(oop);
					goto l10;
				}
#        endif /* SPURVM */
			}
			else {
				
#        if SPURVM

				/* No non-immediate characters in Spur */
#        else /* SPURVM */
				if (isCharacterObject(oop)) {
					intValue2 = characterValueOf(oop);
					goto l10;
				}
#        endif /* SPURVM */
				if (isFloatObject(oop)) {
					intValue2 = floatValueOf(oop);
					goto l10;
				}
				if (oop == (nilObject())) {
					intValue2 = 0;
					goto l10;
				}
				if (oop == (falseObject())) {
					intValue2 = 0;
					goto l10;
				}
				if (oop == (trueObject())) {
					intValue2 = 1;
					goto l10;
				}
				if (isLargePositiveIntegerObject(oop)) {
					
#          if BytesPerWord == 8

					/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
					intValue2 = positive64BitValueOf(oop);
					goto l10;
#          else /* BytesPerWord == 8 */
					intValue2 = positive32BitValueOf(oop);
					goto l10;
#          endif /* BytesPerWord == 8 */
				}
			}
			intValue2 = signedMachineIntegerValueOf(oop);
	l10:	/* end ffiIntegerValueOf: */;
		}
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		
		switch (atomicType3) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushUnsignedIntin(intValue2, calloutState);
		case 2:
			return ffiPushUnsignedBytein(intValue2, calloutState);
		case 3:
			return ffiPushSignedBytein(intValue2, calloutState);
		case 4:
			return ffiPushUnsignedShortin(intValue2, calloutState);
		case 5:
			return ffiPushSignedShortin(intValue2, calloutState);
		case 6:
			return ffiPushUnsignedIntin(intValue2, calloutState);
		case 7:
			return ffiPushSignedIntin(intValue2, calloutState);
		case 8:
			return ffiPushUnsignedLongLongOopin(intValue2, calloutState);
		case 9:
			return ffiPushSignedLongLongOopin(intValue2, calloutState);
		case 10:
			return ffiPushUnsignedCharin(intValue2, calloutState);
		case 11:
			return ffiPushSignedCharin(intValue2, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	/* begin ffiFloatValueOf: */
	if (isFloatObject(oop)) {
		floatValue2 = floatValueOf(oop);
		goto l8;
	}
	floatValue2 = ((double) (ffiIntegerValueOf(oop)) );
	l8:	/* end ffiFloatValueOf: */;
	if (failed()) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType3 == FFITypeSingleFloat) {
		/* begin ffiPushSingleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			if (((calloutState->backfillFloatRegisterIndex)) > 0) {
				((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue2;
				(calloutState->backfillFloatRegisterIndex = 0);
			}
			else {
				((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue2;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue2);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	else {
		/* begin ffiPushDoubleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
			if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
				(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
			(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue2;
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
		}
		else {
			if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			(calloutState->floatRegisterIndex = NumFloatRegArgs);
			storeFloatAtPointerfrom((calloutState->currentArg), floatValue2);
			(calloutState->currentArg = ((calloutState->currentArg)) + 8);
		}
		return 0;
	}
}


/*	So we want to pass an immediate value, which is possible from:
	- nil,true,false
	- Integer, Float, Character
	- ExternalTypeAlias to an atomic
	- ExternalData (dereferencing the pointer) typically case of a global
	variable 
	We do not handle ExternalAddress or RawBitsArray, here...
	They shall be de-referenced at image side */

	/* ThreadedFFIPlugin>>#ffiPassAtomicArgumentByValue:Class:In: */
static sqInt
ffiPassAtomicArgumentByValueClassIn(sqInt oop, sqInt oopClass, CalloutState *calloutState)
{
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType2;
    double floatValue;
    double floatValue1;
    sqInt handle;
    sqInt intValue;
    sqInt intValue1;
    void *pointer;
    sqInt ptrClass;
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec2;

	pointer = ((void *) 0);
	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Fetch the type specification and check: we handle pointer to an atomic type */
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiArgHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		/* begin ffiValidateExternalData:AtomicType: */
		ptrType = fetchPointerofObject(1, oop);
		if (!((isPointers(ptrType))
			 && ((slotSizeOf(ptrType)) >= 2))) {
			goto l3;
		}
		specOop = fetchPointerofObject(0, ptrType);
		if (!((isWords(specOop))
			 && ((slotSizeOf(specOop)) > 0))) {
			goto l3;
		}
		spec = fetchPointerofObject(0, specOop);
		if (!(spec & FFIFlagAtomic)) {
			goto l3;
		}
		/* begin atomicTypeOf: */
		specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if (specType != atomicType) {

			/* Allow for signed/unsigned conversion but nothing else.
			   See FFIConstants class>>#initializeTypeConstants */
			if (!((atomicType >= FFITypeUnsignedByte)
				 && ((atomicType <= FFITypeSignedChar)
				 && ((((usqInt)(atomicType)) >> 1) == (((usqInt)(specType)) >> 1))))) {
				goto l3;
			}
		}
	l3:	/* end ffiValidateExternalData:AtomicType: */;
		if (failed()) {
			return null;
		}
		handle = fetchPointerofObject(0, oop);
		ptrClass = fetchClassOf(handle);
		if (ptrClass == (classExternalAddress())) {

			/* Don't you dare to pass pointers into object memory */
			pointer = fetchPointerofObject(0, handle);
			if (isInMemory(pointer)) {
				return FFIErrorInvalidPointer;
			}
		}
		else {
			if (ptrClass == (classByteArray())) {
				pointer = ((void *) (firstIndexableField(handle)));
			}
			else {
				return FFIErrorBadArg;
			}
		}
		
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushDereferenceUnsignedIntin(pointer, calloutState);
		case 2:
			return ffiPushDereferenceUnsignedBytein(pointer, calloutState);
		case 3:
			return ffiPushDereferenceSignedBytein(pointer, calloutState);
		case 4:
			return ffiPushDereferenceUnsignedShortin(pointer, calloutState);
		case 5:
			return ffiPushDereferenceSignedShortin(pointer, calloutState);
		case 6:
			return ffiPushDereferenceUnsignedIntin(pointer, calloutState);
		case 7:
			return ffiPushDereferenceSignedIntin(pointer, calloutState);
		case 8:
			return ffiPushDereferenceUnsignedLongLongin(pointer, calloutState);
		case 9:
			return ffiPushDereferenceSignedLongLongin(pointer, calloutState);
		case 10:
			return ffiPushDereferenceUnsignedCharin(pointer, calloutState);
		case 11:
			return ffiPushDereferenceSignedCharin(pointer, calloutState);
		case 12:
			return ffiPushDereferenceSingleFloatin(pointer, calloutState);
		case 13:
			return ffiPushDereferenceDoubleFloatin(pointer, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

		/* We do not have any type specification easily available.
		   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
		handle = fetchPointerofObject(0, oop);
		/* begin ffiArgByValue:in: */
		typeSpec1 = (calloutState->ffiArgHeader);
		atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((atomicType1 < 0)
		 || (atomicType1 > FFITypeDoubleFloat)) {
			return FFIErrorBadAtomicType;
		}
		if (atomicType1 < FFITypeSingleFloat) {

			/* integer types */
			if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

				/* ffi support code must coerce longlong */
				intValue = handle;
			}
			else {
				/* begin ffiIntegerValueOf: */
				if (handle & (BytesPerWord - 1)) {
					if (isIntegerObject(handle)) {
						intValue = integerValueOf(handle);
						goto l6;
					}
					
#          if SPURVM
					if (isCharacterObject(handle)) {

						/* Immediate in Spur */
						intValue = characterValueOf(handle);
						goto l6;
					}
					if (isFloatObject(handle)) {

						/* Immediate in 64-bit Spur */
						intValue = floatValueOf(handle);
						goto l6;
					}
#          endif /* SPURVM */
				}
				else {
					
#          if SPURVM

					/* No non-immediate characters in Spur */
#          else /* SPURVM */
					if (isCharacterObject(handle)) {
						intValue = characterValueOf(handle);
						goto l6;
					}
#          endif /* SPURVM */
					if (isFloatObject(handle)) {
						intValue = floatValueOf(handle);
						goto l6;
					}
					if (handle == (nilObject())) {
						intValue = 0;
						goto l6;
					}
					if (handle == (falseObject())) {
						intValue = 0;
						goto l6;
					}
					if (handle == (trueObject())) {
						intValue = 1;
						goto l6;
					}
					if (isLargePositiveIntegerObject(handle)) {
						
#            if BytesPerWord == 8

						/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
						intValue = positive64BitValueOf(handle);
						goto l6;
#            else /* BytesPerWord == 8 */
						intValue = positive32BitValueOf(handle);
						goto l6;
#            endif /* BytesPerWord == 8 */
					}
				}
				intValue = signedMachineIntegerValueOf(handle);
	l6:	/* end ffiIntegerValueOf: */;
			}
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
			
			switch (atomicType1) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 2:
				return ffiPushUnsignedBytein(intValue, calloutState);
			case 3:
				return ffiPushSignedBytein(intValue, calloutState);
			case 4:
				return ffiPushUnsignedShortin(intValue, calloutState);
			case 5:
				return ffiPushSignedShortin(intValue, calloutState);
			case 6:
				return ffiPushUnsignedIntin(intValue, calloutState);
			case 7:
				return ffiPushSignedIntin(intValue, calloutState);
			case 8:
				return ffiPushUnsignedLongLongOopin(intValue, calloutState);
			case 9:
				return ffiPushSignedLongLongOopin(intValue, calloutState);
			case 10:
				return ffiPushUnsignedCharin(intValue, calloutState);
			case 11:
				return ffiPushSignedCharin(intValue, calloutState);

			default:
				error("Case not found");
				return -1;
			}
		}
		/* begin ffiFloatValueOf: */
		if (isFloatObject(handle)) {
			floatValue = floatValueOf(handle);
			goto l4;
		}
		floatValue = ((double) (ffiIntegerValueOf(handle)) );
	l4:	/* end ffiFloatValueOf: */;
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType1 == FFITypeSingleFloat) {
			/* begin ffiPushSingleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				if (((calloutState->backfillFloatRegisterIndex)) > 0) {
					((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
					(calloutState->backfillFloatRegisterIndex = 0);
				}
				else {
					((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		else {
			/* begin ffiPushDoubleFloat:in: */
			if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
				if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
					(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
				}
				(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
			}
			else {
				if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				(calloutState->floatRegisterIndex = NumFloatRegArgs);
				storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + 8);
			}
			return 0;
		}
	}
	/* begin ffiArgByValue:in: */
	typeSpec2 = (calloutState->ffiArgHeader);
	atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((atomicType2 < 0)
	 || (atomicType2 > FFITypeDoubleFloat)) {
		return FFIErrorBadAtomicType;
	}
	if (atomicType2 < FFITypeSingleFloat) {

		/* integer types */
		if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

			/* ffi support code must coerce longlong */
			intValue1 = oop;
		}
		else {
			/* begin ffiIntegerValueOf: */
			if (oop & (BytesPerWord - 1)) {
				if (isIntegerObject(oop)) {
					intValue1 = integerValueOf(oop);
					goto l9;
				}
				
#        if SPURVM
				if (isCharacterObject(oop)) {

					/* Immediate in Spur */
					intValue1 = characterValueOf(oop);
					goto l9;
				}
				if (isFloatObject(oop)) {

					/* Immediate in 64-bit Spur */
					intValue1 = floatValueOf(oop);
					goto l9;
				}
#        endif /* SPURVM */
			}
			else {
				
#        if SPURVM

				/* No non-immediate characters in Spur */
#        else /* SPURVM */
				if (isCharacterObject(oop)) {
					intValue1 = characterValueOf(oop);
					goto l9;
				}
#        endif /* SPURVM */
				if (isFloatObject(oop)) {
					intValue1 = floatValueOf(oop);
					goto l9;
				}
				if (oop == (nilObject())) {
					intValue1 = 0;
					goto l9;
				}
				if (oop == (falseObject())) {
					intValue1 = 0;
					goto l9;
				}
				if (oop == (trueObject())) {
					intValue1 = 1;
					goto l9;
				}
				if (isLargePositiveIntegerObject(oop)) {
					
#          if BytesPerWord == 8

					/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
					intValue1 = positive64BitValueOf(oop);
					goto l9;
#          else /* BytesPerWord == 8 */
					intValue1 = positive32BitValueOf(oop);
					goto l9;
#          endif /* BytesPerWord == 8 */
				}
			}
			intValue1 = signedMachineIntegerValueOf(oop);
	l9:	/* end ffiIntegerValueOf: */;
		}
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		
		switch (atomicType2) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			return ffiPushUnsignedIntin(intValue1, calloutState);
		case 2:
			return ffiPushUnsignedBytein(intValue1, calloutState);
		case 3:
			return ffiPushSignedBytein(intValue1, calloutState);
		case 4:
			return ffiPushUnsignedShortin(intValue1, calloutState);
		case 5:
			return ffiPushSignedShortin(intValue1, calloutState);
		case 6:
			return ffiPushUnsignedIntin(intValue1, calloutState);
		case 7:
			return ffiPushSignedIntin(intValue1, calloutState);
		case 8:
			return ffiPushUnsignedLongLongOopin(intValue1, calloutState);
		case 9:
			return ffiPushSignedLongLongOopin(intValue1, calloutState);
		case 10:
			return ffiPushUnsignedCharin(intValue1, calloutState);
		case 11:
			return ffiPushSignedCharin(intValue1, calloutState);

		default:
			error("Case not found");
			return -1;
		}
	}
	/* begin ffiFloatValueOf: */
	if (isFloatObject(oop)) {
		floatValue1 = floatValueOf(oop);
		goto l7;
	}
	floatValue1 = ((double) (ffiIntegerValueOf(oop)) );
	l7:	/* end ffiFloatValueOf: */;
	if (failed()) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType2 == FFITypeSingleFloat) {
		/* begin ffiPushSingleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			if (((calloutState->backfillFloatRegisterIndex)) > 0) {
				((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
				(calloutState->backfillFloatRegisterIndex = 0);
			}
			else {
				((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	else {
		/* begin ffiPushDoubleFloat:in: */
		if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
			if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
				(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
			(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
		}
		else {
			if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			(calloutState->floatRegisterIndex = NumFloatRegArgs);
			storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
			(calloutState->currentArg = ((calloutState->currentArg)) + 8);
		}
		return 0;
	}
}


/*	So we want to pass a reference to immediate value, which is possible from:
	- ExternalStructure if class is matching expected argClass
	- ExternalData if type is matching expected argClass
	- nil (representing NULL pointer)
	direct use of ExternalAddress or ByteArray memory zone is considered
	unsafe. They have to be explicitely wrapped into an ExternalData and
	dressed with appropriate type
 */

	/* ThreadedFFIPlugin>>#ffiPassStructureArgumentByReference:Class:expectedClass:In: */
static sqInt
ffiPassStructureArgumentByReferenceClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState)
{
    sqInt handle;
    sqInt referentClass;
    sqInt type;

	if (includesBehaviorThatOf(oopClass, argClass)) {

		/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
		handle = fetchPointerofObject(0, oop);
		return ffiPushPointerContentsOfin(handle, calloutState);
	}
	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Fetch the type specification and check against expectedClass */
		type = fetchPointerofObject(1, oop);
		if (!((isPointers(type))
			 && ((slotSizeOf(type)) >= 2))) {
			return FFIErrorWrongType;
		}
		referentClass = fetchPointerofObject(1, type);
		if (!(includesBehaviorThatOf(referentClass, argClass))) {
			return FFIErrorCoercionFailed;
		}
		handle = fetchPointerofObject(0, oop);
		return ffiPushPointerContentsOfin(handle, calloutState);
	}
	if (oop == (nilObject())) {
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), null);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorCoercionFailed;
}


/*	So we want to pass a Structure by value, which is possible for:
	- ExternalStructure of expectedClass (or eventually a subclass)
	- ExternalData (dereferencing the pointer) of expectedClass
	Every other case is considered unsafe */

	/* ThreadedFFIPlugin>>#ffiPassStructureArgumentByValue:Class:expectedClass:In: */
static sqInt
ffiPassStructureArgumentByValueClassexpectedClassIn(sqInt oop, sqInt oopClass, sqInt argClass, CalloutState *calloutState)
{
    sqInt *argSpec;
    sqInt *argSpec1;
    sqInt *argSpec11;
    sqInt *argSpec2;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt argSpecSize11;
    sqInt argSpecSize2;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt availableRegisterSpace11;
    sqInt availableRegisterSpace2;
    sqInt handle;
    void * ptrAddress;
    void * ptrAddress1;
    sqInt ptrClass;
    sqInt ptrClass1;
    sqInt referentClass;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt roundedSize11;
    sqInt roundedSize2;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt stackPartSize11;
    sqInt stackPartSize2;
    sqInt structSize;
    sqInt structSize1;
    sqInt structSize11;
    sqInt structSize2;
    sqInt type;

	if (includesBehaviorThatOf(oopClass, argClass)) {

		/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
		handle = fetchPointerofObject(0, oop);
		/* begin ffiPushStructureContentsOf:in: */
		ptrClass = fetchClassOf(handle);
		if (ptrClass == (classExternalAddress())) {

			/* ExternalAddress is bytes */

			/* There is no way we can make sure the structure is valid.
			   But we can at least check for attempts to pass pointers to ST memory. */
			ptrAddress = ((void *)(fetchPointerofObject(0, handle)));
			if (isInMemory(ptrAddress)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec = (calloutState->ffiArgSpec);
			argSpecSize = (calloutState->ffiArgSpecSize);
			availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
			stackPartSize = structSize;
			if (availableRegisterSpace > 0) {
				if (structSize <= availableRegisterSpace) {

					/* all in registers */
					stackPartSize = 0;
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
				}
				else {

					/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
					   Otherwise push entire struct on stack. */
					if (((calloutState->currentArg)) == ((calloutState->argVector))) {
						stackPartSize = structSize - availableRegisterSpace;
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, availableRegisterSpace);
					}
					else {
						availableRegisterSpace = 0;
					}
					(calloutState->integerRegisterIndex = NumIntRegArgs);
				}
			}
			if (stackPartSize > 0) {
				roundedSize = (((stackPartSize + 3) | 3) - 3);
				if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				memcpy((calloutState->currentArg), (&((((char *) ptrAddress))[availableRegisterSpace])), stackPartSize);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
			}
			return 0;
		}
		if (ptrClass == (classByteArray())) {

			/* The following is a somewhat pessimistic test but I like being sure... */
			if (!((byteSizeOf(handle)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
				return FFIErrorStructSize;
			}
			ptrAddress = firstIndexableField(handle);
			if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

				/* Since this involves passing the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				
#        if COGMTVM
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(handle))) {
					return -PrimErrObjectMayMove;
				}
#        endif /* COGMTVM */
				/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
				structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
				argSpec1 = (calloutState->ffiArgSpec);
				argSpecSize1 = (calloutState->ffiArgSpecSize);
				availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
				stackPartSize1 = structSize1;
				if (availableRegisterSpace1 > 0) {
					if (structSize1 <= availableRegisterSpace1) {

						/* all in registers */
						stackPartSize1 = 0;
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize1);
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
					}
					else {

						/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
						   Otherwise push entire struct on stack. */
						if (((calloutState->currentArg)) == ((calloutState->argVector))) {
							stackPartSize1 = structSize1 - availableRegisterSpace1;
							memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, availableRegisterSpace1);
						}
						else {
							availableRegisterSpace1 = 0;
						}
						(calloutState->integerRegisterIndex = NumIntRegArgs);
					}
				}
				if (stackPartSize1 > 0) {
					roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
					if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					memcpy((calloutState->currentArg), (&((((char *) ptrAddress))[availableRegisterSpace1])), stackPartSize1);
					(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
				}
				return 0;
			}
			if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
				return FFIErrorStructSize;
			}
			ptrAddress = ((void *)(fetchPointerofObject(0, handle)));
			if (isInMemory(ptrAddress)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		return FFIErrorBadArg;
	}
	if (includesBehaviorThatOf(oopClass, classExternalData())) {

		/* Fetch the type specification and check against expectedClass */
		type = fetchPointerofObject(1, oop);
		if (!((isPointers(type))
			 && ((slotSizeOf(type)) >= 2))) {
			return FFIErrorWrongType;
		}
		referentClass = fetchPointerofObject(1, type);
		if (!(includesBehaviorThatOf(referentClass, argClass))) {
			return FFIErrorCoercionFailed;
		}
		handle = fetchPointerofObject(0, oop);
		/* begin ffiPushStructureContentsOf:in: */
		ptrClass1 = fetchClassOf(handle);
		if (ptrClass1 == (classExternalAddress())) {

			/* ExternalAddress is bytes */

			/* There is no way we can make sure the structure is valid.
			   But we can at least check for attempts to pass pointers to ST memory. */
			ptrAddress1 = ((void *)(fetchPointerofObject(0, handle)));
			if (isInMemory(ptrAddress1)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize2 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec2 = (calloutState->ffiArgSpec);
			argSpecSize2 = (calloutState->ffiArgSpecSize);
			availableRegisterSpace2 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
			stackPartSize2 = structSize2;
			if (availableRegisterSpace2 > 0) {
				if (structSize2 <= availableRegisterSpace2) {

					/* all in registers */
					stackPartSize2 = 0;
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize2);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize2 + 3))) >> 2)));
				}
				else {

					/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
					   Otherwise push entire struct on stack. */
					if (((calloutState->currentArg)) == ((calloutState->argVector))) {
						stackPartSize2 = structSize2 - availableRegisterSpace2;
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace2);
					}
					else {
						availableRegisterSpace2 = 0;
					}
					(calloutState->integerRegisterIndex = NumIntRegArgs);
				}
			}
			if (stackPartSize2 > 0) {
				roundedSize2 = (((stackPartSize2 + 3) | 3) - 3);
				if ((((calloutState->currentArg)) + roundedSize2) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace2])), stackPartSize2);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize2);
			}
			return 0;
		}
		if (ptrClass1 == (classByteArray())) {

			/* The following is a somewhat pessimistic test but I like being sure... */
			if (!((byteSizeOf(handle)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
				return FFIErrorStructSize;
			}
			ptrAddress1 = firstIndexableField(handle);
			if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

				/* Since this involves passing the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				
#        if COGMTVM
				if ((((calloutState->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(handle))) {
					return -PrimErrObjectMayMove;
				}
#        endif /* COGMTVM */
				/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
				structSize11 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
				argSpec11 = (calloutState->ffiArgSpec);
				argSpecSize11 = (calloutState->ffiArgSpecSize);
				availableRegisterSpace11 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
				stackPartSize11 = structSize11;
				if (availableRegisterSpace11 > 0) {
					if (structSize11 <= availableRegisterSpace11) {

						/* all in registers */
						stackPartSize11 = 0;
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize11);
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize11 + 3))) >> 2)));
					}
					else {

						/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
						   Otherwise push entire struct on stack. */
						if (((calloutState->currentArg)) == ((calloutState->argVector))) {
							stackPartSize11 = structSize11 - availableRegisterSpace11;
							memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace11);
						}
						else {
							availableRegisterSpace11 = 0;
						}
						(calloutState->integerRegisterIndex = NumIntRegArgs);
					}
				}
				if (stackPartSize11 > 0) {
					roundedSize11 = (((stackPartSize11 + 3) | 3) - 3);
					if ((((calloutState->currentArg)) + roundedSize11) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace11])), stackPartSize11);
					(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize11);
				}
				return 0;
			}
			if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
				return FFIErrorStructSize;
			}
			ptrAddress1 = ((void *)(fetchPointerofObject(0, handle)));
			if (isInMemory(ptrAddress1)) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress1));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress1);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		return FFIErrorBadArg;
	}
	return FFIErrorCoercionFailed;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceDoubleFloat:in: */
static sqInt
ffiPushDereferenceDoubleFloatin(void *pointer, CalloutState *calloutState)
{
    double floatValue;

	floatValue = (((double *) pointer))[0];
	/* begin ffiPushDoubleFloat:in: */
	if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
		if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
			(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
		}
		(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
		(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->floatRegisterIndex = NumFloatRegArgs);
		storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSignedByte:in: */
static sqInt
ffiPushDereferenceSignedBytein(void *pointer, CalloutState *calloutState)
{
    signed char intValue;

	intValue = (((signed char *) pointer))[0];
	/* begin ffiPushSignedByte:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSignedChar:in: */
static sqInt
ffiPushDereferenceSignedCharin(void *pointer, CalloutState *calloutState)
{
    signed char intValue;

	intValue = (((signed char *) pointer))[0];
	/* begin ffiPushSignedChar:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSignedInt:in: */
static sqInt
ffiPushDereferenceSignedIntin(void *pointer, CalloutState *calloutState)
{
    int intValue;

	intValue = (((int *) pointer))[0];
	/* begin ffiPushSignedInt:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = intValue;
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), intValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSignedLongLong:in: */
static sqInt
ffiPushDereferenceSignedLongLongin(void *pointer, CalloutState *calloutState)
{
    sqLong intValue;

	intValue = (((sqLong *) pointer))[0];
	/* begin ffiPushSignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) intValue));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) (((usqLong)(intValue)) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) intValue));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) (((usqLong)(intValue)) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSignedShort:in: */
static sqInt
ffiPushDereferenceSignedShortin(void *pointer, CalloutState *calloutState)
{
    short intValue;

	intValue = (((short *) pointer))[0];
	/* begin ffiPushSignedShort:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed short) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceSingleFloat:in: */
static sqInt
ffiPushDereferenceSingleFloatin(void *pointer, CalloutState *calloutState)
{
    double floatValue;

	floatValue = (((float *) pointer))[0];
	/* begin ffiPushSingleFloat:in: */
	if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
		if (((calloutState->backfillFloatRegisterIndex)) > 0) {
			((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
			(calloutState->backfillFloatRegisterIndex = 0);
		}
		else {
			((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
		}
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceUnsignedByte:in: */
static sqInt
ffiPushDereferenceUnsignedBytein(void *pointer, CalloutState *calloutState)
{
    unsigned char intValue;

	intValue = (((unsigned char *) pointer))[0];
	/* begin ffiPushUnsignedByte:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceUnsignedChar:in: */
static sqInt
ffiPushDereferenceUnsignedCharin(void *pointer, CalloutState *calloutState)
{
    unsigned char intValue;

	intValue = (((unsigned char *) pointer))[0];
	/* begin ffiPushUnsignedChar:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceUnsignedInt:in: */
static sqInt
ffiPushDereferenceUnsignedIntin(void *pointer, CalloutState *calloutState)
{
    unsigned int intValue;

	intValue = (((unsigned int *) pointer))[0];
	/* begin ffiPushUnsignedInt:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = intValue;
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), intValue);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceUnsignedLongLong:in: */
static sqInt
ffiPushDereferenceUnsignedLongLongin(void *pointer, CalloutState *calloutState)
{
    usqLong intValue;

	intValue = (((usqLong *) pointer))[0];
	/* begin ffiPushUnsignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) intValue));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) ((intValue) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) intValue));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) ((intValue) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushDereferenceUnsignedShort:in: */
static sqInt
ffiPushDereferenceUnsignedShortin(void *pointer, CalloutState *calloutState)
{
    unsigned short intValue;

	intValue = (((unsigned short *) pointer))[0];
	/* begin ffiPushUnsignedShort:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned short) intValue));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}


/*	This is a fallback in case somebody tries to pass a 'void' value.
	We could simply ignore the argument but I think it's better to let
	the caller know what he did */

	/* ThreadedFFIPlugin>>#ffiPushDereferenceVoid:in: */
static sqInt
ffiPushDereferenceVoidin(void *pointer, CalloutState *calloutState)
{
	return FFIErrorAttemptToPassVoid;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushPointerContentsOf:in: */
static sqInt
ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState)
{
    void * ptrAddress;
    sqInt ptrClass;

	ptrClass = fetchClassOf(oop);
	if (ptrClass == (classExternalAddress())) {

		/* Don't you dare to pass pointers into object memory */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (ptrClass == (classByteArray())) {

		/* Since this involves passing the address of the first indexable field we need to fail
		   the call if it is threaded and the object is young, since it may move during the call. */
		
#    if COGMTVM
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (isYoung(oop))) {
			return -PrimErrObjectMayMove;
		}
#    endif /* COGMTVM */
		ptrAddress = firstIndexableField(oop);
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (includesBehaviorThatOf(ptrClass, classAlien())) {
		
#    if COGMTVM
		if ((((calloutState->callFlags)) & FFICallFlagThreaded)
		 && (((assert(isAlien(oop)),
		(longAt(oop + BaseHeaderSize)) > 0))
		 && (isYoung(oop)))) {
			return -PrimErrObjectMayMove;
		}
#    endif /* COGMTVM */
		ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
			? (oop + BaseHeaderSize) + BytesPerOop
			: longAt((oop + BaseHeaderSize) + BytesPerOop));
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorBadArg;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushPointer:in: */
static sqInt
ffiPushPointerin(void *pointer, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), pointer);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushSignedByte:in: */
static sqInt
ffiPushSignedBytein(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushSignedChar:in: */
static sqInt
ffiPushSignedCharin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushSignedInt:in: */
static sqInt
ffiPushSignedIntin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}


/*	Push a longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

	/* ThreadedFFIPlugin>>#ffiPushSignedLongLongOop:in: */
static sqInt
ffiPushSignedLongLongOopin(sqInt oop, CalloutState *calloutState)
{
    sqLong value;

	if ((oop == (nilObject()))
	 || (oop == (falseObject()))) {
		value = 0;
	}
	else {
		if (oop == (trueObject())) {
			value = 1;
		}
		else {
			value = signed64BitValueOf(oop);
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushSignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) (((usqLong)(value)) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) value));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) (((usqLong)(value)) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushSignedLongLong:in: */
static sqInt
ffiPushSignedLongLongin(sqLong value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) (((usqLong)(value)) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) value));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) (((usqLong)(value)) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushSignedShort:in: */
static sqInt
ffiPushSignedShortin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((signed short) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#ffiPushString:OfLength:in: */
static sqInt
ffiPushStringOfLengthin(char *pointer, sqInt length, CalloutState *calloutState)
{
    char *copy;

	if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
		return -PrimErrBadNumArgs;
	}
	copy = malloc(length + 1);
	if (copy == null) {
		return -PrimErrNoCMemory;
	}
	memcpy(copy, pointer, length);
	copy[length] = 0;
	((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
	(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
	/* begin ffiPushPointer:in: */
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), copy);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushStructureContentsOf:in: */
static sqInt
ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState)
{
    sqInt *argSpec;
    sqInt *argSpec1;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    void * ptrAddress;
    sqInt ptrClass;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt structSize;
    sqInt structSize1;

	ptrClass = fetchClassOf(oop);
	if (ptrClass == (classExternalAddress())) {

		/* ExternalAddress is bytes */

		/* There is no way we can make sure the structure is valid.
		   But we can at least check for attempts to pass pointers to ST memory. */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
		structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
		argSpec = (calloutState->ffiArgSpec);
		argSpecSize = (calloutState->ffiArgSpecSize);
		availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
		stackPartSize = structSize;
		if (availableRegisterSpace > 0) {
			if (structSize <= availableRegisterSpace) {

				/* all in registers */
				stackPartSize = 0;
				memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize);
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
			}
			else {

				/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
				   Otherwise push entire struct on stack. */
				if (((calloutState->currentArg)) == ((calloutState->argVector))) {
					stackPartSize = structSize - availableRegisterSpace;
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, availableRegisterSpace);
				}
				else {
					availableRegisterSpace = 0;
				}
				(calloutState->integerRegisterIndex = NumIntRegArgs);
			}
		}
		if (stackPartSize > 0) {
			roundedSize = (((stackPartSize + 3) | 3) - 3);
			if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			memcpy((calloutState->currentArg), (&((((char *) ptrAddress))[availableRegisterSpace])), stackPartSize);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
		}
		return 0;
	}
	if (ptrClass == (classByteArray())) {

		/* The following is a somewhat pessimistic test but I like being sure... */
		if (!((byteSizeOf(oop)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
			return FFIErrorStructSize;
		}
		ptrAddress = firstIndexableField(oop);
		if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

			/* Since this involves passing the address of the first indexable field we need to fail
			   the call if it is threaded and the object is young, since it may move during the call. */
			
#      if COGMTVM
			if ((((calloutState->callFlags)) & FFICallFlagThreaded)
			 && (isYoung(oop))) {
				return -PrimErrObjectMayMove;
			}
#      endif /* COGMTVM */
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec1 = (calloutState->ffiArgSpec);
			argSpecSize1 = (calloutState->ffiArgSpecSize);
			availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
			stackPartSize1 = structSize1;
			if (availableRegisterSpace1 > 0) {
				if (structSize1 <= availableRegisterSpace1) {

					/* all in registers */
					stackPartSize1 = 0;
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize1);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
				}
				else {

					/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
					   Otherwise push entire struct on stack. */
					if (((calloutState->currentArg)) == ((calloutState->argVector))) {
						stackPartSize1 = structSize1 - availableRegisterSpace1;
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, availableRegisterSpace1);
					}
					else {
						availableRegisterSpace1 = 0;
					}
					(calloutState->integerRegisterIndex = NumIntRegArgs);
				}
			}
			if (stackPartSize1 > 0) {
				roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
				if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				memcpy((calloutState->currentArg), (&((((char *) ptrAddress))[availableRegisterSpace1])), stackPartSize1);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
			}
			return 0;
		}
		if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
			return FFIErrorStructSize;
		}
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(ptrAddress)) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorBadArg;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushStructure:ofSize:typeSpec:ofLength:in: */
static sqInt
ffiPushStructureofSizetypeSpecofLengthin(void *pointer, sqInt structSize, sqInt *argSpec, sqInt argSpecSize, CalloutState *calloutState)
{
    sqInt availableRegisterSpace;
    sqInt roundedSize;
    sqInt stackPartSize;

	availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
	stackPartSize = structSize;
	if (availableRegisterSpace > 0) {
		if (structSize <= availableRegisterSpace) {

			/* all in registers */
			stackPartSize = 0;
			memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), pointer, structSize);
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
		}
		else {

			/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
			   Otherwise push entire struct on stack. */
			if (((calloutState->currentArg)) == ((calloutState->argVector))) {
				stackPartSize = structSize - availableRegisterSpace;
				memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), pointer, availableRegisterSpace);
			}
			else {
				availableRegisterSpace = 0;
			}
			(calloutState->integerRegisterIndex = NumIntRegArgs);
		}
	}
	if (stackPartSize > 0) {
		roundedSize = (((stackPartSize + 3) | 3) - 3);
		if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		memcpy((calloutState->currentArg), (&((((char *) pointer))[availableRegisterSpace])), stackPartSize);
		(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushUnsignedByte:in: */
static sqInt
ffiPushUnsignedBytein(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushUnsignedChar:in: */
static sqInt
ffiPushUnsignedCharin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned char) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushUnsignedInt:in: */
static sqInt
ffiPushUnsignedIntin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = value;
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), value);
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}


/*	Push an unsigned longlong type (e.g., a 64bit integer).
	Note: Coercions from float are *not* supported. */

	/* ThreadedFFIPlugin>>#ffiPushUnsignedLongLongOop:in: */
static sqInt
ffiPushUnsignedLongLongOopin(sqInt oop, CalloutState *calloutState)
{
    usqLong value;

	if ((oop == (nilObject()))
	 || (oop == (falseObject()))) {
		value = 0;
	}
	else {
		if (oop == (trueObject())) {
			value = 1;
		}
		else {
			value = positive64BitValueOf(oop);
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
		}
	}
	/* begin ffiPushUnsignedLongLong:in: */
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) ((value) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) value));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) ((value) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushUnsignedLongLong:in: */
static sqInt
ffiPushUnsignedLongLongin(usqLong value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < (NumIntRegArgs - 1)) {
		(calloutState->integerRegisterIndex = (((((calloutState->integerRegisterIndex)) + 1) | 1) - 1));
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqInt) value));
		((calloutState->integerRegisters))[((calloutState->integerRegisterIndex)) + 1] = (((usqInt) ((value) >> 32)));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 2);
	}
	else {
		if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		(calloutState->integerRegisterIndex = NumIntRegArgs);
		longAtput((calloutState->currentArg), ((usqInt) value));
		longAtput(((calloutState->currentArg)) + BytesPerWord, ((usqInt) ((value) >> 32)));
		(calloutState->currentArg = ((calloutState->currentArg)) + 8);
	}
	return 0;
}

	/* ThreadedARM32FFIPlugin>>#ffiPushUnsignedShort:in: */
static sqInt
ffiPushUnsignedShortin(sqInt value, CalloutState *calloutState)
{
	if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
		((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) value));
		(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
	}
	else {
		if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
			return FFIErrorCallFrameTooBig;
		}
		longAtput((calloutState->currentArg), ((unsigned short) value));
		(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
	}
	return 0;
}


/*	This is a fallback in case somebody tries to pass a 'void' value.
	We could simply ignore the argument but I think it's better to let
	the caller know what he did */

	/* ThreadedFFIPlugin>>#ffiPushVoid:in: */
static sqInt
ffiPushVoidin(sqInt ignored, CalloutState *calloutState)
{
	return FFIErrorAttemptToPassVoid;
}


/*	Create a Smalltalk string from a zero terminated C string */

	/* ThreadedFFIPlugin>>#ffiReturnCStringFrom: */
static sqInt
ffiReturnCStringFrom(sqInt cPointer)
{
    char *cString;
    sqInt i;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;

	if (!(cPointer)) {
		return nilObject();
	}
	cString = ((char *) cPointer);
	strLen = 0;
	while (!((cString[strLen]) == 0)) {
		strLen += 1;
	}
	strOop = instantiateClassindexableSize(classString(), strLen);
	strPtr = firstIndexableField(strOop);
	for (i = 0; i < strLen; i += 1) {
		strPtr[i] = (cString[i]);
	}
	return strOop;
}


/*	Generic callout support. Create a pointer return value from an external
	function call
 */

	/* ThreadedFFIPlugin>>#ffiReturnPointer:ofType:in: */
static sqInt
ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState)
{
    sqInt atomicType;
    sqInt cPointer;
    char *cString;
    sqInt i;
    sqInt oop;
    sqInt *ptr;
    sqInt retClass;
    sqInt retOop;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;

	retClass = fetchPointerofObject(1, retType);
	if (retClass == (nilObject())) {

		/* Create ExternalData upon return */
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

			/* String return */
			/* begin ffiReturnCStringFrom: */
			cPointer = ((usqInt) retVal);
			if (!(cPointer)) {
				retOop = nilObject();
				goto l1;
			}
			cString = ((char *) cPointer);
			strLen = 0;
			while (!((cString[strLen]) == 0)) {
				strLen += 1;
			}
			strOop = instantiateClassindexableSize(classString(), strLen);
			strPtr = firstIndexableField(strOop);
			for (i = 0; i < strLen; i += 1) {
				strPtr[i] = (cString[i]);
			}
			retOop = strOop;
	l1:	/* end ffiReturnCStringFrom: */;
			return retOop;
		}
	}
	
#if SPURVM
	oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
	ptr = firstIndexableField(oop);
	ptr[0] = (((sqInt) retVal));
	retOop = instantiateClassindexableSize(classExternalData(), 0);
	storePointerofObjectwithValue(0, retOop, oop);

#else /* SPURVM */
	pushRemappableOop(retType);
	oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
	ptr = firstIndexableField(oop);
	ptr[0] = (((sqInt) retVal));
		pushRemappableOop(oop);
	retOop = instantiateClassindexableSize(classExternalData(), 0);
	oop = popRemappableOop();
	storePointerofObjectwithValue(0, retOop, oop);
	retType = popRemappableOop()
#endif /* SPURVM */
;
	storePointerofObjectwithValue(1, retOop, retType);
	return retOop;
}


/*	Create a structure return value from an external function call. The value
	has been stored in
	alloca'ed space pointed to by the calloutState or in the return value
	passed by pointer. */

	/* ThreadedARM32FFIPlugin>>#ffiReturnStruct:ofType:in: */
static sqInt
ffiReturnStructofTypein(void *longLongRetPtr, sqInt ffiRetType, CalloutState *calloutState)
{
    sqInt oop;
    sqInt retClass;
    sqInt retOop;

	retClass = fetchPointerofObject(1, ffiRetType);
	retOop = instantiateClassindexableSize(retClass, 0);
	
#if SPURVM
	oop = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));

#else /* SPURVM */
	pushRemappableOop(retOop);
	oop = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
	retOop = popRemappableOop()
#endif /* SPURVM */
;
	memcpy(firstIndexableField(oop), ((calloutState->structReturnType)
		? longLongRetPtr
		: (calloutState->limit)), (calloutState->structReturnSize));
	storePointerofObjectwithValue(0, retOop, oop);
	return retOop;
}


/*	Answer the return type object for the current invocation */

	/* ThreadedFFIPlugin>>#ffiReturnType: */
static sqInt
ffiReturnType(sqInt specOnStack)
{
    sqInt argTypes;
    sqInt specLiteral;

	specLiteral = (specOnStack
		? stackValue(1)
		: literalofMethod(0, primitiveMethod()));
	argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
	return fetchPointerofObject(0, argTypes);
}


/*	Check that the calling convention is valid. This test also filters out
	attempts to do a threaded call in the non-threaded VM/plugin combinatioin. */

	/* ThreadedFFIPlugin>>#ffiSupportsCallingConvention: */
static sqInt
ffiSupportsCallingConvention(sqInt aCallingConvention)
{
	return (aCallingConvention == FFICallTypeCDecl)
	 || (aCallingConvention == FFICallTypeApi);
}


/*	Validate if the given oop (an instance of ExternalData) can be passed as a
	pointer to the given atomic type.
 */

	/* ThreadedFFIPlugin>>#ffiValidateExternalData:AtomicType: */
static sqInt
ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType)
{
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;

	ptrType = fetchPointerofObject(1, oop);
	if (!((isPointers(ptrType))
		 && ((slotSizeOf(ptrType)) >= 2))) {
		return FFIErrorWrongType;
	}
	specOop = fetchPointerofObject(0, ptrType);
	if (!((isWords(specOop))
		 && ((slotSizeOf(specOop)) > 0))) {
		return FFIErrorWrongType;
	}
	spec = fetchPointerofObject(0, specOop);
	if (!(spec & FFIFlagAtomic)) {
		return FFIErrorWrongType;
	}
	/* begin atomicTypeOf: */
	specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if (specType != atomicType) {

		/* Allow for signed/unsigned conversion but nothing else.
		   See FFIConstants class>>#initializeTypeConstants */
		if (!((atomicType >= FFITypeUnsignedByte)
			 && ((atomicType <= FFITypeSignedChar)
			 && ((((usqInt)(atomicType)) >> 1) == (((usqInt)(specType)) >> 1))))) {
			return FFIErrorCoercionFailed;
		}
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* ThreadedFFIPlugin>>#getModuleName */
EXPORT(const char *)
getModuleName(void)
{
	return "SqueakFFIPrims" PluginVersionInfo;
}

	/* ThreadedFFIPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{

	/* By default, disable logging */
	ffiLastError = 0;

	/* Get the instSize of ExternalFunction to know whether it contains a cache of the stackSize,
	   and what the offset of ExternalLibraryFunction's functionName and moduleName slots are. */
	ffiLogEnabled = 0;
	externalFunctionInstSize = instanceSizeOf(classExternalFunction());
	initSurfacePluginFunctionPointers();
	return 1;
}

	/* ThreadedFFIPlugin>>#isAlien: */
static sqInt
isAlien(sqInt anOop)
{
	return includesBehaviorThatOf(fetchClassOf(anOop), classAlien());
}

	/* ThreadedFFIPlugin>>#isAtomicType: */
static sqInt
isAtomicType(sqInt typeSpec)
{
	return typeSpec & FFIFlagAtomic;
}

	/* ThreadedFFIPlugin>>#isDirectAlien: */
static sqInt
isDirectAlien(sqInt oop)
{
	assert(isAlien(oop));
	return (longAt(oop + BaseHeaderSize)) > 0;
}


/*	We can't easily distinguish union from structures with available flags.
	But we have a trick: a union should have one field size equal to its own
	size. 
 */

	/* ThreadedFFIPlugin>>#isUnionSpec:OfLength:StartingAt: */
static sqInt
isUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt index;
    unsigned int spec;
    unsigned int thisSize;
    unsigned int unionSize;

	index = startIndex;
	spec = specs[index];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	unionSize = spec & FFIStructSizeMask;
	while (1) {
		index += 1;
		if (!(index < specSize)) break;
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return 0;
		}
		thisSize = spec & FFIStructSizeMask;
		if (thisSize == unionSize) {
			return 1;
		}
		if ((spec & (FFIFlagPointer + FFIFlagStructure)) == FFIFlagStructure) {

			/* Asking for alignment is a trick for skipping this sub structure/union */
			alignmentOfStructSpecOfLengthStartingAt(specs, specSize, (&index));
		}
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#msg: */
static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", getModuleName(), s);
	return 0;
}


/*	Answer if a struct returned in memory is returned to the
	referent of a pointer passed as an implciit first argument.
	It almost always is. Subclasses can override if not. */

	/* ThreadedFFIPlugin>>#nonRegisterStructReturnIsViaImplicitFirstArgument */
static sqInt
nonRegisterStructReturnIsViaImplicitFirstArgument(void)
{
	return 1;
}


/*	IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE
	Interpreter>>primitiveCalloutToFFI
	TO REFLECT THE CHANGE. */
/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec. */

	/* ThreadedFFIPlugin>>#primitiveCallout */
EXPORT(void)
primitiveCallout(void)
{
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt addressPtr;
    sqInt addressPtr1;
    sqInt alias;
    sqInt alias1;
    char *allocation;
    char *allocation1;
    sqInt argClass;
    sqInt argClass1;
    sqInt argSpec;
    sqInt *argSpec1;
    sqInt *argSpec11;
    sqInt *argSpec111;
    sqInt *argSpec12;
    sqInt *argSpec2;
    sqInt *argSpec21;
    sqInt *argSpec3;
    sqInt *argSpec31;
    sqInt argSpec4;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt argSpecSize11;
    sqInt argSpecSize111;
    sqInt argSpecSize12;
    sqInt argSpecSize2;
    sqInt argSpecSize21;
    sqInt argSpecSize3;
    sqInt argType;
    sqInt argType1;
    sqInt argTypeArray;
    sqInt argTypeArray1;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt argTypes11;
    sqInt argTypes2;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType111;
    sqInt atomicType12;
    sqInt atomicType121;
    sqInt atomicType13;
    sqInt atomicType2;
    sqInt atomicType21;
    sqInt atomicType211;
    sqInt atomicType22;
    sqInt atomicType3;
    sqInt atomicType31;
    sqInt atomicType311;
    sqInt atomicType32;
    sqInt atomicType4;
    sqInt atomicType41;
    sqInt atomicType5;
    sqInt atomicType51;
    sqInt atomicType6;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt availableRegisterSpace11;
    sqInt availableRegisterSpace111;
    sqInt availableRegisterSpace12;
    sqInt availableRegisterSpace2;
    sqInt availableRegisterSpace21;
    sqInt availableRegisterSpace3;
    sqInt byteSize;
    sqInt byteSize1;
    CalloutState *calloutState;
    CalloutState *calloutState1;
    char *copy;
    char *copy1;
    sqInt cPointer;
    sqInt cPointer1;
    char *cString;
    char *cString1;
    sqInt err;
    sqInt err1;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt ffiRetType1;
    sqInt flags;
    sqInt flags1;
    double floatRet;
    double floatRet1;
    double floatValue;
    double floatValue1;
    double floatValue11;
    double floatValue111;
    double floatValue12;
    double floatValue2;
    double floatValue21;
    double floatValue3;
    double floatValue31;
    double floatValue4;
    sqInt functionName;
    sqInt functionName1;
    sqInt handle;
    sqInt handle1;
    sqInt handle11;
    sqInt handle2;
    sqInt handle21;
    sqInt handle3;
    sqInt handle31;
    sqInt handle4;
    sqInt handle41;
    sqInt handle5;
    sqInt handle51;
    sqInt handle6;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    usqLong intRet;
    usqLong intRet1;
    sqInt intValue;
    sqInt intValue1;
    sqInt intValue11;
    sqInt intValue111;
    sqInt intValue12;
    sqInt intValue2;
    sqInt intValue21;
    sqInt intValue3;
    sqInt intValue31;
    sqInt intValue4;
    sqInt length;
    sqInt length1;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    void *longLongRetPtr1;
    usqLong mask;
    usqLong mask1;
    sqInt meth;
    sqInt myThreadIndex;
    sqInt myThreadIndex1;
    sqInt nArgs;
    sqInt nArgs1;
    sqInt nilOop;
    sqInt nilOop1;
    sqInt oop;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt oop3;
    sqInt oopClass;
    sqInt oopClass1;
    void *pointer;
    void *pointer1;
    void *pointer11;
    void *pointer2;
    void *pointer21;
    void *pointer3;
    void *pointer31;
    void *pointer4;
    void *pointer41;
    void *pointer5;
    void *pointer51;
    void *pointer6;
    void *pointer61;
    char *pointer7;
    char *pointer71;
    void *pointer8;
    sqInt primNumArgs;
    sqInt primNumArgs1;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt *ptr11;
    sqIntptr_t *ptr2;
    void * ptrAddress;
    void * ptrAddress1;
    void * ptrAddress11;
    void * ptrAddress2;
    void * ptrAddress21;
    void * ptrAddress3;
    sqInt ptrClass;
    sqInt ptrClass1;
    sqInt ptrClass11;
    sqInt ptrClass111;
    sqInt ptrClass12;
    sqInt ptrClass2;
    sqInt ptrClass21;
    sqInt ptrClass3;
    sqInt ptrClass31;
    sqInt ptrClass4;
    sqInt ptrType;
    sqInt ptrType1;
    sqInt ptrType11;
    sqInt ptrType2;
    sqInt referentClass;
    sqInt referentClass1;
    sqInt referentClass11;
    sqInt referentClass2;
    sqInt referentClass21;
    sqInt referentClass3;
    sqInt referentClass31;
    sqInt referentClass4;
    sqInt requiredStackSize;
    sqInt requiredStackSize1;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass11;
    sqInt retClass2;
    sqInt retClass21;
    sqInt retClass3;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop11;
    sqInt retOop2;
    sqInt retryCount;
    sqInt retType;
    sqInt retType1;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt roundedSize11;
    sqInt roundedSize111;
    sqInt roundedSize12;
    sqInt roundedSize2;
    sqInt roundedSize21;
    sqInt roundedSize3;
    sqInt shift;
    sqInt shift1;
    sqInt spec;
    sqInt spec1;
    sqInt spec11;
    sqInt spec2;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specLiteral11;
    sqInt specLiteral2;
    sqInt specOop;
    sqInt specOop1;
    sqInt specOop11;
    sqInt specOop2;
    sqInt specType;
    sqInt specType1;
    sqInt specType11;
    sqInt specType2;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt stackPartSize11;
    sqInt stackPartSize111;
    sqInt stackPartSize12;
    sqInt stackPartSize2;
    sqInt stackPartSize21;
    sqInt stackPartSize3;
    sqInt stackSize;
    sqInt stackSize1;
    sqInt strLen;
    sqInt strLen1;
    sqInt strOop;
    sqInt strOop1;
    char *strPtr;
    char *strPtr1;
    sqInt structSize;
    sqInt structSize1;
    sqInt structSize11;
    sqInt structSize111;
    sqInt structSize12;
    sqInt structSize2;
    sqInt structSize21;
    sqInt structSize3;
    CalloutState theCalloutState;
    CalloutState theCalloutState1;
    sqInt type;
    sqInt type1;
    sqInt type11;
    sqInt type2;
    sqInt type21;
    sqInt type3;
    sqInt type31;
    sqInt type4;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec111;
    sqInt typeSpec12;
    sqInt typeSpec121;
    sqInt typeSpec13;
    sqInt typeSpec2;
    sqInt typeSpec21;
    sqInt typeSpec211;
    sqInt typeSpec22;
    sqInt typeSpec3;
    sqInt typeSpec31;
    sqInt typeSpec311;
    sqInt typeSpec32;
    sqInt typeSpec4;
    sqInt typeSpec41;
    sqInt typeSpec5;
    sqInt typeSpec51;
    sqInt typeSpec6;
    usqLong value;
    usqLong value1;

	pointer5 = ((void *) 0);
	pointer51 = ((void *) 0);
	pointer6 = ((void *) 0);
	pointer61 = ((void *) 0);
	meth = primitiveMethod();
	if (!((literalCountOf(meth)) > 0)) {
		primitiveFailFor(PrimErrBadMethod);
		return;
	}
	externalFunction = literalofMethod(0, meth);
	
#  if COGMTVM
	nArgs = methodArgumentCount();
	retryCount = 0;
	while (1) {
		/* begin ffiCall:ArgArrayOrNil:NumArgs: */
		primNumArgs = methodArgumentCount();
		if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
			result = ffiFail(FFIErrorNotFunction);
			goto l34;
		}
		flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
		if (failed()) {
			result = ffiFail(FFIErrorBadArgs);
			goto l34;
		}
		/* begin ffiLoadCalloutAddress: */

		/* Make sure it's an external handle */
		addressPtr = fetchPointerofObject(0, externalFunction);
		if (!((isBytes(addressPtr))
			 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
			address1 = ffiFail(FFIErrorBadAddress);
			goto l1;
		}
		address1 = fetchPointerofObject(0, addressPtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
		if (failed()) {
			address = 0;
			goto l2;
		}
		if (address1 == 0) {

			/* Go look it up in the module */
			if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
				storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1));
			}
			if ((slotSizeOf(externalFunction)) < 5) {
				address = ffiFail(FFIErrorNoModule);
				goto l2;
			}
			address1 = ffiLoadCalloutAddressFrom(externalFunction);
			if (failed()) {
				address = 0;
				goto l2;
			}
			ptr = firstIndexableField(addressPtr);
			ptr[0] = address1;
		}
		address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
		if (failed()) {
			result = 0;
			goto l34;
		}

		/* must be array of arg types */
		argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
		if (!((isArray(argTypeArray))
			 && ((slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
			result = ffiFail(FFIErrorBadArgs);
			goto l34;
		}
		
#    if COGMTVM
		if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
			 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType);
			goto l34;
		}
#    else /* COGMTVM */

		/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
		if (!((flags == FFICallTypeCDecl)
			 || (flags == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType);
			goto l34;
		}
#    endif /* COGMTVM */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			requiredStackSize = fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction);
		}
		else {
			requiredStackSize = -1;
		}
		if (failed()) {
			result = primitiveFailFor((null == null
				? PrimErrBadMethod
				: PrimErrBadReceiver));
			goto l34;
		}
		stackSize = (requiredStackSize < 0
			? DefaultMaxStackSize
			: requiredStackSize);
		calloutState = (&theCalloutState);
		memset(calloutState, 0, sizeof(CalloutState));
		(calloutState->callFlags = flags);
		argType = fetchPointerofObject(0, argTypeArray);
		argSpec = fetchPointerofObject(0, argType);
		retClass = fetchPointerofObject(1, argType);
		if (((err = ffiCheckReturnWithin(argSpec, retClass, calloutState))) != 0) {
			result = ffiFail(err);
			goto l34;
		}
		allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
		if (mustAlignStack()) {
			allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
		}
		(calloutState->argVector = allocation);
		(calloutState->currentArg = allocation);
		(calloutState->limit = allocation + stackSize);
		if ((((calloutState->structReturnSize)) > 0)
		 && (1
		 && (!((calloutState->structReturnType))))) {
			/* begin ffiPushPointer:in: */
			pointer = (calloutState->limit);
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					err = FFIErrorCallFrameTooBig;
					goto l4;
				}
				longAtput((calloutState->currentArg), pointer);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			err = 0;
	l4:	/* end ffiPushPointer:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l34;
				}
#        endif /* COGMTVM */
				result = ffiFail(err);
				goto l34;
			}
		}
		for (i = 1; i <= nArgs; i += 1) {
			argType = fetchPointerofObject(i, argTypeArray);
			argSpec = fetchPointerofObject(0, argType);
			argClass = fetchPointerofObject(1, argType);
			oop = (null == null
				? stackValue(nArgs - i)
				: fetchPointerofObject(i - 1, null));
			/* begin ffiArgument:Spec:Class:in: */
			if (!(isWords(argSpec))) {
				err = FFIErrorWrongType;
				goto l33;
			}
			(calloutState->ffiArgSpecSize = slotSizeOf(argSpec));
			if (((calloutState->ffiArgSpecSize)) == 0) {
				err = FFIErrorWrongType;
				goto l33;
			}
			(calloutState->ffiArgSpec = firstIndexableField(argSpec));
			(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));

			/* Prefetch class (we'll need it) */
			oopClass = fetchClassOf(oop);
			nilOop = nilObject();
			if (nilOop == argClass) {
				
				switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
				case FFIFlagAtomic:
					/* begin ffiPassAtomicArgumentByValue:Class:In: */
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check: we handle pointer to an atomic type */
						/* begin atomicTypeOf: */
						typeSpec3 = (calloutState->ffiArgHeader);
						atomicType3 = ((usqInt)((typeSpec3 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						/* begin ffiValidateExternalData:AtomicType: */
						ptrType1 = fetchPointerofObject(1, oop);
						if (!((isPointers(ptrType1))
							 && ((slotSizeOf(ptrType1)) >= 2))) {
							goto l11;
						}
						specOop1 = fetchPointerofObject(0, ptrType1);
						if (!((isWords(specOop1))
							 && ((slotSizeOf(specOop1)) > 0))) {
							goto l11;
						}
						spec1 = fetchPointerofObject(0, specOop1);
						if (!(spec1 & FFIFlagAtomic)) {
							goto l11;
						}
						/* begin atomicTypeOf: */
						specType1 = ((usqInt)((spec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if (specType1 != atomicType3) {

							/* Allow for signed/unsigned conversion but nothing else.
							   See FFIConstants class>>#initializeTypeConstants */
							if (!((atomicType3 >= FFITypeUnsignedByte)
								 && ((atomicType3 <= FFITypeSignedChar)
								 && ((((usqInt)(atomicType3)) >> 1) == (((usqInt)(specType1)) >> 1))))) {
								goto l11;
							}
						}
	l11:	/* end ffiValidateExternalData:AtomicType: */;
						if (failed()) {
							err = null;
							goto l33;
						}
						handle3 = fetchPointerofObject(0, oop);
						ptrClass1 = fetchClassOf(handle3);
						if (ptrClass1 == (classExternalAddress())) {

							/* Don't you dare to pass pointers into object memory */
							pointer5 = fetchPointerofObject(0, handle3);
							if (isInMemory(pointer5)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
						}
						else {
							if (ptrClass1 == (classByteArray())) {
								pointer5 = ((void *) (firstIndexableField(handle3)));
							}
							else {
								err = FFIErrorBadArg;
								goto l33;
							}
						}
						switch (atomicType3) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushDereferenceUnsignedIntin(pointer5, calloutState);
							break;
						case 2:
							err = ffiPushDereferenceUnsignedBytein(pointer5, calloutState);
							break;
						case 3:
							err = ffiPushDereferenceSignedBytein(pointer5, calloutState);
							break;
						case 4:
							err = ffiPushDereferenceUnsignedShortin(pointer5, calloutState);
							break;
						case 5:
							err = ffiPushDereferenceSignedShortin(pointer5, calloutState);
							break;
						case 7:
							err = ffiPushDereferenceSignedIntin(pointer5, calloutState);
							break;
						case 8:
							err = ffiPushDereferenceUnsignedLongLongin(pointer5, calloutState);
							break;
						case 9:
							err = ffiPushDereferenceSignedLongLongin(pointer5, calloutState);
							break;
						case 10:
							err = ffiPushDereferenceUnsignedCharin(pointer5, calloutState);
							break;
						case 11:
							err = ffiPushDereferenceSignedCharin(pointer5, calloutState);
							break;
						case 12:
							err = ffiPushDereferenceSingleFloatin(pointer5, calloutState);
							break;
						case 13:
							err = ffiPushDereferenceDoubleFloatin(pointer5, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

						/* We do not have any type specification easily available.
						   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
						handle3 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec12 = (calloutState->ffiArgHeader);
						atomicType12 = ((usqInt)((typeSpec12 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType12 < 0)
						 || (atomicType12 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType12 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType12)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue = handle3;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle3 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle3)) {
										intValue = integerValueOf(handle3);
										goto l29;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle3)) {

										/* Immediate in Spur */
										intValue = characterValueOf(handle3);
										goto l29;
									}
									if (isFloatObject(handle3)) {

										/* Immediate in 64-bit Spur */
										intValue = floatValueOf(handle3);
										goto l29;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle3)) {
										intValue = characterValueOf(handle3);
										goto l29;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle3)) {
										intValue = floatValueOf(handle3);
										goto l29;
									}
									if (handle3 == (nilObject())) {
										intValue = 0;
										goto l29;
									}
									if (handle3 == (falseObject())) {
										intValue = 0;
										goto l29;
									}
									if (handle3 == (trueObject())) {
										intValue = 1;
										goto l29;
									}
									if (isLargePositiveIntegerObject(handle3)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue = positive64BitValueOf(handle3);
										goto l29;
#                    else /* BytesPerWord == 8 */
										intValue = positive32BitValueOf(handle3);
										goto l29;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue = signedMachineIntegerValueOf(handle3);
	l29:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType12) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle3)) {
							floatValue = floatValueOf(handle3);
							goto l32;
						}
						floatValue = ((double) (ffiIntegerValueOf(handle3)) );
	l32:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType12 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					/* begin ffiArgByValue:in: */
					typeSpec2 = (calloutState->ffiArgHeader);
					atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType2 < 0)
					 || (atomicType2 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType2 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue1 = oop;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (oop & (BytesPerWord - 1)) {
								if (isIntegerObject(oop)) {
									intValue1 = integerValueOf(oop);
									goto l30;
								}
								
#                if SPURVM
								if (isCharacterObject(oop)) {

									/* Immediate in Spur */
									intValue1 = characterValueOf(oop);
									goto l30;
								}
								if (isFloatObject(oop)) {

									/* Immediate in 64-bit Spur */
									intValue1 = floatValueOf(oop);
									goto l30;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(oop)) {
									intValue1 = characterValueOf(oop);
									goto l30;
								}
#                endif /* SPURVM */
								if (isFloatObject(oop)) {
									intValue1 = floatValueOf(oop);
									goto l30;
								}
								if (oop == (nilObject())) {
									intValue1 = 0;
									goto l30;
								}
								if (oop == (falseObject())) {
									intValue1 = 0;
									goto l30;
								}
								if (oop == (trueObject())) {
									intValue1 = 1;
									goto l30;
								}
								if (isLargePositiveIntegerObject(oop)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue1 = positive64BitValueOf(oop);
									goto l30;
#                  else /* BytesPerWord == 8 */
									intValue1 = positive32BitValueOf(oop);
									goto l30;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue1 = signedMachineIntegerValueOf(oop);
	l30:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType2) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue1, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue1, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue1, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue1, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue1, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue1, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue1, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue1, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue1, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue1, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(oop)) {
						floatValue1 = floatValueOf(oop);
						goto l23;
					}
					floatValue1 = ((double) (ffiIntegerValueOf(oop)) );
	l23:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType2 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
					break;
				case FFIFlagAtomic + FFIFlagPointer:
					/* begin ffiPassAtomicArgumentByReference:Class:In: */
					typeSpec5 = (calloutState->ffiArgHeader);
					atomicType5 = ((usqInt)((typeSpec5 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Check: we handle pointer to an atomic type */
						/* no type checks for void pointers */
						if (atomicType5 != FFITypeVoid) {
							/* begin ffiValidateExternalData:AtomicType: */
							ptrType = fetchPointerofObject(1, oop);
							if (!((isPointers(ptrType))
								 && ((slotSizeOf(ptrType)) >= 2))) {
								goto l27;
							}
							specOop = fetchPointerofObject(0, ptrType);
							if (!((isWords(specOop))
								 && ((slotSizeOf(specOop)) > 0))) {
								goto l27;
							}
							spec = fetchPointerofObject(0, specOop);
							if (!(spec & FFIFlagAtomic)) {
								goto l27;
							}
							/* begin atomicTypeOf: */
							specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
							if (specType != atomicType5) {

								/* Allow for signed/unsigned conversion but nothing else.
								   See FFIConstants class>>#initializeTypeConstants */
								if (!((atomicType5 >= FFITypeUnsignedByte)
									 && ((atomicType5 <= FFITypeSignedChar)
									 && ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(specType)) >> 1))))) {
									goto l27;
								}
							}
	l27:	/* end ffiValidateExternalData:AtomicType: */;
						}
						if (failed()) {
							err = null;
							goto l33;
						}
						handle = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

						/* note: the only types allowed for passing into char* types are
						   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
						   (e.g., CompiledMethod, LargeInteger). We only check for strings
						   here and fall through to the byte* check otherwise. */
						if (includesBehaviorThatOf(oopClass, classString())) {
							/* begin ffiPushString:OfLength:in: */
							pointer7 = ((char *) (firstIndexableField(oop)));
							length = byteSizeOf(oop);
							if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
								err = -PrimErrBadNumArgs;
								goto l33;
							}
							copy = malloc(length + 1);
							if (copy == null) {
								err = -PrimErrNoCMemory;
								goto l33;
							}
							memcpy(copy, pointer7, length);
							copy[length] = 0;
							((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
							(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), copy);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						atomicType5 = FFITypeUnsignedByte;
					}
					ptrClass = fetchClassOf(oop);
					if (ptrClass == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
						if (isInMemory(ptrAddress)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if (includesBehaviorThatOf(ptrClass, classAlien())) {
						
#            if COGMTVM
						if ((((calloutState->callFlags)) & FFICallFlagThreaded)
						 && (((assert(isAlien(oop)),
						(longAt(oop + BaseHeaderSize)) > 0))
						 && (isYoung(oop)))) {
							err = -PrimErrObjectMayMove;
							goto l33;
						}
#            endif /* COGMTVM */
						ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
							? (oop + BaseHeaderSize) + BytesPerOop
							: longAt((oop + BaseHeaderSize) + BytesPerOop));
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					
#          if COGMTVM

					/* Since all the following pass the address of the first indexable field we need to fail
					   the call if it is threaded and the object is young, since it may move during the call. */
					if ((((calloutState->callFlags)) & FFICallFlagThreaded)
					 && (isYoung(oop))) {
						err = -PrimErrObjectMayMove;
						goto l33;
					}
#          endif /* COGMTVM */
					if ((ptrClass == (classByteArray()))
					 && ((atomicType5 == FFITypeVoid)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
						/* begin ffiPushPointer:in: */
						pointer1 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer1);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isShorts(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
						/* begin ffiPushPointer:in: */
						pointer2 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer2);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isWords(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((atomicType5 == FFITypeSingleFloat)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
						/* begin ffiPushPointer:in: */
						pointer3 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer3);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isLong64s(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((atomicType5 == FFITypeDoubleFloat)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
						/* begin ffiPushPointer:in: */
						pointer4 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer4);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				default:
					err = FFIErrorWrongType;
					goto l33;

				}
			}
			else {

				/* If specified, the required class of the argument shall be subclass of ExternalStructure */
				if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
					err = FFIErrorWrongType;
					goto l33;
				}
				
				switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
				case FFIFlagAtomic:
					/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
						handle4 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec11 = (calloutState->ffiArgHeader);
						atomicType11 = ((usqInt)((typeSpec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType11 < 0)
						 || (atomicType11 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType11 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType11)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue3 = handle4;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle4 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle4)) {
										intValue3 = integerValueOf(handle4);
										goto l14;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle4)) {

										/* Immediate in Spur */
										intValue3 = characterValueOf(handle4);
										goto l14;
									}
									if (isFloatObject(handle4)) {

										/* Immediate in 64-bit Spur */
										intValue3 = floatValueOf(handle4);
										goto l14;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle4)) {
										intValue3 = characterValueOf(handle4);
										goto l14;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle4)) {
										intValue3 = floatValueOf(handle4);
										goto l14;
									}
									if (handle4 == (nilObject())) {
										intValue3 = 0;
										goto l14;
									}
									if (handle4 == (falseObject())) {
										intValue3 = 0;
										goto l14;
									}
									if (handle4 == (trueObject())) {
										intValue3 = 1;
										goto l14;
									}
									if (isLargePositiveIntegerObject(handle4)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue3 = positive64BitValueOf(handle4);
										goto l14;
#                    else /* BytesPerWord == 8 */
										intValue3 = positive32BitValueOf(handle4);
										goto l14;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue3 = signedMachineIntegerValueOf(handle4);
	l14:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType11) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue3, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue3, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue3, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue3, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue3, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue3, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue3, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue3, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue3, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue3, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle4)) {
							floatValue3 = floatValueOf(handle4);
							goto l17;
						}
						floatValue3 = ((double) (ffiIntegerValueOf(handle4)) );
	l17:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType11 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue3;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue3;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue3);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue3;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue3);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type2 = fetchPointerofObject(1, oop);
						if (!((isPointers(type2))
							 && ((slotSizeOf(type2)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass2 = fetchPointerofObject(1, type2);
						if (!(includesBehaviorThatOf(referentClass2, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle4 = fetchPointerofObject(0, oop);
						ptrClass2 = fetchClassOf(handle4);
						if (ptrClass2 == (classExternalAddress())) {

							/* Don't you dare to pass pointers into object memory */
							pointer6 = fetchPointerofObject(0, handle4);
							if (isInMemory(pointer6)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
						}
						else {
							if (ptrClass2 == (classByteArray())) {
								pointer6 = ((void *) (firstIndexableField(handle4)));
							}
							else {
								err = FFIErrorBadArg;
								goto l33;
							}
						}
						/* begin atomicTypeOf: */
						typeSpec4 = (calloutState->ffiArgHeader);
						atomicType4 = ((usqInt)((typeSpec4 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						switch (atomicType4) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushDereferenceUnsignedIntin(pointer6, calloutState);
							break;
						case 2:
							err = ffiPushDereferenceUnsignedBytein(pointer6, calloutState);
							break;
						case 3:
							err = ffiPushDereferenceSignedBytein(pointer6, calloutState);
							break;
						case 4:
							err = ffiPushDereferenceUnsignedShortin(pointer6, calloutState);
							break;
						case 5:
							err = ffiPushDereferenceSignedShortin(pointer6, calloutState);
							break;
						case 7:
							err = ffiPushDereferenceSignedIntin(pointer6, calloutState);
							break;
						case 8:
							err = ffiPushDereferenceUnsignedLongLongin(pointer6, calloutState);
							break;
						case 9:
							err = ffiPushDereferenceSignedLongLongin(pointer6, calloutState);
							break;
						case 10:
							err = ffiPushDereferenceUnsignedCharin(pointer6, calloutState);
							break;
						case 11:
							err = ffiPushDereferenceSignedCharin(pointer6, calloutState);
							break;
						case 12:
							err = ffiPushDereferenceSingleFloatin(pointer6, calloutState);
							break;
						case 13:
							err = ffiPushDereferenceDoubleFloatin(pointer6, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

						/* We do not have any type specification easily available.
						   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
						handle4 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec21 = (calloutState->ffiArgHeader);
						atomicType21 = ((usqInt)((typeSpec21 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType21 < 0)
						 || (atomicType21 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType21 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType21)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue11 = handle4;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle4 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle4)) {
										intValue11 = integerValueOf(handle4);
										goto l13;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle4)) {

										/* Immediate in Spur */
										intValue11 = characterValueOf(handle4);
										goto l13;
									}
									if (isFloatObject(handle4)) {

										/* Immediate in 64-bit Spur */
										intValue11 = floatValueOf(handle4);
										goto l13;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle4)) {
										intValue11 = characterValueOf(handle4);
										goto l13;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle4)) {
										intValue11 = floatValueOf(handle4);
										goto l13;
									}
									if (handle4 == (nilObject())) {
										intValue11 = 0;
										goto l13;
									}
									if (handle4 == (falseObject())) {
										intValue11 = 0;
										goto l13;
									}
									if (handle4 == (trueObject())) {
										intValue11 = 1;
										goto l13;
									}
									if (isLargePositiveIntegerObject(handle4)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue11 = positive64BitValueOf(handle4);
										goto l13;
#                    else /* BytesPerWord == 8 */
										intValue11 = positive32BitValueOf(handle4);
										goto l13;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue11 = signedMachineIntegerValueOf(handle4);
	l13:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType21) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue11, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue11, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue11, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue11, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue11, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue11, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue11, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue11, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue11, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue11, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle4)) {
							floatValue11 = floatValueOf(handle4);
							goto l15;
						}
						floatValue11 = ((double) (ffiIntegerValueOf(handle4)) );
	l15:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType21 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue11;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue11;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue11);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue11;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue11);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					if (!0) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					/* begin ffiArgByValue:in: */
					typeSpec31 = (calloutState->ffiArgHeader);
					atomicType31 = ((usqInt)((typeSpec31 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType31 < 0)
					 || (atomicType31 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType31 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType31)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue2 = oop;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (oop & (BytesPerWord - 1)) {
								if (isIntegerObject(oop)) {
									intValue2 = integerValueOf(oop);
									goto l18;
								}
								
#                if SPURVM
								if (isCharacterObject(oop)) {

									/* Immediate in Spur */
									intValue2 = characterValueOf(oop);
									goto l18;
								}
								if (isFloatObject(oop)) {

									/* Immediate in 64-bit Spur */
									intValue2 = floatValueOf(oop);
									goto l18;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(oop)) {
									intValue2 = characterValueOf(oop);
									goto l18;
								}
#                endif /* SPURVM */
								if (isFloatObject(oop)) {
									intValue2 = floatValueOf(oop);
									goto l18;
								}
								if (oop == (nilObject())) {
									intValue2 = 0;
									goto l18;
								}
								if (oop == (falseObject())) {
									intValue2 = 0;
									goto l18;
								}
								if (oop == (trueObject())) {
									intValue2 = 1;
									goto l18;
								}
								if (isLargePositiveIntegerObject(oop)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue2 = positive64BitValueOf(oop);
									goto l18;
#                  else /* BytesPerWord == 8 */
									intValue2 = positive32BitValueOf(oop);
									goto l18;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue2 = signedMachineIntegerValueOf(oop);
	l18:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType31) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue2, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue2, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue2, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue2, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue2, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue2, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue2, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue2, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue2, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue2, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(oop)) {
						floatValue2 = floatValueOf(oop);
						goto l16;
					}
					floatValue2 = ((double) (ffiIntegerValueOf(oop)) );
	l16:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType31 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue2;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue2;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue2);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue2;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue2);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
					break;
				case FFIFlagAtomic + FFIFlagPointer:
					/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type = fetchPointerofObject(1, oop);
						if (!((isPointers(type))
							 && ((slotSizeOf(type)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass = fetchPointerofObject(1, type);
						if (!(includesBehaviorThatOf(referentClass, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle1 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle1, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				case FFIFlagStructure:
					/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
						handle5 = fetchPointerofObject(0, oop);
						/* begin ffiPushStructureContentsOf:in: */
						ptrClass3 = fetchClassOf(handle5);
						if (ptrClass3 == (classExternalAddress())) {

							/* ExternalAddress is bytes */

							/* There is no way we can make sure the structure is valid.
							   But we can at least check for attempts to pass pointers to ST memory. */
							ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress2)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec3 = (calloutState->ffiArgSpec);
							argSpecSize = (calloutState->ffiArgSpecSize);
							availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize = structSize;
							if (availableRegisterSpace > 0) {
								if (structSize <= availableRegisterSpace) {

									/* all in registers */
									stackPartSize = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize = structSize - availableRegisterSpace;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace);
									}
									else {
										availableRegisterSpace = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize > 0) {
								roundedSize = (((stackPartSize + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace])), stackPartSize);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
							}
							err = 0;
							goto l33;
						}
						if (ptrClass3 == (classByteArray())) {

							/* The following is a somewhat pessimistic test but I like being sure... */
							if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress2 = firstIndexableField(handle5);
							if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

								/* Since this involves passing the address of the first indexable field we need to fail
								   the call if it is threaded and the object is young, since it may move during the call. */
								
#                if COGMTVM
								if ((((calloutState->callFlags)) & FFICallFlagThreaded)
								 && (isYoung(handle5))) {
									err = -PrimErrObjectMayMove;
									goto l33;
								}
#                endif /* COGMTVM */
								/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
								structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
								argSpec1 = (calloutState->ffiArgSpec);
								argSpecSize1 = (calloutState->ffiArgSpecSize);
								availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
								stackPartSize1 = structSize1;
								if (availableRegisterSpace1 > 0) {
									if (structSize1 <= availableRegisterSpace1) {

										/* all in registers */
										stackPartSize1 = 0;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize1);
										(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
									}
									else {

										/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
										   Otherwise push entire struct on stack. */
										if (((calloutState->currentArg)) == ((calloutState->argVector))) {
											stackPartSize1 = structSize1 - availableRegisterSpace1;
											memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace1);
										}
										else {
											availableRegisterSpace1 = 0;
										}
										(calloutState->integerRegisterIndex = NumIntRegArgs);
									}
								}
								if (stackPartSize1 > 0) {
									roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
									if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
										err = FFIErrorCallFrameTooBig;
										goto l33;
									}
									memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace1])), stackPartSize1);
									(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
								}
								err = 0;
								goto l33;
							}
							if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress2)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress2));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), ptrAddress2);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						err = FFIErrorBadArg;
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type3 = fetchPointerofObject(1, oop);
						if (!((isPointers(type3))
							 && ((slotSizeOf(type3)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass3 = fetchPointerofObject(1, type3);
						if (!(includesBehaviorThatOf(referentClass3, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle5 = fetchPointerofObject(0, oop);
						/* begin ffiPushStructureContentsOf:in: */
						ptrClass11 = fetchClassOf(handle5);
						if (ptrClass11 == (classExternalAddress())) {

							/* ExternalAddress is bytes */

							/* There is no way we can make sure the structure is valid.
							   But we can at least check for attempts to pass pointers to ST memory. */
							ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress1)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize2 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec2 = (calloutState->ffiArgSpec);
							argSpecSize2 = (calloutState->ffiArgSpecSize);
							availableRegisterSpace2 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize2 = structSize2;
							if (availableRegisterSpace2 > 0) {
								if (structSize2 <= availableRegisterSpace2) {

									/* all in registers */
									stackPartSize2 = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize2);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize2 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize2 = structSize2 - availableRegisterSpace2;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace2);
									}
									else {
										availableRegisterSpace2 = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize2 > 0) {
								roundedSize2 = (((stackPartSize2 + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize2) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace2])), stackPartSize2);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize2);
							}
							err = 0;
							goto l33;
						}
						if (ptrClass11 == (classByteArray())) {

							/* The following is a somewhat pessimistic test but I like being sure... */
							if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress1 = firstIndexableField(handle5);
							if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

								/* Since this involves passing the address of the first indexable field we need to fail
								   the call if it is threaded and the object is young, since it may move during the call. */
								
#                if COGMTVM
								if ((((calloutState->callFlags)) & FFICallFlagThreaded)
								 && (isYoung(handle5))) {
									err = -PrimErrObjectMayMove;
									goto l33;
								}
#                endif /* COGMTVM */
								/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
								structSize11 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
								argSpec11 = (calloutState->ffiArgSpec);
								argSpecSize11 = (calloutState->ffiArgSpecSize);
								availableRegisterSpace11 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
								stackPartSize11 = structSize11;
								if (availableRegisterSpace11 > 0) {
									if (structSize11 <= availableRegisterSpace11) {

										/* all in registers */
										stackPartSize11 = 0;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize11);
										(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize11 + 3))) >> 2)));
									}
									else {

										/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
										   Otherwise push entire struct on stack. */
										if (((calloutState->currentArg)) == ((calloutState->argVector))) {
											stackPartSize11 = structSize11 - availableRegisterSpace11;
											memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace11);
										}
										else {
											availableRegisterSpace11 = 0;
										}
										(calloutState->integerRegisterIndex = NumIntRegArgs);
									}
								}
								if (stackPartSize11 > 0) {
									roundedSize11 = (((stackPartSize11 + 3) | 3) - 3);
									if ((((calloutState->currentArg)) + roundedSize11) > ((calloutState->limit))) {
										err = FFIErrorCallFrameTooBig;
										goto l33;
									}
									memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace11])), stackPartSize11);
									(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize11);
								}
								err = 0;
								goto l33;
							}
							if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress1)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress1));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), ptrAddress1);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						err = FFIErrorBadArg;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				case FFIFlagStructure + FFIFlagPointer:
					/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
						handle2 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle2, calloutState);
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type1 = fetchPointerofObject(1, oop);
						if (!((isPointers(type1))
							 && ((slotSizeOf(type1)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass1 = fetchPointerofObject(1, type1);
						if (!(includesBehaviorThatOf(referentClass1, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle2 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle2, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				default:
					err = FFIErrorWrongType;
					goto l33;

				}
			}
	l33:	/* end ffiArgument:Spec:Class:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l34;
				}
#        endif /* COGMTVM */
				result = ffiFail(err);
				goto l34;
			}
		}
		assert(!(failed()));
		/* begin ffiLogCallout: */
		if (ffiLogEnabled) {
			functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction);
			if (!(isBytes(functionName))) {
				goto l3;
			}
			ffiLogCallOfLength(firstIndexableField(functionName), byteSizeOf(functionName));
		}
	l3:	/* end ffiLogCallout: */;
		if ((requiredStackSize < 0)
		 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
			stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
		}
		/* begin ffiCalloutTo:SpecOnStack:in: */
		myThreadIndex = disownVM(
#    if COGMTVM
			(((calloutState->callFlags)) & FFICallFlagThreaded
						? DisownVMForFFICall + DisownVMForThreading
						: DisownVMForFFICall)
#    else /* COGMTVM */
			DisownVMForFFICall
#    endif /* COGMTVM */
			);
		if (((calloutState->floatRegisterIndex)) > 0) {
			loadFloatRegs((((double *) ((&(((calloutState->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState->floatRegisters))[14])))))[0]);
		}
		if ((allocaLiesSoSetSpBeforeCall())
		 || (mustAlignStack())) {
			setsp((calloutState->argVector));
		}
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
			if (atomicType == FFITypeSingleFloat) {
				floatRet = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
			}
			else {

				/* atomicType = FFITypeDoubleFloat */
				floatRet = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
			}
			if (isCalleePopsConvention((calloutState->callFlags))) {
				setsp((calloutState->argVector));
			}
			ownVM(myThreadIndex);
			result1 = floatObjectOf(floatRet);
			goto l9;
		}

		/* undo any callee argument pops because it may confuse stack management with the alloca. */
		intRet = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(myThreadIndex);
		if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

			/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
			   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
			if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
				/* begin ffiReturnPointer:ofType:in: */
				specLiteral = (null != null
					? stackValue(1)
					: literalofMethod(0, primitiveMethod()));
				argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
				retType = fetchPointerofObject(0, argTypes);
				retClass2 = fetchPointerofObject(1, retType);
				if (retClass2 == (nilObject())) {

					/* Create ExternalData upon return */
					/* begin atomicTypeOf: */
					typeSpec1 = (calloutState->ffiRetHeader);
					atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

						/* String return */
						/* begin ffiReturnCStringFrom: */
						cPointer = ((usqInt) intRet);
						if (!(cPointer)) {
							retOop = nilObject();
							goto l5;
						}
						cString = ((char *) cPointer);
						strLen = 0;
						while (!((cString[strLen]) == 0)) {
							strLen += 1;
						}
						strOop = instantiateClassindexableSize(classString(), strLen);
						strPtr = firstIndexableField(strOop);
						for (i1 = 0; i1 < strLen; i1 += 1) {
							strPtr[i1] = (cString[i1]);
						}
						retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
						result1 = retOop;
						goto l9;
					}
				}
				
#if SPURVM
				oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop2);
				ptr1[0] = (((sqInt) intRet));
				retOop = instantiateClassindexableSize(classExternalData(), 0);
				storePointerofObjectwithValue(0, retOop, oop2);

#else /* SPURVM */
				pushRemappableOop(retType);
				oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop2);
				ptr1[0] = (((sqInt) intRet));
								pushRemappableOop(oop2);
				retOop = instantiateClassindexableSize(classExternalData(), 0);
				oop2 = popRemappableOop();
				storePointerofObjectwithValue(0, retOop, oop2);
				retType = popRemappableOop()
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop, retType);
				result1 = retOop;
				goto l9;
			}
			/* begin ffiReturnStruct:ofType:in: */
			longLongRetPtr = (&intRet);
			/* begin ffiReturnType: */
			specLiteral1 = (null != null
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
			ffiRetType = fetchPointerofObject(0, argTypes1);
			retClass1 = fetchPointerofObject(1, ffiRetType);
			retOop1 = instantiateClassindexableSize(retClass1, 0);
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));

#else /* SPURVM */
			pushRemappableOop(retOop1);
			oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
			retOop1 = popRemappableOop()
#endif /* SPURVM */
;
			memcpy(firstIndexableField(oop1), ((calloutState->structReturnType)
				? longLongRetPtr
				: (calloutState->limit)), (calloutState->structReturnSize));
			storePointerofObjectwithValue(0, retOop1, oop1);
			result1 = retOop1;
			goto l9;
		}
		/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
		assert(atomicType < FFITypeSingleFloat);
		if (atomicType == FFITypeBool) {

			/* Make sure bool honors the byte size requested */
			byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
			value = (byteSize == (sizeof(intRet))
				? intRet
				: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
			if (value == 0) {
				result1 = falseObject();
			}
			else {
				result1 = trueObject();
			}
			goto l9;
		}
		if (atomicType <= FFITypeSignedInt) {

			/* these are all generall integer returns */
			if (atomicType <= ((BytesPerWord == 8
				? FFITypeSignedInt
				: FFITypeSignedShort))) {

				/* byte/short. first extract partial word, then sign extend */

				/* # of significant bits */
				shift = ((BytesPerWord == 8)
				 && (atomicType >= FFITypeUnsignedInt)
					? 32
					: (((usqInt)(atomicType)) >> 1) * 8);
				value = intRet & (((((unsigned long long)1)) << shift) - 1);
				if (atomicType & 1) {

					/* make the guy signed */
					mask = (((unsigned long long)1)) << (shift - 1);
					value = (value & (mask - 1)) - (value & mask);
				}
				result1 = integerObjectOf(value);
				goto l9;
			}
			if (atomicType & 1) {
				if (BytesPerWord == 8) {
					result1 = signed64BitIntegerFor(intRet);
				}
				else {
					result1 = signed32BitIntegerFor(intRet);
				}
			}
			else {
				if (BytesPerWord == 8) {
					result1 = positive64BitIntegerFor(intRet);
				}
				else {
					result1 = positive32BitIntegerFor(intRet);
				}
			}
			goto l9;
		}
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {
			if (atomicType & 1) {
				result1 = signed64BitIntegerFor(intRet);
			}
			else {
				result1 = positive64BitIntegerFor(intRet);
			}
		}
		else {
			result1 = characterObjectOf(intRet & 0xFF);
		}
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
		if (!(retClass == (nilObject()))) {
			if ((((calloutState->ffiRetHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) == FFIFlagAtomic) {
				
#if SPURVM
				alias = instantiateClassindexableSize(retClass, 0);

#else /* SPURVM */
				pushRemappableOop(result1);
				alias = instantiateClassindexableSize(retClass, 0);
				result1 = popRemappableOop()
#endif /* SPURVM */
;
				storePointerofObjectwithValue(0, alias, result1);
				result1 = alias;
			}
		}
		/* begin cleanupCalloutState: */
		while (((calloutState->stringArgIndex)) > 0) {
			free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
		}
		popthenPush(primNumArgs + 1, result1);
		result = result1;
	l34:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
		if (!((result == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= (nArgs + 1)))) break;
		tenuringIncrementalGC();
	}
#  else /* COGMTVM */
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	nArgs1 = methodArgumentCount();
	primNumArgs1 = methodArgumentCount();
	if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
		ffiFail(FFIErrorNotFunction);
		goto l68;
	}
	flags1 = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (failed()) {
		ffiFail(FFIErrorBadArgs);
		goto l68;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr1 = fetchPointerofObject(0, externalFunction);
	if (!((isBytes(addressPtr1))
		 && ((byteSizeOf(addressPtr1)) == (sizeof(sqInt))))) {
		address11 = ffiFail(FFIErrorBadAddress);
		goto l67;
	}
	address11 = fetchPointerofObject(0, addressPtr1);
	l67:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		address2 = 0;
		goto l65;
	}
	if (address11 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1));
		}
		if ((slotSizeOf(externalFunction)) < 5) {
			address2 = ffiFail(FFIErrorNoModule);
			goto l65;
		}
		address11 = ffiLoadCalloutAddressFrom(externalFunction);
		if (failed()) {
			address2 = 0;
			goto l65;
		}
		ptr2 = firstIndexableField(addressPtr1);
		ptr2[0] = address11;
	}
	address2 = address11;
	l65:	/* end ffiLoadCalloutAddress: */;
	if (failed()) {
		goto l68;
	}

	/* must be array of arg types */
	argTypeArray1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((isArray(argTypeArray1))
		 && ((slotSizeOf(argTypeArray1)) == (nArgs1 + 1)))) {
		ffiFail(FFIErrorBadArgs);
		goto l68;
	}
	
#  if COGMTVM
	if (!(((flags1 & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags1 & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l68;
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags1 == FFICallTypeCDecl)
		 || (flags1 == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l68;
	}
#  endif /* COGMTVM */
	if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
		requiredStackSize1 = fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction);
	}
	else {
		requiredStackSize1 = -1;
	}
	if (failed()) {
		primitiveFailFor((null == null
			? PrimErrBadMethod
			: PrimErrBadReceiver));
		goto l68;
	}
	stackSize1 = (requiredStackSize1 < 0
		? DefaultMaxStackSize
		: requiredStackSize1);
	calloutState1 = (&theCalloutState1);
	memset(calloutState1, 0, sizeof(CalloutState));
	(calloutState1->callFlags = flags1);
	argType1 = fetchPointerofObject(0, argTypeArray1);
	argSpec4 = fetchPointerofObject(0, argType1);
	retClass3 = fetchPointerofObject(1, argType1);
	if (((err1 = ffiCheckReturnWithin(argSpec4, retClass3, calloutState1))) != 0) {
		ffiFail(err1);
		goto l68;
	}
	allocation1 = alloca((stackSize1 + ((calloutState1->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation1 = ((char *) ((((((usqIntptr_t)allocation1)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState1->argVector = allocation1);
	(calloutState1->currentArg = allocation1);
	(calloutState1->limit = allocation1 + stackSize1);
	if ((((calloutState1->structReturnSize)) > 0)
	 && (1
	 && (!((calloutState1->structReturnType))))) {
		/* begin ffiPushPointer:in: */
		pointer8 = (calloutState1->limit);
		if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer8));
			(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
				err1 = FFIErrorCallFrameTooBig;
				goto l59;
			}
			longAtput((calloutState1->currentArg), pointer8);
			(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
		}
		err1 = 0;
	l59:	/* end ffiPushPointer:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l68;
			}
#      endif /* COGMTVM */
			ffiFail(err1);
			goto l68;
		}
	}
	for (i2 = 1; i2 <= nArgs1; i2 += 1) {
		argType1 = fetchPointerofObject(i2, argTypeArray1);
		argSpec4 = fetchPointerofObject(0, argType1);
		argClass1 = fetchPointerofObject(1, argType1);
		oop3 = (null == null
			? stackValue(nArgs1 - i2)
			: fetchPointerofObject(i2 - 1, null));
		/* begin ffiArgument:Spec:Class:in: */
		if (!(isWords(argSpec4))) {
			err1 = FFIErrorWrongType;
			goto l40;
		}
		(calloutState1->ffiArgSpecSize = slotSizeOf(argSpec4));
		if (((calloutState1->ffiArgSpecSize)) == 0) {
			err1 = FFIErrorWrongType;
			goto l40;
		}
		(calloutState1->ffiArgSpec = firstIndexableField(argSpec4));
		(calloutState1->ffiArgHeader = longAt((calloutState1->ffiArgSpec)));

		/* Prefetch class (we'll need it) */
		oopClass1 = fetchClassOf(oop3);
		nilOop1 = nilObject();
		if (nilOop1 == argClass1) {
			
			switch (((calloutState1->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:In: */
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check: we handle pointer to an atomic type */
					/* begin atomicTypeOf: */
					typeSpec32 = (calloutState1->ffiArgHeader);
					atomicType32 = ((usqInt)((typeSpec32 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType11 = fetchPointerofObject(1, oop3);
					if (!((isPointers(ptrType11))
						 && ((slotSizeOf(ptrType11)) >= 2))) {
						goto l64;
					}
					specOop11 = fetchPointerofObject(0, ptrType11);
					if (!((isWords(specOop11))
						 && ((slotSizeOf(specOop11)) > 0))) {
						goto l64;
					}
					spec11 = fetchPointerofObject(0, specOop11);
					if (!(spec11 & FFIFlagAtomic)) {
						goto l64;
					}
					/* begin atomicTypeOf: */
					specType11 = ((usqInt)((spec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (specType11 != atomicType32) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType32 >= FFITypeUnsignedByte)
							 && ((atomicType32 <= FFITypeSignedChar)
							 && ((((usqInt)(atomicType32)) >> 1) == (((usqInt)(specType11)) >> 1))))) {
							goto l64;
						}
					}
	l64:	/* end ffiValidateExternalData:AtomicType: */;
					if (failed()) {
						err1 = null;
						goto l40;
					}
					handle31 = fetchPointerofObject(0, oop3);
					ptrClass12 = fetchClassOf(handle31);
					if (ptrClass12 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer51 = fetchPointerofObject(0, handle31);
						if (isInMemory(pointer51)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
					}
					else {
						if (ptrClass12 == (classByteArray())) {
							pointer51 = ((void *) (firstIndexableField(handle31)));
						}
						else {
							err1 = FFIErrorBadArg;
							goto l40;
						}
					}
					switch (atomicType32) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushDereferenceUnsignedIntin(pointer51, calloutState1);
						break;
					case 2:
						err1 = ffiPushDereferenceUnsignedBytein(pointer51, calloutState1);
						break;
					case 3:
						err1 = ffiPushDereferenceSignedBytein(pointer51, calloutState1);
						break;
					case 4:
						err1 = ffiPushDereferenceUnsignedShortin(pointer51, calloutState1);
						break;
					case 5:
						err1 = ffiPushDereferenceSignedShortin(pointer51, calloutState1);
						break;
					case 7:
						err1 = ffiPushDereferenceSignedIntin(pointer51, calloutState1);
						break;
					case 8:
						err1 = ffiPushDereferenceUnsignedLongLongin(pointer51, calloutState1);
						break;
					case 9:
						err1 = ffiPushDereferenceSignedLongLongin(pointer51, calloutState1);
						break;
					case 10:
						err1 = ffiPushDereferenceUnsignedCharin(pointer51, calloutState1);
						break;
					case 11:
						err1 = ffiPushDereferenceSignedCharin(pointer51, calloutState1);
						break;
					case 12:
						err1 = ffiPushDereferenceSingleFloatin(pointer51, calloutState1);
						break;
					case 13:
						err1 = ffiPushDereferenceDoubleFloatin(pointer51, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle31 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec121 = (calloutState1->ffiArgHeader);
					atomicType121 = ((usqInt)((typeSpec121 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType121 < 0)
					 || (atomicType121 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType121 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType121)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue4 = handle31;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle31 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle31)) {
									intValue4 = integerValueOf(handle31);
									goto l35;
								}
								
#                if SPURVM
								if (isCharacterObject(handle31)) {

									/* Immediate in Spur */
									intValue4 = characterValueOf(handle31);
									goto l35;
								}
								if (isFloatObject(handle31)) {

									/* Immediate in 64-bit Spur */
									intValue4 = floatValueOf(handle31);
									goto l35;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle31)) {
									intValue4 = characterValueOf(handle31);
									goto l35;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle31)) {
									intValue4 = floatValueOf(handle31);
									goto l35;
								}
								if (handle31 == (nilObject())) {
									intValue4 = 0;
									goto l35;
								}
								if (handle31 == (falseObject())) {
									intValue4 = 0;
									goto l35;
								}
								if (handle31 == (trueObject())) {
									intValue4 = 1;
									goto l35;
								}
								if (isLargePositiveIntegerObject(handle31)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue4 = positive64BitValueOf(handle31);
									goto l35;
#                  else /* BytesPerWord == 8 */
									intValue4 = positive32BitValueOf(handle31);
									goto l35;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue4 = signedMachineIntegerValueOf(handle31);
	l35:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType121) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue4, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue4, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue4, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue4, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue4, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue4, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue4, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue4, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue4, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue4, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle31)) {
						floatValue4 = floatValueOf(handle31);
						goto l44;
					}
					floatValue4 = ((double) (ffiIntegerValueOf(handle31)) );
	l44:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType121 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue4;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue4;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue4);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue4;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue4);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				/* begin ffiArgByValue:in: */
				typeSpec22 = (calloutState1->ffiArgHeader);
				atomicType22 = ((usqInt)((typeSpec22 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType22 < 0)
				 || (atomicType22 > FFITypeDoubleFloat)) {
					err1 = FFIErrorBadAtomicType;
					goto l40;
				}
				if (atomicType22 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType22)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue12 = oop3;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop3 & (BytesPerWord - 1)) {
							if (isIntegerObject(oop3)) {
								intValue12 = integerValueOf(oop3);
								goto l51;
							}
							
#              if SPURVM
							if (isCharacterObject(oop3)) {

								/* Immediate in Spur */
								intValue12 = characterValueOf(oop3);
								goto l51;
							}
							if (isFloatObject(oop3)) {

								/* Immediate in 64-bit Spur */
								intValue12 = floatValueOf(oop3);
								goto l51;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop3)) {
								intValue12 = characterValueOf(oop3);
								goto l51;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop3)) {
								intValue12 = floatValueOf(oop3);
								goto l51;
							}
							if (oop3 == (nilObject())) {
								intValue12 = 0;
								goto l51;
							}
							if (oop3 == (falseObject())) {
								intValue12 = 0;
								goto l51;
							}
							if (oop3 == (trueObject())) {
								intValue12 = 1;
								goto l51;
							}
							if (isLargePositiveIntegerObject(oop3)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue12 = positive64BitValueOf(oop3);
								goto l51;
#                else /* BytesPerWord == 8 */
								intValue12 = positive32BitValueOf(oop3);
								goto l51;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue12 = signedMachineIntegerValueOf(oop3);
	l51:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					switch (atomicType22) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushUnsignedIntin(intValue12, calloutState1);
						break;
					case 2:
						err1 = ffiPushUnsignedBytein(intValue12, calloutState1);
						break;
					case 3:
						err1 = ffiPushSignedBytein(intValue12, calloutState1);
						break;
					case 4:
						err1 = ffiPushUnsignedShortin(intValue12, calloutState1);
						break;
					case 5:
						err1 = ffiPushSignedShortin(intValue12, calloutState1);
						break;
					case 7:
						err1 = ffiPushSignedIntin(intValue12, calloutState1);
						break;
					case 8:
						err1 = ffiPushUnsignedLongLongOopin(intValue12, calloutState1);
						break;
					case 9:
						err1 = ffiPushSignedLongLongOopin(intValue12, calloutState1);
						break;
					case 10:
						err1 = ffiPushUnsignedCharin(intValue12, calloutState1);
						break;
					case 11:
						err1 = ffiPushSignedCharin(intValue12, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop3)) {
					floatValue12 = floatValueOf(oop3);
					goto l54;
				}
				floatValue12 = ((double) (ffiIntegerValueOf(oop3)) );
	l54:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				if (atomicType22 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
							((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue12;
							(calloutState1->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue12;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue12);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
							(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue12;
						(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						(calloutState1->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState1->currentArg), floatValue12);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
					}
					err1 = 0;
					goto l40;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:In: */
				typeSpec51 = (calloutState1->ffiArgHeader);
				atomicType51 = ((usqInt)((typeSpec51 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Check: we handle pointer to an atomic type */
					/* no type checks for void pointers */
					if (atomicType51 != FFITypeVoid) {
						/* begin ffiValidateExternalData:AtomicType: */
						ptrType2 = fetchPointerofObject(1, oop3);
						if (!((isPointers(ptrType2))
							 && ((slotSizeOf(ptrType2)) >= 2))) {
							goto l38;
						}
						specOop2 = fetchPointerofObject(0, ptrType2);
						if (!((isWords(specOop2))
							 && ((slotSizeOf(specOop2)) > 0))) {
							goto l38;
						}
						spec2 = fetchPointerofObject(0, specOop2);
						if (!(spec2 & FFIFlagAtomic)) {
							goto l38;
						}
						/* begin atomicTypeOf: */
						specType2 = ((usqInt)((spec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if (specType2 != atomicType51) {

							/* Allow for signed/unsigned conversion but nothing else.
							   See FFIConstants class>>#initializeTypeConstants */
							if (!((atomicType51 >= FFITypeUnsignedByte)
								 && ((atomicType51 <= FFITypeSignedChar)
								 && ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(specType2)) >> 1))))) {
								goto l38;
							}
						}
	l38:	/* end ffiValidateExternalData:AtomicType: */;
					}
					if (failed()) {
						err1 = null;
						goto l40;
					}
					handle6 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle6, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* note: the only types allowed for passing into char* types are
					   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
					   (e.g., CompiledMethod, LargeInteger). We only check for strings
					   here and fall through to the byte* check otherwise. */
					if (includesBehaviorThatOf(oopClass1, classString())) {
						/* begin ffiPushString:OfLength:in: */
						pointer71 = ((char *) (firstIndexableField(oop3)));
						length1 = byteSizeOf(oop3);
						if (((calloutState1->stringArgIndex)) >= MaxNumArgs) {
							err1 = -PrimErrBadNumArgs;
							goto l40;
						}
						copy1 = malloc(length1 + 1);
						if (copy1 == null) {
							err1 = -PrimErrNoCMemory;
							goto l40;
						}
						memcpy(copy1, pointer71, length1);
						copy1[length1] = 0;
						((calloutState1->stringArgs))[(calloutState1->stringArgIndex)] = copy1;
						(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) + 1);
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)copy1));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), copy1);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					atomicType51 = FFITypeUnsignedByte;
				}
				ptrClass4 = fetchClassOf(oop3);
				if (ptrClass4 == (classExternalAddress())) {

					/* Don't you dare to pass pointers into object memory */
					ptrAddress3 = ((void *)(fetchPointerofObject(0, oop3)));
					if (isInMemory(ptrAddress3)) {
						err1 = FFIErrorInvalidPointer;
						goto l40;
					}
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress3));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), ptrAddress3);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if (includesBehaviorThatOf(ptrClass4, classAlien())) {
					
#          if COGMTVM
					if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
					 && (((assert(isAlien(oop3)),
					(longAt(oop3 + BaseHeaderSize)) > 0))
					 && (isYoung(oop3)))) {
						err1 = -PrimErrObjectMayMove;
						goto l40;
					}
#          endif /* COGMTVM */
					ptrAddress3 = ((longAt(oop3 + BaseHeaderSize)) > 0
						? (oop3 + BaseHeaderSize) + BytesPerOop
						: longAt((oop3 + BaseHeaderSize) + BytesPerOop));
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress3));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), ptrAddress3);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				
#        if COGMTVM

				/* Since all the following pass the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(oop3))) {
					err1 = -PrimErrObjectMayMove;
					goto l40;
				}
#        endif /* COGMTVM */
				if ((ptrClass4 == (classByteArray()))
				 && ((atomicType51 == FFITypeVoid)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer11 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer11));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer11);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isShorts(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer21 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer21));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isWords(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((atomicType51 == FFITypeSingleFloat)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer31 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer31));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer31);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isLong64s(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((atomicType51 == FFITypeDoubleFloat)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer41 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer41));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer41);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			default:
				err1 = FFIErrorWrongType;
				goto l40;

			}
		}
		else {

			/* If specified, the required class of the argument shall be subclass of ExternalStructure */
			if (!(includesBehaviorThatOf(argClass1, classExternalStructure()))) {
				err1 = FFIErrorWrongType;
				goto l40;
			}
			
			switch (((calloutState1->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle41 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec111 = (calloutState1->ffiArgHeader);
					atomicType111 = ((usqInt)((typeSpec111 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType111 < 0)
					 || (atomicType111 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType111 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType111)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue31 = handle41;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle41 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle41)) {
									intValue31 = integerValueOf(handle41);
									goto l55;
								}
								
#                if SPURVM
								if (isCharacterObject(handle41)) {

									/* Immediate in Spur */
									intValue31 = characterValueOf(handle41);
									goto l55;
								}
								if (isFloatObject(handle41)) {

									/* Immediate in 64-bit Spur */
									intValue31 = floatValueOf(handle41);
									goto l55;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle41)) {
									intValue31 = characterValueOf(handle41);
									goto l55;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle41)) {
									intValue31 = floatValueOf(handle41);
									goto l55;
								}
								if (handle41 == (nilObject())) {
									intValue31 = 0;
									goto l55;
								}
								if (handle41 == (falseObject())) {
									intValue31 = 0;
									goto l55;
								}
								if (handle41 == (trueObject())) {
									intValue31 = 1;
									goto l55;
								}
								if (isLargePositiveIntegerObject(handle41)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue31 = positive64BitValueOf(handle41);
									goto l55;
#                  else /* BytesPerWord == 8 */
									intValue31 = positive32BitValueOf(handle41);
									goto l55;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue31 = signedMachineIntegerValueOf(handle41);
	l55:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType111) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue31, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue31, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue31, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue31, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue31, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue31, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue31, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue31, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue31, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue31, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle41)) {
						floatValue31 = floatValueOf(handle41);
						goto l43;
					}
					floatValue31 = ((double) (ffiIntegerValueOf(handle41)) );
	l43:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType111 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue31;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue31;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue31);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue31;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue31);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type21 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type21))
						 && ((slotSizeOf(type21)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass21 = fetchPointerofObject(1, type21);
					if (!(includesBehaviorThatOf(referentClass21, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle41 = fetchPointerofObject(0, oop3);
					ptrClass21 = fetchClassOf(handle41);
					if (ptrClass21 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer61 = fetchPointerofObject(0, handle41);
						if (isInMemory(pointer61)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
					}
					else {
						if (ptrClass21 == (classByteArray())) {
							pointer61 = ((void *) (firstIndexableField(handle41)));
						}
						else {
							err1 = FFIErrorBadArg;
							goto l40;
						}
					}
					/* begin atomicTypeOf: */
					typeSpec41 = (calloutState1->ffiArgHeader);
					atomicType41 = ((usqInt)((typeSpec41 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					switch (atomicType41) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushDereferenceUnsignedIntin(pointer61, calloutState1);
						break;
					case 2:
						err1 = ffiPushDereferenceUnsignedBytein(pointer61, calloutState1);
						break;
					case 3:
						err1 = ffiPushDereferenceSignedBytein(pointer61, calloutState1);
						break;
					case 4:
						err1 = ffiPushDereferenceUnsignedShortin(pointer61, calloutState1);
						break;
					case 5:
						err1 = ffiPushDereferenceSignedShortin(pointer61, calloutState1);
						break;
					case 7:
						err1 = ffiPushDereferenceSignedIntin(pointer61, calloutState1);
						break;
					case 8:
						err1 = ffiPushDereferenceUnsignedLongLongin(pointer61, calloutState1);
						break;
					case 9:
						err1 = ffiPushDereferenceSignedLongLongin(pointer61, calloutState1);
						break;
					case 10:
						err1 = ffiPushDereferenceUnsignedCharin(pointer61, calloutState1);
						break;
					case 11:
						err1 = ffiPushDereferenceSignedCharin(pointer61, calloutState1);
						break;
					case 12:
						err1 = ffiPushDereferenceSingleFloatin(pointer61, calloutState1);
						break;
					case 13:
						err1 = ffiPushDereferenceDoubleFloatin(pointer61, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle41 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec211 = (calloutState1->ffiArgHeader);
					atomicType211 = ((usqInt)((typeSpec211 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType211 < 0)
					 || (atomicType211 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType211 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType211)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue111 = handle41;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle41 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle41)) {
									intValue111 = integerValueOf(handle41);
									goto l58;
								}
								
#                if SPURVM
								if (isCharacterObject(handle41)) {

									/* Immediate in Spur */
									intValue111 = characterValueOf(handle41);
									goto l58;
								}
								if (isFloatObject(handle41)) {

									/* Immediate in 64-bit Spur */
									intValue111 = floatValueOf(handle41);
									goto l58;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle41)) {
									intValue111 = characterValueOf(handle41);
									goto l58;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle41)) {
									intValue111 = floatValueOf(handle41);
									goto l58;
								}
								if (handle41 == (nilObject())) {
									intValue111 = 0;
									goto l58;
								}
								if (handle41 == (falseObject())) {
									intValue111 = 0;
									goto l58;
								}
								if (handle41 == (trueObject())) {
									intValue111 = 1;
									goto l58;
								}
								if (isLargePositiveIntegerObject(handle41)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue111 = positive64BitValueOf(handle41);
									goto l58;
#                  else /* BytesPerWord == 8 */
									intValue111 = positive32BitValueOf(handle41);
									goto l58;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue111 = signedMachineIntegerValueOf(handle41);
	l58:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType211) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue111, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue111, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue111, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue111, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue111, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue111, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue111, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue111, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue111, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue111, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle41)) {
						floatValue111 = floatValueOf(handle41);
						goto l52;
					}
					floatValue111 = ((double) (ffiIntegerValueOf(handle41)) );
	l52:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType211 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue111;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue111;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue111);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue111;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue111);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				if (!0) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				/* begin ffiArgByValue:in: */
				typeSpec311 = (calloutState1->ffiArgHeader);
				atomicType311 = ((usqInt)((typeSpec311 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType311 < 0)
				 || (atomicType311 > FFITypeDoubleFloat)) {
					err1 = FFIErrorBadAtomicType;
					goto l40;
				}
				if (atomicType311 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType311)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue21 = oop3;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop3 & (BytesPerWord - 1)) {
							if (isIntegerObject(oop3)) {
								intValue21 = integerValueOf(oop3);
								goto l39;
							}
							
#              if SPURVM
							if (isCharacterObject(oop3)) {

								/* Immediate in Spur */
								intValue21 = characterValueOf(oop3);
								goto l39;
							}
							if (isFloatObject(oop3)) {

								/* Immediate in 64-bit Spur */
								intValue21 = floatValueOf(oop3);
								goto l39;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop3)) {
								intValue21 = characterValueOf(oop3);
								goto l39;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop3)) {
								intValue21 = floatValueOf(oop3);
								goto l39;
							}
							if (oop3 == (nilObject())) {
								intValue21 = 0;
								goto l39;
							}
							if (oop3 == (falseObject())) {
								intValue21 = 0;
								goto l39;
							}
							if (oop3 == (trueObject())) {
								intValue21 = 1;
								goto l39;
							}
							if (isLargePositiveIntegerObject(oop3)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue21 = positive64BitValueOf(oop3);
								goto l39;
#                else /* BytesPerWord == 8 */
								intValue21 = positive32BitValueOf(oop3);
								goto l39;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue21 = signedMachineIntegerValueOf(oop3);
	l39:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					switch (atomicType311) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushUnsignedIntin(intValue21, calloutState1);
						break;
					case 2:
						err1 = ffiPushUnsignedBytein(intValue21, calloutState1);
						break;
					case 3:
						err1 = ffiPushSignedBytein(intValue21, calloutState1);
						break;
					case 4:
						err1 = ffiPushUnsignedShortin(intValue21, calloutState1);
						break;
					case 5:
						err1 = ffiPushSignedShortin(intValue21, calloutState1);
						break;
					case 7:
						err1 = ffiPushSignedIntin(intValue21, calloutState1);
						break;
					case 8:
						err1 = ffiPushUnsignedLongLongOopin(intValue21, calloutState1);
						break;
					case 9:
						err1 = ffiPushSignedLongLongOopin(intValue21, calloutState1);
						break;
					case 10:
						err1 = ffiPushUnsignedCharin(intValue21, calloutState1);
						break;
					case 11:
						err1 = ffiPushSignedCharin(intValue21, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop3)) {
					floatValue21 = floatValueOf(oop3);
					goto l48;
				}
				floatValue21 = ((double) (ffiIntegerValueOf(oop3)) );
	l48:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				if (atomicType311 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
							((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue21;
							(calloutState1->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue21;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
							(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue21;
						(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						(calloutState1->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState1->currentArg), floatValue21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
					}
					err1 = 0;
					goto l40;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type4 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type4))
						 && ((slotSizeOf(type4)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass4 = fetchPointerofObject(1, type4);
					if (!(includesBehaviorThatOf(referentClass4, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle11 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle11, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			case FFIFlagStructure:
				/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle51 = fetchPointerofObject(0, oop3);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass31 = fetchClassOf(handle51);
					if (ptrClass31 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress21 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress21)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize3 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
						argSpec31 = (calloutState1->ffiArgSpec);
						argSpecSize3 = (calloutState1->ffiArgSpecSize);
						availableRegisterSpace3 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
						stackPartSize3 = structSize3;
						if (availableRegisterSpace3 > 0) {
							if (structSize3 <= availableRegisterSpace3) {

								/* all in registers */
								stackPartSize3 = 0;
								memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, structSize3);
								(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize3 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
									stackPartSize3 = structSize3 - availableRegisterSpace3;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, availableRegisterSpace3);
								}
								else {
									availableRegisterSpace3 = 0;
								}
								(calloutState1->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize3 > 0) {
							roundedSize3 = (((stackPartSize3 + 3) | 3) - 3);
							if ((((calloutState1->currentArg)) + roundedSize3) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							memcpy((calloutState1->currentArg), (&((((char *) ptrAddress21))[availableRegisterSpace3])), stackPartSize3);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize3);
						}
						err1 = 0;
						goto l40;
					}
					if (ptrClass31 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle51)) == (((calloutState1->ffiArgHeader)) & FFIStructSizeMask))) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress21 = firstIndexableField(handle51);
						if (!(((calloutState1->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle51))) {
								err1 = -PrimErrObjectMayMove;
								goto l40;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize12 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
							argSpec12 = (calloutState1->ffiArgSpec);
							argSpecSize12 = (calloutState1->ffiArgSpecSize);
							availableRegisterSpace12 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
							stackPartSize12 = structSize12;
							if (availableRegisterSpace12 > 0) {
								if (structSize12 <= availableRegisterSpace12) {

									/* all in registers */
									stackPartSize12 = 0;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, structSize12);
									(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize12 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
										stackPartSize12 = structSize12 - availableRegisterSpace12;
										memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, availableRegisterSpace12);
									}
									else {
										availableRegisterSpace12 = 0;
									}
									(calloutState1->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize12 > 0) {
								roundedSize12 = (((stackPartSize12 + 3) | 3) - 3);
								if ((((calloutState1->currentArg)) + roundedSize12) > ((calloutState1->limit))) {
									err1 = FFIErrorCallFrameTooBig;
									goto l40;
								}
								memcpy((calloutState1->currentArg), (&((((char *) ptrAddress21))[availableRegisterSpace12])), stackPartSize12);
								(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize12);
							}
							err1 = 0;
							goto l40;
						}
						if (!((((calloutState1->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress21 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress21)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress21));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), ptrAddress21);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					err1 = FFIErrorBadArg;
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type31 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type31))
						 && ((slotSizeOf(type31)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass31 = fetchPointerofObject(1, type31);
					if (!(includesBehaviorThatOf(referentClass31, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle51 = fetchPointerofObject(0, oop3);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass111 = fetchClassOf(handle51);
					if (ptrClass111 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress11 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress11)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize21 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
						argSpec21 = (calloutState1->ffiArgSpec);
						argSpecSize21 = (calloutState1->ffiArgSpecSize);
						availableRegisterSpace21 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
						stackPartSize21 = structSize21;
						if (availableRegisterSpace21 > 0) {
							if (structSize21 <= availableRegisterSpace21) {

								/* all in registers */
								stackPartSize21 = 0;
								memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, structSize21);
								(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize21 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
									stackPartSize21 = structSize21 - availableRegisterSpace21;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, availableRegisterSpace21);
								}
								else {
									availableRegisterSpace21 = 0;
								}
								(calloutState1->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize21 > 0) {
							roundedSize21 = (((stackPartSize21 + 3) | 3) - 3);
							if ((((calloutState1->currentArg)) + roundedSize21) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							memcpy((calloutState1->currentArg), (&((((char *) ptrAddress11))[availableRegisterSpace21])), stackPartSize21);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize21);
						}
						err1 = 0;
						goto l40;
					}
					if (ptrClass111 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle51)) == (((calloutState1->ffiArgHeader)) & FFIStructSizeMask))) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress11 = firstIndexableField(handle51);
						if (!(((calloutState1->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle51))) {
								err1 = -PrimErrObjectMayMove;
								goto l40;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize111 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
							argSpec111 = (calloutState1->ffiArgSpec);
							argSpecSize111 = (calloutState1->ffiArgSpecSize);
							availableRegisterSpace111 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
							stackPartSize111 = structSize111;
							if (availableRegisterSpace111 > 0) {
								if (structSize111 <= availableRegisterSpace111) {

									/* all in registers */
									stackPartSize111 = 0;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, structSize111);
									(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize111 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
										stackPartSize111 = structSize111 - availableRegisterSpace111;
										memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, availableRegisterSpace111);
									}
									else {
										availableRegisterSpace111 = 0;
									}
									(calloutState1->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize111 > 0) {
								roundedSize111 = (((stackPartSize111 + 3) | 3) - 3);
								if ((((calloutState1->currentArg)) + roundedSize111) > ((calloutState1->limit))) {
									err1 = FFIErrorCallFrameTooBig;
									goto l40;
								}
								memcpy((calloutState1->currentArg), (&((((char *) ptrAddress11))[availableRegisterSpace111])), stackPartSize111);
								(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize111);
							}
							err1 = 0;
							goto l40;
						}
						if (!((((calloutState1->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress11 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress11)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress11));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), ptrAddress11);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					err1 = FFIErrorBadArg;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			case FFIFlagStructure + FFIFlagPointer:
				/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
					handle21 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle21, calloutState1);
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type11 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type11))
						 && ((slotSizeOf(type11)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass11 = fetchPointerofObject(1, type11);
					if (!(includesBehaviorThatOf(referentClass11, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle21 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle21, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			default:
				err1 = FFIErrorWrongType;
				goto l40;

			}
		}
	l40:	/* end ffiArgument:Spec:Class:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l68;
			}
#      endif /* COGMTVM */
			ffiFail(err1);
			goto l68;
		}
	}
	assert(!(failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName1 = fetchPointerofObject(externalFunctionInstSize, externalFunction);
		if (!(isBytes(functionName1))) {
			goto l62;
		}
		ffiLogCallOfLength(firstIndexableField(functionName1), byteSizeOf(functionName1));
	}
	l62:	/* end ffiLogCallout: */;
	if ((requiredStackSize1 < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize1 = ((calloutState1->currentArg)) - ((calloutState1->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize1);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex1 = disownVM(
#  if COGMTVM
		(((calloutState1->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		);
	if (((calloutState1->floatRegisterIndex)) > 0) {
		loadFloatRegs((((double *) ((&(((calloutState1->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[14])))))[0]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState1->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec6 = (calloutState1->ffiRetHeader);
	atomicType6 = ((usqInt)((typeSpec6 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType6)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType6 == FFITypeSingleFloat) {
			floatRet1 = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet1 = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
		}
		if (isCalleePopsConvention((calloutState1->callFlags))) {
			setsp((calloutState1->argVector));
		}
		ownVM(myThreadIndex1);
		result2 = floatObjectOf(floatRet1);
		goto l41;
	}

	/* undo any callee argument pops because it may confuse stack management with the alloca. */
	intRet1 = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
	if (isCalleePopsConvention((calloutState1->callFlags))) {
		setsp((calloutState1->argVector));
	}
	ownVM(myThreadIndex1);
	if (((calloutState1->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState1->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			specLiteral2 = (null != null
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes2 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral2);
			retType1 = fetchPointerofObject(0, argTypes2);
			retClass21 = fetchPointerofObject(1, retType1);
			if (retClass21 == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec13 = (calloutState1->ffiRetHeader);
				atomicType13 = ((usqInt)((typeSpec13 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType13)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer1 = ((usqInt) intRet1);
					if (!(cPointer1)) {
						retOop2 = nilObject();
						goto l56;
					}
					cString1 = ((char *) cPointer1);
					strLen1 = 0;
					while (!((cString1[strLen1]) == 0)) {
						strLen1 += 1;
					}
					strOop1 = instantiateClassindexableSize(classString(), strLen1);
					strPtr1 = firstIndexableField(strOop1);
					for (i11 = 0; i11 < strLen1; i11 += 1) {
						strPtr1[i11] = (cString1[i11]);
					}
					retOop2 = strOop1;
	l56:	/* end ffiReturnCStringFrom: */;
					result2 = retOop2;
					goto l41;
				}
			}
			
#if SPURVM
			oop21 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr11 = firstIndexableField(oop21);
			ptr11[0] = (((sqInt) intRet1));
			retOop2 = instantiateClassindexableSize(classExternalData(), 0);
			storePointerofObjectwithValue(0, retOop2, oop21);

#else /* SPURVM */
			pushRemappableOop(retType1);
			oop21 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr11 = firstIndexableField(oop21);
			ptr11[0] = (((sqInt) intRet1));
						pushRemappableOop(oop21);
			retOop2 = instantiateClassindexableSize(classExternalData(), 0);
			oop21 = popRemappableOop();
			storePointerofObjectwithValue(0, retOop2, oop21);
			retType1 = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(1, retOop2, retType1);
			result2 = retOop2;
			goto l41;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr1 = (&intRet1);
		/* begin ffiReturnType: */
		specLiteral11 = (null != null
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes11 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral11);
		ffiRetType1 = fetchPointerofObject(0, argTypes11);
		retClass11 = fetchPointerofObject(1, ffiRetType1);
		retOop11 = instantiateClassindexableSize(retClass11, 0);
		
#if SPURVM
		oop11 = instantiateClassindexableSize(classByteArray(), (calloutState1->structReturnSize));

#else /* SPURVM */
		pushRemappableOop(retOop11);
		oop11 = instantiateClassindexableSize(classByteArray(), (calloutState1->structReturnSize));
		retOop11 = popRemappableOop()
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop11), ((calloutState1->structReturnType)
			? longLongRetPtr1
			: (calloutState1->limit)), (calloutState1->structReturnSize));
		storePointerofObjectwithValue(0, retOop11, oop11);
		result2 = retOop11;
		goto l41;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(atomicType6 < FFITypeSingleFloat);
	if (atomicType6 == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize1 = ((calloutState1->ffiRetHeader)) & FFIStructSizeMask;
		value1 = (byteSize1 == (sizeof(intRet1))
			? intRet1
			: intRet1 & (((((unsigned long long)1)) << (byteSize1 * 8)) - 1));
		if (value1 == 0) {
			result2 = falseObject();
		}
		else {
			result2 = trueObject();
		}
		goto l41;
	}
	if (atomicType6 <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType6 <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift1 = ((BytesPerWord == 8)
			 && (atomicType6 >= FFITypeUnsignedInt)
				? 32
				: (((usqInt)(atomicType6)) >> 1) * 8);
			value1 = intRet1 & (((((unsigned long long)1)) << shift1) - 1);
			if (atomicType6 & 1) {

				/* make the guy signed */
				mask1 = (((unsigned long long)1)) << (shift1 - 1);
				value1 = (value1 & (mask1 - 1)) - (value1 & mask1);
			}
			result2 = integerObjectOf(value1);
			goto l41;
		}
		if (atomicType6 & 1) {
			if (BytesPerWord == 8) {
				result2 = signed64BitIntegerFor(intRet1);
			}
			else {
				result2 = signed32BitIntegerFor(intRet1);
			}
		}
		else {
			if (BytesPerWord == 8) {
				result2 = positive64BitIntegerFor(intRet1);
			}
			else {
				result2 = positive32BitIntegerFor(intRet1);
			}
		}
		goto l41;
	}
	if ((((usqInt)(atomicType6)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {
		if (atomicType6 & 1) {
			result2 = signed64BitIntegerFor(intRet1);
		}
		else {
			result2 = positive64BitIntegerFor(intRet1);
		}
	}
	else {
		result2 = characterObjectOf(intRet1 & 0xFF);
	}
	l41:	/* end ffiCalloutTo:SpecOnStack:in: */;
	if (!(retClass3 == (nilObject()))) {
		if ((((calloutState1->ffiRetHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) == FFIFlagAtomic) {
			
#if SPURVM
			alias1 = instantiateClassindexableSize(retClass3, 0);

#else /* SPURVM */
			pushRemappableOop(result2);
			alias1 = instantiateClassindexableSize(retClass3, 0);
			result2 = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, alias1, result2);
			result2 = alias1;
		}
	}
	/* begin cleanupCalloutState: */
	while (((calloutState1->stringArgIndex)) > 0) {
		free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs1 + 1, result2);
	l68:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
#  endif /* COGMTVM */
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from ExternalFunction>>invokeWithArguments: */

	/* ThreadedFFIPlugin>>#primitiveCalloutWithArgs */
EXPORT(void)
primitiveCalloutWithArgs(void)
{
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt addressPtr;
    sqInt addressPtr1;
    sqInt alias;
    sqInt alias1;
    char *allocation;
    char *allocation1;
    sqInt argArray;
    sqInt argClass;
    sqInt argClass1;
    sqInt argSpec;
    sqInt *argSpec1;
    sqInt *argSpec11;
    sqInt *argSpec111;
    sqInt *argSpec12;
    sqInt *argSpec2;
    sqInt *argSpec21;
    sqInt *argSpec3;
    sqInt *argSpec31;
    sqInt argSpec4;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt argSpecSize11;
    sqInt argSpecSize111;
    sqInt argSpecSize12;
    sqInt argSpecSize2;
    sqInt argSpecSize21;
    sqInt argSpecSize3;
    sqInt argType;
    sqInt argType1;
    sqInt argTypeArray;
    sqInt argTypeArray1;
    sqInt argTypes;
    sqInt argTypes1;
    sqInt argTypes11;
    sqInt argTypes2;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType11;
    sqInt atomicType111;
    sqInt atomicType12;
    sqInt atomicType121;
    sqInt atomicType13;
    sqInt atomicType2;
    sqInt atomicType21;
    sqInt atomicType211;
    sqInt atomicType22;
    sqInt atomicType3;
    sqInt atomicType31;
    sqInt atomicType311;
    sqInt atomicType32;
    sqInt atomicType4;
    sqInt atomicType41;
    sqInt atomicType5;
    sqInt atomicType51;
    sqInt atomicType6;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt availableRegisterSpace11;
    sqInt availableRegisterSpace111;
    sqInt availableRegisterSpace12;
    sqInt availableRegisterSpace2;
    sqInt availableRegisterSpace21;
    sqInt availableRegisterSpace3;
    sqInt byteSize;
    sqInt byteSize1;
    CalloutState *calloutState;
    CalloutState *calloutState1;
    char *copy;
    char *copy1;
    sqInt cPointer;
    sqInt cPointer1;
    char *cString;
    char *cString1;
    sqInt err;
    sqInt err1;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt ffiRetType1;
    sqInt flags;
    sqInt flags1;
    double floatRet;
    double floatRet1;
    double floatValue;
    double floatValue1;
    double floatValue11;
    double floatValue111;
    double floatValue12;
    double floatValue2;
    double floatValue21;
    double floatValue3;
    double floatValue31;
    double floatValue4;
    sqInt functionName;
    sqInt functionName1;
    sqInt handle;
    sqInt handle1;
    sqInt handle11;
    sqInt handle2;
    sqInt handle21;
    sqInt handle3;
    sqInt handle31;
    sqInt handle4;
    sqInt handle41;
    sqInt handle5;
    sqInt handle51;
    sqInt handle6;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    usqLong intRet;
    usqLong intRet1;
    sqInt intValue;
    sqInt intValue1;
    sqInt intValue11;
    sqInt intValue111;
    sqInt intValue12;
    sqInt intValue2;
    sqInt intValue21;
    sqInt intValue3;
    sqInt intValue31;
    sqInt intValue4;
    sqInt length;
    sqInt length1;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    void *longLongRetPtr1;
    usqLong mask;
    usqLong mask1;
    sqInt myThreadIndex;
    sqInt myThreadIndex1;
    sqInt nArgs;
    sqInt nilOop;
    sqInt nilOop1;
    sqInt oop;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt oop3;
    sqInt oopClass;
    sqInt oopClass1;
    void *pointer;
    void *pointer1;
    void *pointer11;
    void *pointer2;
    void *pointer21;
    void *pointer3;
    void *pointer31;
    void *pointer4;
    void *pointer41;
    void *pointer5;
    void *pointer51;
    void *pointer6;
    void *pointer61;
    char *pointer7;
    char *pointer71;
    void *pointer8;
    sqInt primNumArgs;
    sqInt primNumArgs1;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt *ptr11;
    sqIntptr_t *ptr2;
    void * ptrAddress;
    void * ptrAddress1;
    void * ptrAddress11;
    void * ptrAddress2;
    void * ptrAddress21;
    void * ptrAddress3;
    sqInt ptrClass;
    sqInt ptrClass1;
    sqInt ptrClass11;
    sqInt ptrClass111;
    sqInt ptrClass12;
    sqInt ptrClass2;
    sqInt ptrClass21;
    sqInt ptrClass3;
    sqInt ptrClass31;
    sqInt ptrClass4;
    sqInt ptrType;
    sqInt ptrType1;
    sqInt ptrType11;
    sqInt ptrType2;
    sqInt referentClass;
    sqInt referentClass1;
    sqInt referentClass11;
    sqInt referentClass2;
    sqInt referentClass21;
    sqInt referentClass3;
    sqInt referentClass31;
    sqInt referentClass4;
    sqInt requiredStackSize;
    sqInt requiredStackSize1;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass11;
    sqInt retClass2;
    sqInt retClass21;
    sqInt retClass3;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop11;
    sqInt retOop2;
    sqInt retryCount;
    sqInt retType;
    sqInt retType1;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt roundedSize11;
    sqInt roundedSize111;
    sqInt roundedSize12;
    sqInt roundedSize2;
    sqInt roundedSize21;
    sqInt roundedSize3;
    sqInt shift;
    sqInt shift1;
    sqInt spec;
    sqInt spec1;
    sqInt spec11;
    sqInt spec2;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specLiteral11;
    sqInt specLiteral2;
    sqInt specOop;
    sqInt specOop1;
    sqInt specOop11;
    sqInt specOop2;
    sqInt specType;
    sqInt specType1;
    sqInt specType11;
    sqInt specType2;
    sqInt stackPartSize;
    sqInt stackPartSize1;
    sqInt stackPartSize11;
    sqInt stackPartSize111;
    sqInt stackPartSize12;
    sqInt stackPartSize2;
    sqInt stackPartSize21;
    sqInt stackPartSize3;
    sqInt stackSize;
    sqInt stackSize1;
    sqInt strLen;
    sqInt strLen1;
    sqInt strOop;
    sqInt strOop1;
    char *strPtr;
    char *strPtr1;
    sqInt structSize;
    sqInt structSize1;
    sqInt structSize11;
    sqInt structSize111;
    sqInt structSize12;
    sqInt structSize2;
    sqInt structSize21;
    sqInt structSize3;
    CalloutState theCalloutState;
    CalloutState theCalloutState1;
    sqInt type;
    sqInt type1;
    sqInt type11;
    sqInt type2;
    sqInt type21;
    sqInt type3;
    sqInt type31;
    sqInt type4;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec11;
    sqInt typeSpec111;
    sqInt typeSpec12;
    sqInt typeSpec121;
    sqInt typeSpec13;
    sqInt typeSpec2;
    sqInt typeSpec21;
    sqInt typeSpec211;
    sqInt typeSpec22;
    sqInt typeSpec3;
    sqInt typeSpec31;
    sqInt typeSpec311;
    sqInt typeSpec32;
    sqInt typeSpec4;
    sqInt typeSpec41;
    sqInt typeSpec5;
    sqInt typeSpec51;
    sqInt typeSpec6;
    usqLong value;
    usqLong value1;

	pointer5 = ((void *) 0);
	pointer51 = ((void *) 0);
	pointer6 = ((void *) 0);
	pointer61 = ((void *) 0);
	if (!((methodArgumentCount()) == 1)) {
		primitiveFailFor(PrimErrBadNumArgs);
		return;
	}
	
#  if COGMTVM
	retryCount = 0;
	while (1) {
		externalFunction = stackValue(1);
		argArray = stackValue(0);
		if (!(isArray(argArray))) {
			primitiveFailFor(PrimErrBadArgument);
			return;
		}
		nArgs = slotSizeOf(argArray);
		/* begin ffiCall:ArgArrayOrNil:NumArgs: */
		primNumArgs = methodArgumentCount();
		if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
			result = ffiFail(FFIErrorNotFunction);
			goto l34;
		}
		flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
		if (failed()) {
			result = ffiFail(FFIErrorBadArgs);
			goto l34;
		}
		/* begin ffiLoadCalloutAddress: */

		/* Make sure it's an external handle */
		addressPtr = fetchPointerofObject(0, externalFunction);
		if (!((isBytes(addressPtr))
			 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
			address1 = ffiFail(FFIErrorBadAddress);
			goto l1;
		}
		address1 = fetchPointerofObject(0, addressPtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
		if (failed()) {
			address = 0;
			goto l2;
		}
		if (address1 == 0) {

			/* Go look it up in the module */
			if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
				storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1));
			}
			if ((slotSizeOf(externalFunction)) < 5) {
				address = ffiFail(FFIErrorNoModule);
				goto l2;
			}
			address1 = ffiLoadCalloutAddressFrom(externalFunction);
			if (failed()) {
				address = 0;
				goto l2;
			}
			ptr = firstIndexableField(addressPtr);
			ptr[0] = address1;
		}
		address = address1;
	l2:	/* end ffiLoadCalloutAddress: */;
		if (failed()) {
			result = 0;
			goto l34;
		}

		/* must be array of arg types */
		argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
		if (!((isArray(argTypeArray))
			 && ((slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
			result = ffiFail(FFIErrorBadArgs);
			goto l34;
		}
		
#    if COGMTVM
		if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
			 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType);
			goto l34;
		}
#    else /* COGMTVM */

		/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
		if (!((flags == FFICallTypeCDecl)
			 || (flags == FFICallTypeApi))) {
			result = ffiFail(FFIErrorCallType);
			goto l34;
		}
#    endif /* COGMTVM */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			requiredStackSize = fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction);
		}
		else {
			requiredStackSize = -1;
		}
		if (failed()) {
			result = primitiveFailFor((argArray == null
				? PrimErrBadMethod
				: PrimErrBadReceiver));
			goto l34;
		}
		stackSize = (requiredStackSize < 0
			? DefaultMaxStackSize
			: requiredStackSize);
		calloutState = (&theCalloutState);
		memset(calloutState, 0, sizeof(CalloutState));
		(calloutState->callFlags = flags);
		argType = fetchPointerofObject(0, argTypeArray);
		argSpec = fetchPointerofObject(0, argType);
		retClass = fetchPointerofObject(1, argType);
		if (((err = ffiCheckReturnWithin(argSpec, retClass, calloutState))) != 0) {
			result = ffiFail(err);
			goto l34;
		}
		allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
		if (mustAlignStack()) {
			allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
		}
		(calloutState->argVector = allocation);
		(calloutState->currentArg = allocation);
		(calloutState->limit = allocation + stackSize);
		if ((((calloutState->structReturnSize)) > 0)
		 && (1
		 && (!((calloutState->structReturnType))))) {
			/* begin ffiPushPointer:in: */
			pointer = (calloutState->limit);
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					err = FFIErrorCallFrameTooBig;
					goto l4;
				}
				longAtput((calloutState->currentArg), pointer);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			err = 0;
	l4:	/* end ffiPushPointer:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l34;
				}
#        endif /* COGMTVM */
				result = ffiFail(err);
				goto l34;
			}
		}
		for (i = 1; i <= nArgs; i += 1) {
			argType = fetchPointerofObject(i, argTypeArray);
			argSpec = fetchPointerofObject(0, argType);
			argClass = fetchPointerofObject(1, argType);
			oop = (argArray == null
				? stackValue(nArgs - i)
				: fetchPointerofObject(i - 1, argArray));
			/* begin ffiArgument:Spec:Class:in: */
			if (!(isWords(argSpec))) {
				err = FFIErrorWrongType;
				goto l33;
			}
			(calloutState->ffiArgSpecSize = slotSizeOf(argSpec));
			if (((calloutState->ffiArgSpecSize)) == 0) {
				err = FFIErrorWrongType;
				goto l33;
			}
			(calloutState->ffiArgSpec = firstIndexableField(argSpec));
			(calloutState->ffiArgHeader = longAt((calloutState->ffiArgSpec)));

			/* Prefetch class (we'll need it) */
			oopClass = fetchClassOf(oop);
			nilOop = nilObject();
			if (nilOop == argClass) {
				
				switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
				case FFIFlagAtomic:
					/* begin ffiPassAtomicArgumentByValue:Class:In: */
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check: we handle pointer to an atomic type */
						/* begin atomicTypeOf: */
						typeSpec3 = (calloutState->ffiArgHeader);
						atomicType3 = ((usqInt)((typeSpec3 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						/* begin ffiValidateExternalData:AtomicType: */
						ptrType1 = fetchPointerofObject(1, oop);
						if (!((isPointers(ptrType1))
							 && ((slotSizeOf(ptrType1)) >= 2))) {
							goto l11;
						}
						specOop1 = fetchPointerofObject(0, ptrType1);
						if (!((isWords(specOop1))
							 && ((slotSizeOf(specOop1)) > 0))) {
							goto l11;
						}
						spec1 = fetchPointerofObject(0, specOop1);
						if (!(spec1 & FFIFlagAtomic)) {
							goto l11;
						}
						/* begin atomicTypeOf: */
						specType1 = ((usqInt)((spec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if (specType1 != atomicType3) {

							/* Allow for signed/unsigned conversion but nothing else.
							   See FFIConstants class>>#initializeTypeConstants */
							if (!((atomicType3 >= FFITypeUnsignedByte)
								 && ((atomicType3 <= FFITypeSignedChar)
								 && ((((usqInt)(atomicType3)) >> 1) == (((usqInt)(specType1)) >> 1))))) {
								goto l11;
							}
						}
	l11:	/* end ffiValidateExternalData:AtomicType: */;
						if (failed()) {
							err = null;
							goto l33;
						}
						handle3 = fetchPointerofObject(0, oop);
						ptrClass1 = fetchClassOf(handle3);
						if (ptrClass1 == (classExternalAddress())) {

							/* Don't you dare to pass pointers into object memory */
							pointer5 = fetchPointerofObject(0, handle3);
							if (isInMemory(pointer5)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
						}
						else {
							if (ptrClass1 == (classByteArray())) {
								pointer5 = ((void *) (firstIndexableField(handle3)));
							}
							else {
								err = FFIErrorBadArg;
								goto l33;
							}
						}
						switch (atomicType3) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushDereferenceUnsignedIntin(pointer5, calloutState);
							break;
						case 2:
							err = ffiPushDereferenceUnsignedBytein(pointer5, calloutState);
							break;
						case 3:
							err = ffiPushDereferenceSignedBytein(pointer5, calloutState);
							break;
						case 4:
							err = ffiPushDereferenceUnsignedShortin(pointer5, calloutState);
							break;
						case 5:
							err = ffiPushDereferenceSignedShortin(pointer5, calloutState);
							break;
						case 7:
							err = ffiPushDereferenceSignedIntin(pointer5, calloutState);
							break;
						case 8:
							err = ffiPushDereferenceUnsignedLongLongin(pointer5, calloutState);
							break;
						case 9:
							err = ffiPushDereferenceSignedLongLongin(pointer5, calloutState);
							break;
						case 10:
							err = ffiPushDereferenceUnsignedCharin(pointer5, calloutState);
							break;
						case 11:
							err = ffiPushDereferenceSignedCharin(pointer5, calloutState);
							break;
						case 12:
							err = ffiPushDereferenceSingleFloatin(pointer5, calloutState);
							break;
						case 13:
							err = ffiPushDereferenceDoubleFloatin(pointer5, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

						/* We do not have any type specification easily available.
						   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
						handle3 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec12 = (calloutState->ffiArgHeader);
						atomicType12 = ((usqInt)((typeSpec12 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType12 < 0)
						 || (atomicType12 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType12 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType12)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue = handle3;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle3 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle3)) {
										intValue = integerValueOf(handle3);
										goto l29;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle3)) {

										/* Immediate in Spur */
										intValue = characterValueOf(handle3);
										goto l29;
									}
									if (isFloatObject(handle3)) {

										/* Immediate in 64-bit Spur */
										intValue = floatValueOf(handle3);
										goto l29;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle3)) {
										intValue = characterValueOf(handle3);
										goto l29;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle3)) {
										intValue = floatValueOf(handle3);
										goto l29;
									}
									if (handle3 == (nilObject())) {
										intValue = 0;
										goto l29;
									}
									if (handle3 == (falseObject())) {
										intValue = 0;
										goto l29;
									}
									if (handle3 == (trueObject())) {
										intValue = 1;
										goto l29;
									}
									if (isLargePositiveIntegerObject(handle3)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue = positive64BitValueOf(handle3);
										goto l29;
#                    else /* BytesPerWord == 8 */
										intValue = positive32BitValueOf(handle3);
										goto l29;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue = signedMachineIntegerValueOf(handle3);
	l29:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType12) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle3)) {
							floatValue = floatValueOf(handle3);
							goto l32;
						}
						floatValue = ((double) (ffiIntegerValueOf(handle3)) );
	l32:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType12 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					/* begin ffiArgByValue:in: */
					typeSpec2 = (calloutState->ffiArgHeader);
					atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType2 < 0)
					 || (atomicType2 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType2 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType2)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue1 = oop;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (oop & (BytesPerWord - 1)) {
								if (isIntegerObject(oop)) {
									intValue1 = integerValueOf(oop);
									goto l30;
								}
								
#                if SPURVM
								if (isCharacterObject(oop)) {

									/* Immediate in Spur */
									intValue1 = characterValueOf(oop);
									goto l30;
								}
								if (isFloatObject(oop)) {

									/* Immediate in 64-bit Spur */
									intValue1 = floatValueOf(oop);
									goto l30;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(oop)) {
									intValue1 = characterValueOf(oop);
									goto l30;
								}
#                endif /* SPURVM */
								if (isFloatObject(oop)) {
									intValue1 = floatValueOf(oop);
									goto l30;
								}
								if (oop == (nilObject())) {
									intValue1 = 0;
									goto l30;
								}
								if (oop == (falseObject())) {
									intValue1 = 0;
									goto l30;
								}
								if (oop == (trueObject())) {
									intValue1 = 1;
									goto l30;
								}
								if (isLargePositiveIntegerObject(oop)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue1 = positive64BitValueOf(oop);
									goto l30;
#                  else /* BytesPerWord == 8 */
									intValue1 = positive32BitValueOf(oop);
									goto l30;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue1 = signedMachineIntegerValueOf(oop);
	l30:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType2) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue1, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue1, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue1, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue1, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue1, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue1, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue1, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue1, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue1, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue1, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(oop)) {
						floatValue1 = floatValueOf(oop);
						goto l23;
					}
					floatValue1 = ((double) (ffiIntegerValueOf(oop)) );
	l23:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType2 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue1;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue1;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue1);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue1;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue1);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
					break;
				case FFIFlagAtomic + FFIFlagPointer:
					/* begin ffiPassAtomicArgumentByReference:Class:In: */
					typeSpec5 = (calloutState->ffiArgHeader);
					atomicType5 = ((usqInt)((typeSpec5 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Check: we handle pointer to an atomic type */
						/* no type checks for void pointers */
						if (atomicType5 != FFITypeVoid) {
							/* begin ffiValidateExternalData:AtomicType: */
							ptrType = fetchPointerofObject(1, oop);
							if (!((isPointers(ptrType))
								 && ((slotSizeOf(ptrType)) >= 2))) {
								goto l27;
							}
							specOop = fetchPointerofObject(0, ptrType);
							if (!((isWords(specOop))
								 && ((slotSizeOf(specOop)) > 0))) {
								goto l27;
							}
							spec = fetchPointerofObject(0, specOop);
							if (!(spec & FFIFlagAtomic)) {
								goto l27;
							}
							/* begin atomicTypeOf: */
							specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
							if (specType != atomicType5) {

								/* Allow for signed/unsigned conversion but nothing else.
								   See FFIConstants class>>#initializeTypeConstants */
								if (!((atomicType5 >= FFITypeUnsignedByte)
									 && ((atomicType5 <= FFITypeSignedChar)
									 && ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(specType)) >> 1))))) {
									goto l27;
								}
							}
	l27:	/* end ffiValidateExternalData:AtomicType: */;
						}
						if (failed()) {
							err = null;
							goto l33;
						}
						handle = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

						/* note: the only types allowed for passing into char* types are
						   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
						   (e.g., CompiledMethod, LargeInteger). We only check for strings
						   here and fall through to the byte* check otherwise. */
						if (includesBehaviorThatOf(oopClass, classString())) {
							/* begin ffiPushString:OfLength:in: */
							pointer7 = ((char *) (firstIndexableField(oop)));
							length = byteSizeOf(oop);
							if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
								err = -PrimErrBadNumArgs;
								goto l33;
							}
							copy = malloc(length + 1);
							if (copy == null) {
								err = -PrimErrNoCMemory;
								goto l33;
							}
							memcpy(copy, pointer7, length);
							copy[length] = 0;
							((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
							(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), copy);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						atomicType5 = FFITypeUnsignedByte;
					}
					ptrClass = fetchClassOf(oop);
					if (ptrClass == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
						if (isInMemory(ptrAddress)) {
							err = FFIErrorInvalidPointer;
							goto l33;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if (includesBehaviorThatOf(ptrClass, classAlien())) {
						
#            if COGMTVM
						if ((((calloutState->callFlags)) & FFICallFlagThreaded)
						 && (((assert(isAlien(oop)),
						(longAt(oop + BaseHeaderSize)) > 0))
						 && (isYoung(oop)))) {
							err = -PrimErrObjectMayMove;
							goto l33;
						}
#            endif /* COGMTVM */
						ptrAddress = ((longAt(oop + BaseHeaderSize)) > 0
							? (oop + BaseHeaderSize) + BytesPerOop
							: longAt((oop + BaseHeaderSize) + BytesPerOop));
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), ptrAddress);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					
#          if COGMTVM

					/* Since all the following pass the address of the first indexable field we need to fail
					   the call if it is threaded and the object is young, since it may move during the call. */
					if ((((calloutState->callFlags)) & FFICallFlagThreaded)
					 && (isYoung(oop))) {
						err = -PrimErrObjectMayMove;
						goto l33;
					}
#          endif /* COGMTVM */
					if ((ptrClass == (classByteArray()))
					 && ((atomicType5 == FFITypeVoid)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
						/* begin ffiPushPointer:in: */
						pointer1 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer1);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isShorts(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
						/* begin ffiPushPointer:in: */
						pointer2 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer2);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isWords(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((atomicType5 == FFITypeSingleFloat)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
						/* begin ffiPushPointer:in: */
						pointer3 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer3);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					if ((isLong64s(oop))
					 && ((atomicType5 == FFITypeVoid)
					 || ((atomicType5 == FFITypeDoubleFloat)
					 || ((((usqInt)(atomicType5)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
						/* begin ffiPushPointer:in: */
						pointer4 = ((void *) (firstIndexableField(oop)));
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), pointer4);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				default:
					err = FFIErrorWrongType;
					goto l33;

				}
			}
			else {

				/* If specified, the required class of the argument shall be subclass of ExternalStructure */
				if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
					err = FFIErrorWrongType;
					goto l33;
				}
				
				switch (((calloutState->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
				case FFIFlagAtomic:
					/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
						handle4 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec11 = (calloutState->ffiArgHeader);
						atomicType11 = ((usqInt)((typeSpec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType11 < 0)
						 || (atomicType11 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType11 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType11)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue3 = handle4;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle4 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle4)) {
										intValue3 = integerValueOf(handle4);
										goto l14;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle4)) {

										/* Immediate in Spur */
										intValue3 = characterValueOf(handle4);
										goto l14;
									}
									if (isFloatObject(handle4)) {

										/* Immediate in 64-bit Spur */
										intValue3 = floatValueOf(handle4);
										goto l14;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle4)) {
										intValue3 = characterValueOf(handle4);
										goto l14;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle4)) {
										intValue3 = floatValueOf(handle4);
										goto l14;
									}
									if (handle4 == (nilObject())) {
										intValue3 = 0;
										goto l14;
									}
									if (handle4 == (falseObject())) {
										intValue3 = 0;
										goto l14;
									}
									if (handle4 == (trueObject())) {
										intValue3 = 1;
										goto l14;
									}
									if (isLargePositiveIntegerObject(handle4)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue3 = positive64BitValueOf(handle4);
										goto l14;
#                    else /* BytesPerWord == 8 */
										intValue3 = positive32BitValueOf(handle4);
										goto l14;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue3 = signedMachineIntegerValueOf(handle4);
	l14:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType11) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue3, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue3, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue3, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue3, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue3, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue3, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue3, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue3, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue3, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue3, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle4)) {
							floatValue3 = floatValueOf(handle4);
							goto l17;
						}
						floatValue3 = ((double) (ffiIntegerValueOf(handle4)) );
	l17:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType11 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue3;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue3;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue3);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue3;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue3);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type2 = fetchPointerofObject(1, oop);
						if (!((isPointers(type2))
							 && ((slotSizeOf(type2)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass2 = fetchPointerofObject(1, type2);
						if (!(includesBehaviorThatOf(referentClass2, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle4 = fetchPointerofObject(0, oop);
						ptrClass2 = fetchClassOf(handle4);
						if (ptrClass2 == (classExternalAddress())) {

							/* Don't you dare to pass pointers into object memory */
							pointer6 = fetchPointerofObject(0, handle4);
							if (isInMemory(pointer6)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
						}
						else {
							if (ptrClass2 == (classByteArray())) {
								pointer6 = ((void *) (firstIndexableField(handle4)));
							}
							else {
								err = FFIErrorBadArg;
								goto l33;
							}
						}
						/* begin atomicTypeOf: */
						typeSpec4 = (calloutState->ffiArgHeader);
						atomicType4 = ((usqInt)((typeSpec4 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						switch (atomicType4) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushDereferenceUnsignedIntin(pointer6, calloutState);
							break;
						case 2:
							err = ffiPushDereferenceUnsignedBytein(pointer6, calloutState);
							break;
						case 3:
							err = ffiPushDereferenceSignedBytein(pointer6, calloutState);
							break;
						case 4:
							err = ffiPushDereferenceUnsignedShortin(pointer6, calloutState);
							break;
						case 5:
							err = ffiPushDereferenceSignedShortin(pointer6, calloutState);
							break;
						case 7:
							err = ffiPushDereferenceSignedIntin(pointer6, calloutState);
							break;
						case 8:
							err = ffiPushDereferenceUnsignedLongLongin(pointer6, calloutState);
							break;
						case 9:
							err = ffiPushDereferenceSignedLongLongin(pointer6, calloutState);
							break;
						case 10:
							err = ffiPushDereferenceUnsignedCharin(pointer6, calloutState);
							break;
						case 11:
							err = ffiPushDereferenceSignedCharin(pointer6, calloutState);
							break;
						case 12:
							err = ffiPushDereferenceSingleFloatin(pointer6, calloutState);
							break;
						case 13:
							err = ffiPushDereferenceDoubleFloatin(pointer6, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalStructure())) {

						/* We do not have any type specification easily available.
						   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
						handle4 = fetchPointerofObject(0, oop);
						/* begin ffiArgByValue:in: */
						typeSpec21 = (calloutState->ffiArgHeader);
						atomicType21 = ((usqInt)((typeSpec21 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if ((atomicType21 < 0)
						 || (atomicType21 > FFITypeDoubleFloat)) {
							err = FFIErrorBadAtomicType;
							goto l33;
						}
						if (atomicType21 < FFITypeSingleFloat) {

							/* integer types */
							if ((((usqInt)(atomicType21)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

								/* ffi support code must coerce longlong */
								intValue11 = handle4;
							}
							else {
								/* begin ffiIntegerValueOf: */
								if (handle4 & (BytesPerWord - 1)) {
									if (isIntegerObject(handle4)) {
										intValue11 = integerValueOf(handle4);
										goto l13;
									}
									
#                  if SPURVM
									if (isCharacterObject(handle4)) {

										/* Immediate in Spur */
										intValue11 = characterValueOf(handle4);
										goto l13;
									}
									if (isFloatObject(handle4)) {

										/* Immediate in 64-bit Spur */
										intValue11 = floatValueOf(handle4);
										goto l13;
									}
#                  endif /* SPURVM */
								}
								else {
									
#                  if SPURVM

									/* No non-immediate characters in Spur */
#                  else /* SPURVM */
									if (isCharacterObject(handle4)) {
										intValue11 = characterValueOf(handle4);
										goto l13;
									}
#                  endif /* SPURVM */
									if (isFloatObject(handle4)) {
										intValue11 = floatValueOf(handle4);
										goto l13;
									}
									if (handle4 == (nilObject())) {
										intValue11 = 0;
										goto l13;
									}
									if (handle4 == (falseObject())) {
										intValue11 = 0;
										goto l13;
									}
									if (handle4 == (trueObject())) {
										intValue11 = 1;
										goto l13;
									}
									if (isLargePositiveIntegerObject(handle4)) {
										
#                    if BytesPerWord == 8

										/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
										intValue11 = positive64BitValueOf(handle4);
										goto l13;
#                    else /* BytesPerWord == 8 */
										intValue11 = positive32BitValueOf(handle4);
										goto l13;
#                    endif /* BytesPerWord == 8 */
									}
								}
								intValue11 = signedMachineIntegerValueOf(handle4);
	l13:	/* end ffiIntegerValueOf: */;
							}
							if (failed()) {
								err = FFIErrorCoercionFailed;
								goto l33;
							}
							switch (atomicType21) {
							case 0:
								err = FFIErrorAttemptToPassVoid;
								break;
							case 1:
							case 6:
								err = ffiPushUnsignedIntin(intValue11, calloutState);
								break;
							case 2:
								err = ffiPushUnsignedBytein(intValue11, calloutState);
								break;
							case 3:
								err = ffiPushSignedBytein(intValue11, calloutState);
								break;
							case 4:
								err = ffiPushUnsignedShortin(intValue11, calloutState);
								break;
							case 5:
								err = ffiPushSignedShortin(intValue11, calloutState);
								break;
							case 7:
								err = ffiPushSignedIntin(intValue11, calloutState);
								break;
							case 8:
								err = ffiPushUnsignedLongLongOopin(intValue11, calloutState);
								break;
							case 9:
								err = ffiPushSignedLongLongOopin(intValue11, calloutState);
								break;
							case 10:
								err = ffiPushUnsignedCharin(intValue11, calloutState);
								break;
							case 11:
								err = ffiPushSignedCharin(intValue11, calloutState);
								break;

							default:
								error("Case not found");
							}
							goto l33;
						}
						/* begin ffiFloatValueOf: */
						if (isFloatObject(handle4)) {
							floatValue11 = floatValueOf(handle4);
							goto l15;
						}
						floatValue11 = ((double) (ffiIntegerValueOf(handle4)) );
	l15:	/* end ffiFloatValueOf: */;
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						if (atomicType21 == FFITypeSingleFloat) {
							/* begin ffiPushSingleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
								if (((calloutState->backfillFloatRegisterIndex)) > 0) {
									((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue11;
									(calloutState->backfillFloatRegisterIndex = 0);
								}
								else {
									((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue11;
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue11);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						else {
							/* begin ffiPushDoubleFloat:in: */
							if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
								if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
									(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
									(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
								}
								(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue11;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
							}
							else {
								if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								(calloutState->floatRegisterIndex = NumFloatRegArgs);
								storeFloatAtPointerfrom((calloutState->currentArg), floatValue11);
								(calloutState->currentArg = ((calloutState->currentArg)) + 8);
							}
							err = 0;
							goto l33;
						}
					}
					if (!0) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					/* begin ffiArgByValue:in: */
					typeSpec31 = (calloutState->ffiArgHeader);
					atomicType31 = ((usqInt)((typeSpec31 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType31 < 0)
					 || (atomicType31 > FFITypeDoubleFloat)) {
						err = FFIErrorBadAtomicType;
						goto l33;
					}
					if (atomicType31 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType31)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue2 = oop;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (oop & (BytesPerWord - 1)) {
								if (isIntegerObject(oop)) {
									intValue2 = integerValueOf(oop);
									goto l18;
								}
								
#                if SPURVM
								if (isCharacterObject(oop)) {

									/* Immediate in Spur */
									intValue2 = characterValueOf(oop);
									goto l18;
								}
								if (isFloatObject(oop)) {

									/* Immediate in 64-bit Spur */
									intValue2 = floatValueOf(oop);
									goto l18;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(oop)) {
									intValue2 = characterValueOf(oop);
									goto l18;
								}
#                endif /* SPURVM */
								if (isFloatObject(oop)) {
									intValue2 = floatValueOf(oop);
									goto l18;
								}
								if (oop == (nilObject())) {
									intValue2 = 0;
									goto l18;
								}
								if (oop == (falseObject())) {
									intValue2 = 0;
									goto l18;
								}
								if (oop == (trueObject())) {
									intValue2 = 1;
									goto l18;
								}
								if (isLargePositiveIntegerObject(oop)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue2 = positive64BitValueOf(oop);
									goto l18;
#                  else /* BytesPerWord == 8 */
									intValue2 = positive32BitValueOf(oop);
									goto l18;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue2 = signedMachineIntegerValueOf(oop);
	l18:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						switch (atomicType31) {
						case 0:
							err = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err = ffiPushUnsignedIntin(intValue2, calloutState);
							break;
						case 2:
							err = ffiPushUnsignedBytein(intValue2, calloutState);
							break;
						case 3:
							err = ffiPushSignedBytein(intValue2, calloutState);
							break;
						case 4:
							err = ffiPushUnsignedShortin(intValue2, calloutState);
							break;
						case 5:
							err = ffiPushSignedShortin(intValue2, calloutState);
							break;
						case 7:
							err = ffiPushSignedIntin(intValue2, calloutState);
							break;
						case 8:
							err = ffiPushUnsignedLongLongOopin(intValue2, calloutState);
							break;
						case 9:
							err = ffiPushSignedLongLongOopin(intValue2, calloutState);
							break;
						case 10:
							err = ffiPushUnsignedCharin(intValue2, calloutState);
							break;
						case 11:
							err = ffiPushSignedCharin(intValue2, calloutState);
							break;

						default:
							error("Case not found");
						}
						goto l33;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(oop)) {
						floatValue2 = floatValueOf(oop);
						goto l16;
					}
					floatValue2 = ((double) (ffiIntegerValueOf(oop)) );
	l16:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err = FFIErrorCoercionFailed;
						goto l33;
					}
					if (atomicType31 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState->backfillFloatRegisterIndex)) > 0) {
								((calloutState->floatRegisters))[(calloutState->backfillFloatRegisterIndex)] = floatValue2;
								(calloutState->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue2;
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							storeSingleFloatAtPointerfrom((calloutState->currentArg), floatValue2);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState->floatRegisterIndex)) & 1) == 1) {
								(calloutState->backfillFloatRegisterIndex = (calloutState->floatRegisterIndex));
								(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))))[0] = floatValue2;
							(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState->currentArg)) + 8) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							(calloutState->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState->currentArg), floatValue2);
							(calloutState->currentArg = ((calloutState->currentArg)) + 8);
						}
						err = 0;
						goto l33;
					}
					break;
				case FFIFlagAtomic + FFIFlagPointer:
					/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type = fetchPointerofObject(1, oop);
						if (!((isPointers(type))
							 && ((slotSizeOf(type)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass = fetchPointerofObject(1, type);
						if (!(includesBehaviorThatOf(referentClass, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle1 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle1, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				case FFIFlagStructure:
					/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
						handle5 = fetchPointerofObject(0, oop);
						/* begin ffiPushStructureContentsOf:in: */
						ptrClass3 = fetchClassOf(handle5);
						if (ptrClass3 == (classExternalAddress())) {

							/* ExternalAddress is bytes */

							/* There is no way we can make sure the structure is valid.
							   But we can at least check for attempts to pass pointers to ST memory. */
							ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress2)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec3 = (calloutState->ffiArgSpec);
							argSpecSize = (calloutState->ffiArgSpecSize);
							availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize = structSize;
							if (availableRegisterSpace > 0) {
								if (structSize <= availableRegisterSpace) {

									/* all in registers */
									stackPartSize = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize = structSize - availableRegisterSpace;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace);
									}
									else {
										availableRegisterSpace = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize > 0) {
								roundedSize = (((stackPartSize + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace])), stackPartSize);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
							}
							err = 0;
							goto l33;
						}
						if (ptrClass3 == (classByteArray())) {

							/* The following is a somewhat pessimistic test but I like being sure... */
							if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress2 = firstIndexableField(handle5);
							if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

								/* Since this involves passing the address of the first indexable field we need to fail
								   the call if it is threaded and the object is young, since it may move during the call. */
								
#                if COGMTVM
								if ((((calloutState->callFlags)) & FFICallFlagThreaded)
								 && (isYoung(handle5))) {
									err = -PrimErrObjectMayMove;
									goto l33;
								}
#                endif /* COGMTVM */
								/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
								structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
								argSpec1 = (calloutState->ffiArgSpec);
								argSpecSize1 = (calloutState->ffiArgSpecSize);
								availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
								stackPartSize1 = structSize1;
								if (availableRegisterSpace1 > 0) {
									if (structSize1 <= availableRegisterSpace1) {

										/* all in registers */
										stackPartSize1 = 0;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, structSize1);
										(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 3))) >> 2)));
									}
									else {

										/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
										   Otherwise push entire struct on stack. */
										if (((calloutState->currentArg)) == ((calloutState->argVector))) {
											stackPartSize1 = structSize1 - availableRegisterSpace1;
											memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress2, availableRegisterSpace1);
										}
										else {
											availableRegisterSpace1 = 0;
										}
										(calloutState->integerRegisterIndex = NumIntRegArgs);
									}
								}
								if (stackPartSize1 > 0) {
									roundedSize1 = (((stackPartSize1 + 3) | 3) - 3);
									if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
										err = FFIErrorCallFrameTooBig;
										goto l33;
									}
									memcpy((calloutState->currentArg), (&((((char *) ptrAddress2))[availableRegisterSpace1])), stackPartSize1);
									(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
								}
								err = 0;
								goto l33;
							}
							if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress2 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress2)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress2));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), ptrAddress2);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						err = FFIErrorBadArg;
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type3 = fetchPointerofObject(1, oop);
						if (!((isPointers(type3))
							 && ((slotSizeOf(type3)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass3 = fetchPointerofObject(1, type3);
						if (!(includesBehaviorThatOf(referentClass3, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle5 = fetchPointerofObject(0, oop);
						/* begin ffiPushStructureContentsOf:in: */
						ptrClass11 = fetchClassOf(handle5);
						if (ptrClass11 == (classExternalAddress())) {

							/* ExternalAddress is bytes */

							/* There is no way we can make sure the structure is valid.
							   But we can at least check for attempts to pass pointers to ST memory. */
							ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress1)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize2 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
							argSpec2 = (calloutState->ffiArgSpec);
							argSpecSize2 = (calloutState->ffiArgSpecSize);
							availableRegisterSpace2 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
							stackPartSize2 = structSize2;
							if (availableRegisterSpace2 > 0) {
								if (structSize2 <= availableRegisterSpace2) {

									/* all in registers */
									stackPartSize2 = 0;
									memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize2);
									(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize2 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState->currentArg)) == ((calloutState->argVector))) {
										stackPartSize2 = structSize2 - availableRegisterSpace2;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace2);
									}
									else {
										availableRegisterSpace2 = 0;
									}
									(calloutState->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize2 > 0) {
								roundedSize2 = (((stackPartSize2 + 3) | 3) - 3);
								if ((((calloutState->currentArg)) + roundedSize2) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace2])), stackPartSize2);
								(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize2);
							}
							err = 0;
							goto l33;
						}
						if (ptrClass11 == (classByteArray())) {

							/* The following is a somewhat pessimistic test but I like being sure... */
							if (!((byteSizeOf(handle5)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress1 = firstIndexableField(handle5);
							if (!(((calloutState->ffiArgHeader)) & FFIFlagPointer)) {

								/* Since this involves passing the address of the first indexable field we need to fail
								   the call if it is threaded and the object is young, since it may move during the call. */
								
#                if COGMTVM
								if ((((calloutState->callFlags)) & FFICallFlagThreaded)
								 && (isYoung(handle5))) {
									err = -PrimErrObjectMayMove;
									goto l33;
								}
#                endif /* COGMTVM */
								/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
								structSize11 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
								argSpec11 = (calloutState->ffiArgSpec);
								argSpecSize11 = (calloutState->ffiArgSpecSize);
								availableRegisterSpace11 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * 4;
								stackPartSize11 = structSize11;
								if (availableRegisterSpace11 > 0) {
									if (structSize11 <= availableRegisterSpace11) {

										/* all in registers */
										stackPartSize11 = 0;
										memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, structSize11);
										(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize11 + 3))) >> 2)));
									}
									else {

										/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
										   Otherwise push entire struct on stack. */
										if (((calloutState->currentArg)) == ((calloutState->argVector))) {
											stackPartSize11 = structSize11 - availableRegisterSpace11;
											memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress1, availableRegisterSpace11);
										}
										else {
											availableRegisterSpace11 = 0;
										}
										(calloutState->integerRegisterIndex = NumIntRegArgs);
									}
								}
								if (stackPartSize11 > 0) {
									roundedSize11 = (((stackPartSize11 + 3) | 3) - 3);
									if ((((calloutState->currentArg)) + roundedSize11) > ((calloutState->limit))) {
										err = FFIErrorCallFrameTooBig;
										goto l33;
									}
									memcpy((calloutState->currentArg), (&((((char *) ptrAddress1))[availableRegisterSpace11])), stackPartSize11);
									(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize11);
								}
								err = 0;
								goto l33;
							}
							if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
								err = FFIErrorStructSize;
								goto l33;
							}
							ptrAddress1 = ((void *)(fetchPointerofObject(0, handle5)));
							if (isInMemory(ptrAddress1)) {
								err = FFIErrorInvalidPointer;
								goto l33;
							}
							/* begin ffiPushPointer:in: */
							if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
								((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress1));
								(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
							}
							else {
								if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
									err = FFIErrorCallFrameTooBig;
									goto l33;
								}
								longAtput((calloutState->currentArg), ptrAddress1);
								(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
							}
							err = 0;
							goto l33;
						}
						err = FFIErrorBadArg;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				case FFIFlagStructure + FFIFlagPointer:
					/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
					if (includesBehaviorThatOf(oopClass, argClass)) {

						/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
						handle2 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle2, calloutState);
						goto l33;
					}
					if (includesBehaviorThatOf(oopClass, classExternalData())) {

						/* Fetch the type specification and check against expectedClass */
						type1 = fetchPointerofObject(1, oop);
						if (!((isPointers(type1))
							 && ((slotSizeOf(type1)) >= 2))) {
							err = FFIErrorWrongType;
							goto l33;
						}
						referentClass1 = fetchPointerofObject(1, type1);
						if (!(includesBehaviorThatOf(referentClass1, argClass))) {
							err = FFIErrorCoercionFailed;
							goto l33;
						}
						handle2 = fetchPointerofObject(0, oop);
						err = ffiPushPointerContentsOfin(handle2, calloutState);
						goto l33;
					}
					if (oop == (nilObject())) {
						/* begin ffiPushPointer:in: */
						if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
							(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
								err = FFIErrorCallFrameTooBig;
								goto l33;
							}
							longAtput((calloutState->currentArg), null);
							(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
						}
						err = 0;
						goto l33;
					}
					err = FFIErrorCoercionFailed;
					goto l33;
					break;
				default:
					err = FFIErrorWrongType;
					goto l33;

				}
			}
	l33:	/* end ffiArgument:Spec:Class:in: */;
			if (err != 0) {
				/* begin cleanupCalloutState: */
				while (((calloutState->stringArgIndex)) > 0) {
					free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
				}
				
#        if COGMTVM
				if (err == (-PrimErrObjectMayMove)) {
					result = PrimErrObjectMayMove;
					goto l34;
				}
#        endif /* COGMTVM */
				result = ffiFail(err);
				goto l34;
			}
		}
		assert(!(failed()));
		/* begin ffiLogCallout: */
		if (ffiLogEnabled) {
			functionName = fetchPointerofObject(externalFunctionInstSize, externalFunction);
			if (!(isBytes(functionName))) {
				goto l3;
			}
			ffiLogCallOfLength(firstIndexableField(functionName), byteSizeOf(functionName));
		}
	l3:	/* end ffiLogCallout: */;
		if ((requiredStackSize < 0)
		 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
			stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
		}
		/* begin ffiCalloutTo:SpecOnStack:in: */
		myThreadIndex = disownVM(
#    if COGMTVM
			(((calloutState->callFlags)) & FFICallFlagThreaded
						? DisownVMForFFICall + DisownVMForThreading
						: DisownVMForFFICall)
#    else /* COGMTVM */
			DisownVMForFFICall
#    endif /* COGMTVM */
			);
		if (((calloutState->floatRegisterIndex)) > 0) {
			loadFloatRegs((((double *) ((&(((calloutState->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState->floatRegisters))[14])))))[0]);
		}
		if ((allocaLiesSoSetSpBeforeCall())
		 || (mustAlignStack())) {
			setsp((calloutState->argVector));
		}
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
			if (atomicType == FFITypeSingleFloat) {
				floatRet = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
			}
			else {

				/* atomicType = FFITypeDoubleFloat */
				floatRet = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
			}
			if (isCalleePopsConvention((calloutState->callFlags))) {
				setsp((calloutState->argVector));
			}
			ownVM(myThreadIndex);
			result1 = floatObjectOf(floatRet);
			goto l9;
		}

		/* undo any callee argument pops because it may confuse stack management with the alloca. */
		intRet = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3]);
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(myThreadIndex);
		if (((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

			/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
			   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
			if (((calloutState->ffiRetHeader)) & FFIFlagPointer) {
				/* begin ffiReturnPointer:ofType:in: */
				specLiteral = (argArray != null
					? stackValue(1)
					: literalofMethod(0, primitiveMethod()));
				argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
				retType = fetchPointerofObject(0, argTypes);
				retClass2 = fetchPointerofObject(1, retType);
				if (retClass2 == (nilObject())) {

					/* Create ExternalData upon return */
					/* begin atomicTypeOf: */
					typeSpec1 = (calloutState->ffiRetHeader);
					atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

						/* String return */
						/* begin ffiReturnCStringFrom: */
						cPointer = ((usqInt) intRet);
						if (!(cPointer)) {
							retOop = nilObject();
							goto l5;
						}
						cString = ((char *) cPointer);
						strLen = 0;
						while (!((cString[strLen]) == 0)) {
							strLen += 1;
						}
						strOop = instantiateClassindexableSize(classString(), strLen);
						strPtr = firstIndexableField(strOop);
						for (i1 = 0; i1 < strLen; i1 += 1) {
							strPtr[i1] = (cString[i1]);
						}
						retOop = strOop;
	l5:	/* end ffiReturnCStringFrom: */;
						result1 = retOop;
						goto l9;
					}
				}
				
#if SPURVM
				oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop2);
				ptr1[0] = (((sqInt) intRet));
				retOop = instantiateClassindexableSize(classExternalData(), 0);
				storePointerofObjectwithValue(0, retOop, oop2);

#else /* SPURVM */
				pushRemappableOop(retType);
				oop2 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop2);
				ptr1[0] = (((sqInt) intRet));
								pushRemappableOop(oop2);
				retOop = instantiateClassindexableSize(classExternalData(), 0);
				oop2 = popRemappableOop();
				storePointerofObjectwithValue(0, retOop, oop2);
				retType = popRemappableOop()
#endif /* SPURVM */
;
				storePointerofObjectwithValue(1, retOop, retType);
				result1 = retOop;
				goto l9;
			}
			/* begin ffiReturnStruct:ofType:in: */
			longLongRetPtr = (&intRet);
			/* begin ffiReturnType: */
			specLiteral1 = (argArray != null
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
			ffiRetType = fetchPointerofObject(0, argTypes1);
			retClass1 = fetchPointerofObject(1, ffiRetType);
			retOop1 = instantiateClassindexableSize(retClass1, 0);
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));

#else /* SPURVM */
			pushRemappableOop(retOop1);
			oop1 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
			retOop1 = popRemappableOop()
#endif /* SPURVM */
;
			memcpy(firstIndexableField(oop1), ((calloutState->structReturnType)
				? longLongRetPtr
				: (calloutState->limit)), (calloutState->structReturnSize));
			storePointerofObjectwithValue(0, retOop1, oop1);
			result1 = retOop1;
			goto l9;
		}
		/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
		assert(atomicType < FFITypeSingleFloat);
		if (atomicType == FFITypeBool) {

			/* Make sure bool honors the byte size requested */
			byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
			value = (byteSize == (sizeof(intRet))
				? intRet
				: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
			if (value == 0) {
				result1 = falseObject();
			}
			else {
				result1 = trueObject();
			}
			goto l9;
		}
		if (atomicType <= FFITypeSignedInt) {

			/* these are all generall integer returns */
			if (atomicType <= ((BytesPerWord == 8
				? FFITypeSignedInt
				: FFITypeSignedShort))) {

				/* byte/short. first extract partial word, then sign extend */

				/* # of significant bits */
				shift = ((BytesPerWord == 8)
				 && (atomicType >= FFITypeUnsignedInt)
					? 32
					: (((usqInt)(atomicType)) >> 1) * 8);
				value = intRet & (((((unsigned long long)1)) << shift) - 1);
				if (atomicType & 1) {

					/* make the guy signed */
					mask = (((unsigned long long)1)) << (shift - 1);
					value = (value & (mask - 1)) - (value & mask);
				}
				result1 = integerObjectOf(value);
				goto l9;
			}
			if (atomicType & 1) {
				if (BytesPerWord == 8) {
					result1 = signed64BitIntegerFor(intRet);
				}
				else {
					result1 = signed32BitIntegerFor(intRet);
				}
			}
			else {
				if (BytesPerWord == 8) {
					result1 = positive64BitIntegerFor(intRet);
				}
				else {
					result1 = positive32BitIntegerFor(intRet);
				}
			}
			goto l9;
		}
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {
			if (atomicType & 1) {
				result1 = signed64BitIntegerFor(intRet);
			}
			else {
				result1 = positive64BitIntegerFor(intRet);
			}
		}
		else {
			result1 = characterObjectOf(intRet & 0xFF);
		}
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
		if (!(retClass == (nilObject()))) {
			if ((((calloutState->ffiRetHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) == FFIFlagAtomic) {
				
#if SPURVM
				alias = instantiateClassindexableSize(retClass, 0);

#else /* SPURVM */
				pushRemappableOop(result1);
				alias = instantiateClassindexableSize(retClass, 0);
				result1 = popRemappableOop()
#endif /* SPURVM */
;
				storePointerofObjectwithValue(0, alias, result1);
				result1 = alias;
			}
		}
		/* begin cleanupCalloutState: */
		while (((calloutState->stringArgIndex)) > 0) {
			free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
		}
		popthenPush(primNumArgs + 1, result1);
		result = result1;
	l34:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
		if (!((result == PrimErrObjectMayMove)
		 && (((retryCount += 1)) <= (nArgs + 1)))) break;
		tenuringIncrementalGC();
	}
#  else /* COGMTVM */
	externalFunction = stackValue(1);
	argArray = stackValue(0);
	if (!(isArray(argArray))) {
		primitiveFailFor(PrimErrBadArgument);
		return;
	}
	nArgs = slotSizeOf(argArray);
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	primNumArgs1 = methodArgumentCount();
	if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
		ffiFail(FFIErrorNotFunction);
		goto l68;
	}
	flags1 = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (failed()) {
		ffiFail(FFIErrorBadArgs);
		goto l68;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr1 = fetchPointerofObject(0, externalFunction);
	if (!((isBytes(addressPtr1))
		 && ((byteSizeOf(addressPtr1)) == (sizeof(sqInt))))) {
		address11 = ffiFail(FFIErrorBadAddress);
		goto l67;
	}
	address11 = fetchPointerofObject(0, addressPtr1);
	l67:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		address2 = 0;
		goto l65;
	}
	if (address11 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storePointerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, integerObjectOf(-1));
		}
		if ((slotSizeOf(externalFunction)) < 5) {
			address2 = ffiFail(FFIErrorNoModule);
			goto l65;
		}
		address11 = ffiLoadCalloutAddressFrom(externalFunction);
		if (failed()) {
			address2 = 0;
			goto l65;
		}
		ptr2 = firstIndexableField(addressPtr1);
		ptr2[0] = address11;
	}
	address2 = address11;
	l65:	/* end ffiLoadCalloutAddress: */;
	if (failed()) {
		goto l68;
	}

	/* must be array of arg types */
	argTypeArray1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((isArray(argTypeArray1))
		 && ((slotSizeOf(argTypeArray1)) == (nArgs + 1)))) {
		ffiFail(FFIErrorBadArgs);
		goto l68;
	}
	
#  if COGMTVM
	if (!(((flags1 & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags1 & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l68;
	}
#  else /* COGMTVM */

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags1 == FFICallTypeCDecl)
		 || (flags1 == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l68;
	}
#  endif /* COGMTVM */
	if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
		requiredStackSize1 = fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction);
	}
	else {
		requiredStackSize1 = -1;
	}
	if (failed()) {
		primitiveFailFor((argArray == null
			? PrimErrBadMethod
			: PrimErrBadReceiver));
		goto l68;
	}
	stackSize1 = (requiredStackSize1 < 0
		? DefaultMaxStackSize
		: requiredStackSize1);
	calloutState1 = (&theCalloutState1);
	memset(calloutState1, 0, sizeof(CalloutState));
	(calloutState1->callFlags = flags1);
	argType1 = fetchPointerofObject(0, argTypeArray1);
	argSpec4 = fetchPointerofObject(0, argType1);
	retClass3 = fetchPointerofObject(1, argType1);
	if (((err1 = ffiCheckReturnWithin(argSpec4, retClass3, calloutState1))) != 0) {
		ffiFail(err1);
		goto l68;
	}
	allocation1 = alloca((stackSize1 + ((calloutState1->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation1 = ((char *) ((((((usqIntptr_t)allocation1)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState1->argVector = allocation1);
	(calloutState1->currentArg = allocation1);
	(calloutState1->limit = allocation1 + stackSize1);
	if ((((calloutState1->structReturnSize)) > 0)
	 && (1
	 && (!((calloutState1->structReturnType))))) {
		/* begin ffiPushPointer:in: */
		pointer8 = (calloutState1->limit);
		if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer8));
			(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
				err1 = FFIErrorCallFrameTooBig;
				goto l59;
			}
			longAtput((calloutState1->currentArg), pointer8);
			(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
		}
		err1 = 0;
	l59:	/* end ffiPushPointer:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l68;
			}
#      endif /* COGMTVM */
			ffiFail(err1);
			goto l68;
		}
	}
	for (i2 = 1; i2 <= nArgs; i2 += 1) {
		argType1 = fetchPointerofObject(i2, argTypeArray1);
		argSpec4 = fetchPointerofObject(0, argType1);
		argClass1 = fetchPointerofObject(1, argType1);
		oop3 = (argArray == null
			? stackValue(nArgs - i2)
			: fetchPointerofObject(i2 - 1, argArray));
		/* begin ffiArgument:Spec:Class:in: */
		if (!(isWords(argSpec4))) {
			err1 = FFIErrorWrongType;
			goto l40;
		}
		(calloutState1->ffiArgSpecSize = slotSizeOf(argSpec4));
		if (((calloutState1->ffiArgSpecSize)) == 0) {
			err1 = FFIErrorWrongType;
			goto l40;
		}
		(calloutState1->ffiArgSpec = firstIndexableField(argSpec4));
		(calloutState1->ffiArgHeader = longAt((calloutState1->ffiArgSpec)));

		/* Prefetch class (we'll need it) */
		oopClass1 = fetchClassOf(oop3);
		nilOop1 = nilObject();
		if (nilOop1 == argClass1) {
			
			switch (((calloutState1->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:In: */
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check: we handle pointer to an atomic type */
					/* begin atomicTypeOf: */
					typeSpec32 = (calloutState1->ffiArgHeader);
					atomicType32 = ((usqInt)((typeSpec32 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType11 = fetchPointerofObject(1, oop3);
					if (!((isPointers(ptrType11))
						 && ((slotSizeOf(ptrType11)) >= 2))) {
						goto l64;
					}
					specOop11 = fetchPointerofObject(0, ptrType11);
					if (!((isWords(specOop11))
						 && ((slotSizeOf(specOop11)) > 0))) {
						goto l64;
					}
					spec11 = fetchPointerofObject(0, specOop11);
					if (!(spec11 & FFIFlagAtomic)) {
						goto l64;
					}
					/* begin atomicTypeOf: */
					specType11 = ((usqInt)((spec11 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (specType11 != atomicType32) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType32 >= FFITypeUnsignedByte)
							 && ((atomicType32 <= FFITypeSignedChar)
							 && ((((usqInt)(atomicType32)) >> 1) == (((usqInt)(specType11)) >> 1))))) {
							goto l64;
						}
					}
	l64:	/* end ffiValidateExternalData:AtomicType: */;
					if (failed()) {
						err1 = null;
						goto l40;
					}
					handle31 = fetchPointerofObject(0, oop3);
					ptrClass12 = fetchClassOf(handle31);
					if (ptrClass12 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer51 = fetchPointerofObject(0, handle31);
						if (isInMemory(pointer51)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
					}
					else {
						if (ptrClass12 == (classByteArray())) {
							pointer51 = ((void *) (firstIndexableField(handle31)));
						}
						else {
							err1 = FFIErrorBadArg;
							goto l40;
						}
					}
					switch (atomicType32) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushDereferenceUnsignedIntin(pointer51, calloutState1);
						break;
					case 2:
						err1 = ffiPushDereferenceUnsignedBytein(pointer51, calloutState1);
						break;
					case 3:
						err1 = ffiPushDereferenceSignedBytein(pointer51, calloutState1);
						break;
					case 4:
						err1 = ffiPushDereferenceUnsignedShortin(pointer51, calloutState1);
						break;
					case 5:
						err1 = ffiPushDereferenceSignedShortin(pointer51, calloutState1);
						break;
					case 7:
						err1 = ffiPushDereferenceSignedIntin(pointer51, calloutState1);
						break;
					case 8:
						err1 = ffiPushDereferenceUnsignedLongLongin(pointer51, calloutState1);
						break;
					case 9:
						err1 = ffiPushDereferenceSignedLongLongin(pointer51, calloutState1);
						break;
					case 10:
						err1 = ffiPushDereferenceUnsignedCharin(pointer51, calloutState1);
						break;
					case 11:
						err1 = ffiPushDereferenceSignedCharin(pointer51, calloutState1);
						break;
					case 12:
						err1 = ffiPushDereferenceSingleFloatin(pointer51, calloutState1);
						break;
					case 13:
						err1 = ffiPushDereferenceDoubleFloatin(pointer51, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle31 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec121 = (calloutState1->ffiArgHeader);
					atomicType121 = ((usqInt)((typeSpec121 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType121 < 0)
					 || (atomicType121 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType121 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType121)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue4 = handle31;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle31 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle31)) {
									intValue4 = integerValueOf(handle31);
									goto l35;
								}
								
#                if SPURVM
								if (isCharacterObject(handle31)) {

									/* Immediate in Spur */
									intValue4 = characterValueOf(handle31);
									goto l35;
								}
								if (isFloatObject(handle31)) {

									/* Immediate in 64-bit Spur */
									intValue4 = floatValueOf(handle31);
									goto l35;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle31)) {
									intValue4 = characterValueOf(handle31);
									goto l35;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle31)) {
									intValue4 = floatValueOf(handle31);
									goto l35;
								}
								if (handle31 == (nilObject())) {
									intValue4 = 0;
									goto l35;
								}
								if (handle31 == (falseObject())) {
									intValue4 = 0;
									goto l35;
								}
								if (handle31 == (trueObject())) {
									intValue4 = 1;
									goto l35;
								}
								if (isLargePositiveIntegerObject(handle31)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue4 = positive64BitValueOf(handle31);
									goto l35;
#                  else /* BytesPerWord == 8 */
									intValue4 = positive32BitValueOf(handle31);
									goto l35;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue4 = signedMachineIntegerValueOf(handle31);
	l35:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType121) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue4, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue4, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue4, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue4, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue4, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue4, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue4, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue4, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue4, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue4, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle31)) {
						floatValue4 = floatValueOf(handle31);
						goto l44;
					}
					floatValue4 = ((double) (ffiIntegerValueOf(handle31)) );
	l44:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType121 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue4;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue4;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue4);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue4;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue4);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				/* begin ffiArgByValue:in: */
				typeSpec22 = (calloutState1->ffiArgHeader);
				atomicType22 = ((usqInt)((typeSpec22 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType22 < 0)
				 || (atomicType22 > FFITypeDoubleFloat)) {
					err1 = FFIErrorBadAtomicType;
					goto l40;
				}
				if (atomicType22 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType22)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue12 = oop3;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop3 & (BytesPerWord - 1)) {
							if (isIntegerObject(oop3)) {
								intValue12 = integerValueOf(oop3);
								goto l51;
							}
							
#              if SPURVM
							if (isCharacterObject(oop3)) {

								/* Immediate in Spur */
								intValue12 = characterValueOf(oop3);
								goto l51;
							}
							if (isFloatObject(oop3)) {

								/* Immediate in 64-bit Spur */
								intValue12 = floatValueOf(oop3);
								goto l51;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop3)) {
								intValue12 = characterValueOf(oop3);
								goto l51;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop3)) {
								intValue12 = floatValueOf(oop3);
								goto l51;
							}
							if (oop3 == (nilObject())) {
								intValue12 = 0;
								goto l51;
							}
							if (oop3 == (falseObject())) {
								intValue12 = 0;
								goto l51;
							}
							if (oop3 == (trueObject())) {
								intValue12 = 1;
								goto l51;
							}
							if (isLargePositiveIntegerObject(oop3)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue12 = positive64BitValueOf(oop3);
								goto l51;
#                else /* BytesPerWord == 8 */
								intValue12 = positive32BitValueOf(oop3);
								goto l51;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue12 = signedMachineIntegerValueOf(oop3);
	l51:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					switch (atomicType22) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushUnsignedIntin(intValue12, calloutState1);
						break;
					case 2:
						err1 = ffiPushUnsignedBytein(intValue12, calloutState1);
						break;
					case 3:
						err1 = ffiPushSignedBytein(intValue12, calloutState1);
						break;
					case 4:
						err1 = ffiPushUnsignedShortin(intValue12, calloutState1);
						break;
					case 5:
						err1 = ffiPushSignedShortin(intValue12, calloutState1);
						break;
					case 7:
						err1 = ffiPushSignedIntin(intValue12, calloutState1);
						break;
					case 8:
						err1 = ffiPushUnsignedLongLongOopin(intValue12, calloutState1);
						break;
					case 9:
						err1 = ffiPushSignedLongLongOopin(intValue12, calloutState1);
						break;
					case 10:
						err1 = ffiPushUnsignedCharin(intValue12, calloutState1);
						break;
					case 11:
						err1 = ffiPushSignedCharin(intValue12, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop3)) {
					floatValue12 = floatValueOf(oop3);
					goto l54;
				}
				floatValue12 = ((double) (ffiIntegerValueOf(oop3)) );
	l54:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				if (atomicType22 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
							((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue12;
							(calloutState1->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue12;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue12);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
							(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue12;
						(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						(calloutState1->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState1->currentArg), floatValue12);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
					}
					err1 = 0;
					goto l40;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:In: */
				typeSpec51 = (calloutState1->ffiArgHeader);
				atomicType51 = ((usqInt)((typeSpec51 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Check: we handle pointer to an atomic type */
					/* no type checks for void pointers */
					if (atomicType51 != FFITypeVoid) {
						/* begin ffiValidateExternalData:AtomicType: */
						ptrType2 = fetchPointerofObject(1, oop3);
						if (!((isPointers(ptrType2))
							 && ((slotSizeOf(ptrType2)) >= 2))) {
							goto l38;
						}
						specOop2 = fetchPointerofObject(0, ptrType2);
						if (!((isWords(specOop2))
							 && ((slotSizeOf(specOop2)) > 0))) {
							goto l38;
						}
						spec2 = fetchPointerofObject(0, specOop2);
						if (!(spec2 & FFIFlagAtomic)) {
							goto l38;
						}
						/* begin atomicTypeOf: */
						specType2 = ((usqInt)((spec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
						if (specType2 != atomicType51) {

							/* Allow for signed/unsigned conversion but nothing else.
							   See FFIConstants class>>#initializeTypeConstants */
							if (!((atomicType51 >= FFITypeUnsignedByte)
								 && ((atomicType51 <= FFITypeSignedChar)
								 && ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(specType2)) >> 1))))) {
								goto l38;
							}
						}
	l38:	/* end ffiValidateExternalData:AtomicType: */;
					}
					if (failed()) {
						err1 = null;
						goto l40;
					}
					handle6 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle6, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* note: the only types allowed for passing into char* types are
					   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
					   (e.g., CompiledMethod, LargeInteger). We only check for strings
					   here and fall through to the byte* check otherwise. */
					if (includesBehaviorThatOf(oopClass1, classString())) {
						/* begin ffiPushString:OfLength:in: */
						pointer71 = ((char *) (firstIndexableField(oop3)));
						length1 = byteSizeOf(oop3);
						if (((calloutState1->stringArgIndex)) >= MaxNumArgs) {
							err1 = -PrimErrBadNumArgs;
							goto l40;
						}
						copy1 = malloc(length1 + 1);
						if (copy1 == null) {
							err1 = -PrimErrNoCMemory;
							goto l40;
						}
						memcpy(copy1, pointer71, length1);
						copy1[length1] = 0;
						((calloutState1->stringArgs))[(calloutState1->stringArgIndex)] = copy1;
						(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) + 1);
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)copy1));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), copy1);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					atomicType51 = FFITypeUnsignedByte;
				}
				ptrClass4 = fetchClassOf(oop3);
				if (ptrClass4 == (classExternalAddress())) {

					/* Don't you dare to pass pointers into object memory */
					ptrAddress3 = ((void *)(fetchPointerofObject(0, oop3)));
					if (isInMemory(ptrAddress3)) {
						err1 = FFIErrorInvalidPointer;
						goto l40;
					}
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress3));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), ptrAddress3);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if (includesBehaviorThatOf(ptrClass4, classAlien())) {
					
#          if COGMTVM
					if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
					 && (((assert(isAlien(oop3)),
					(longAt(oop3 + BaseHeaderSize)) > 0))
					 && (isYoung(oop3)))) {
						err1 = -PrimErrObjectMayMove;
						goto l40;
					}
#          endif /* COGMTVM */
					ptrAddress3 = ((longAt(oop3 + BaseHeaderSize)) > 0
						? (oop3 + BaseHeaderSize) + BytesPerOop
						: longAt((oop3 + BaseHeaderSize) + BytesPerOop));
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress3));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), ptrAddress3);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				
#        if COGMTVM

				/* Since all the following pass the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
				if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
				 && (isYoung(oop3))) {
					err1 = -PrimErrObjectMayMove;
					goto l40;
				}
#        endif /* COGMTVM */
				if ((ptrClass4 == (classByteArray()))
				 && ((atomicType51 == FFITypeVoid)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedByte)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer11 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer11));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer11);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isShorts(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedShort)) >> 1)))) {
					/* begin ffiPushPointer:in: */
					pointer21 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer21));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isWords(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((atomicType51 == FFITypeSingleFloat)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedInt)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer31 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer31));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer31);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				if ((isLong64s(oop3))
				 && ((atomicType51 == FFITypeVoid)
				 || ((atomicType51 == FFITypeDoubleFloat)
				 || ((((usqInt)(atomicType51)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1))))) {
					/* begin ffiPushPointer:in: */
					pointer41 = ((void *) (firstIndexableField(oop3)));
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)pointer41));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), pointer41);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			default:
				err1 = FFIErrorWrongType;
				goto l40;

			}
		}
		else {

			/* If specified, the required class of the argument shall be subclass of ExternalStructure */
			if (!(includesBehaviorThatOf(argClass1, classExternalStructure()))) {
				err1 = FFIErrorWrongType;
				goto l40;
			}
			
			switch (((calloutState1->ffiArgHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) {
			case FFIFlagAtomic:
				/* begin ffiPassAtomicArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle41 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec111 = (calloutState1->ffiArgHeader);
					atomicType111 = ((usqInt)((typeSpec111 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType111 < 0)
					 || (atomicType111 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType111 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType111)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue31 = handle41;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle41 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle41)) {
									intValue31 = integerValueOf(handle41);
									goto l55;
								}
								
#                if SPURVM
								if (isCharacterObject(handle41)) {

									/* Immediate in Spur */
									intValue31 = characterValueOf(handle41);
									goto l55;
								}
								if (isFloatObject(handle41)) {

									/* Immediate in 64-bit Spur */
									intValue31 = floatValueOf(handle41);
									goto l55;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle41)) {
									intValue31 = characterValueOf(handle41);
									goto l55;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle41)) {
									intValue31 = floatValueOf(handle41);
									goto l55;
								}
								if (handle41 == (nilObject())) {
									intValue31 = 0;
									goto l55;
								}
								if (handle41 == (falseObject())) {
									intValue31 = 0;
									goto l55;
								}
								if (handle41 == (trueObject())) {
									intValue31 = 1;
									goto l55;
								}
								if (isLargePositiveIntegerObject(handle41)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue31 = positive64BitValueOf(handle41);
									goto l55;
#                  else /* BytesPerWord == 8 */
									intValue31 = positive32BitValueOf(handle41);
									goto l55;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue31 = signedMachineIntegerValueOf(handle41);
	l55:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType111) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue31, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue31, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue31, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue31, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue31, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue31, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue31, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue31, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue31, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue31, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle41)) {
						floatValue31 = floatValueOf(handle41);
						goto l43;
					}
					floatValue31 = ((double) (ffiIntegerValueOf(handle41)) );
	l43:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType111 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue31;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue31;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue31);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue31;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue31);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type21 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type21))
						 && ((slotSizeOf(type21)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass21 = fetchPointerofObject(1, type21);
					if (!(includesBehaviorThatOf(referentClass21, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle41 = fetchPointerofObject(0, oop3);
					ptrClass21 = fetchClassOf(handle41);
					if (ptrClass21 == (classExternalAddress())) {

						/* Don't you dare to pass pointers into object memory */
						pointer61 = fetchPointerofObject(0, handle41);
						if (isInMemory(pointer61)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
					}
					else {
						if (ptrClass21 == (classByteArray())) {
							pointer61 = ((void *) (firstIndexableField(handle41)));
						}
						else {
							err1 = FFIErrorBadArg;
							goto l40;
						}
					}
					/* begin atomicTypeOf: */
					typeSpec41 = (calloutState1->ffiArgHeader);
					atomicType41 = ((usqInt)((typeSpec41 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					switch (atomicType41) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushDereferenceUnsignedIntin(pointer61, calloutState1);
						break;
					case 2:
						err1 = ffiPushDereferenceUnsignedBytein(pointer61, calloutState1);
						break;
					case 3:
						err1 = ffiPushDereferenceSignedBytein(pointer61, calloutState1);
						break;
					case 4:
						err1 = ffiPushDereferenceUnsignedShortin(pointer61, calloutState1);
						break;
					case 5:
						err1 = ffiPushDereferenceSignedShortin(pointer61, calloutState1);
						break;
					case 7:
						err1 = ffiPushDereferenceSignedIntin(pointer61, calloutState1);
						break;
					case 8:
						err1 = ffiPushDereferenceUnsignedLongLongin(pointer61, calloutState1);
						break;
					case 9:
						err1 = ffiPushDereferenceSignedLongLongin(pointer61, calloutState1);
						break;
					case 10:
						err1 = ffiPushDereferenceUnsignedCharin(pointer61, calloutState1);
						break;
					case 11:
						err1 = ffiPushDereferenceSignedCharin(pointer61, calloutState1);
						break;
					case 12:
						err1 = ffiPushDereferenceSingleFloatin(pointer61, calloutState1);
						break;
					case 13:
						err1 = ffiPushDereferenceDoubleFloatin(pointer61, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalStructure())) {

					/* We do not have any type specification easily available.
					   ExternalTypeAlias are wrapper around the handle, so just pass the handle */
					handle41 = fetchPointerofObject(0, oop3);
					/* begin ffiArgByValue:in: */
					typeSpec211 = (calloutState1->ffiArgHeader);
					atomicType211 = ((usqInt)((typeSpec211 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if ((atomicType211 < 0)
					 || (atomicType211 > FFITypeDoubleFloat)) {
						err1 = FFIErrorBadAtomicType;
						goto l40;
					}
					if (atomicType211 < FFITypeSingleFloat) {

						/* integer types */
						if ((((usqInt)(atomicType211)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

							/* ffi support code must coerce longlong */
							intValue111 = handle41;
						}
						else {
							/* begin ffiIntegerValueOf: */
							if (handle41 & (BytesPerWord - 1)) {
								if (isIntegerObject(handle41)) {
									intValue111 = integerValueOf(handle41);
									goto l58;
								}
								
#                if SPURVM
								if (isCharacterObject(handle41)) {

									/* Immediate in Spur */
									intValue111 = characterValueOf(handle41);
									goto l58;
								}
								if (isFloatObject(handle41)) {

									/* Immediate in 64-bit Spur */
									intValue111 = floatValueOf(handle41);
									goto l58;
								}
#                endif /* SPURVM */
							}
							else {
								
#                if SPURVM

								/* No non-immediate characters in Spur */
#                else /* SPURVM */
								if (isCharacterObject(handle41)) {
									intValue111 = characterValueOf(handle41);
									goto l58;
								}
#                endif /* SPURVM */
								if (isFloatObject(handle41)) {
									intValue111 = floatValueOf(handle41);
									goto l58;
								}
								if (handle41 == (nilObject())) {
									intValue111 = 0;
									goto l58;
								}
								if (handle41 == (falseObject())) {
									intValue111 = 0;
									goto l58;
								}
								if (handle41 == (trueObject())) {
									intValue111 = 1;
									goto l58;
								}
								if (isLargePositiveIntegerObject(handle41)) {
									
#                  if BytesPerWord == 8

									/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
									intValue111 = positive64BitValueOf(handle41);
									goto l58;
#                  else /* BytesPerWord == 8 */
									intValue111 = positive32BitValueOf(handle41);
									goto l58;
#                  endif /* BytesPerWord == 8 */
								}
							}
							intValue111 = signedMachineIntegerValueOf(handle41);
	l58:	/* end ffiIntegerValueOf: */;
						}
						if (failed()) {
							err1 = FFIErrorCoercionFailed;
							goto l40;
						}
						switch (atomicType211) {
						case 0:
							err1 = FFIErrorAttemptToPassVoid;
							break;
						case 1:
						case 6:
							err1 = ffiPushUnsignedIntin(intValue111, calloutState1);
							break;
						case 2:
							err1 = ffiPushUnsignedBytein(intValue111, calloutState1);
							break;
						case 3:
							err1 = ffiPushSignedBytein(intValue111, calloutState1);
							break;
						case 4:
							err1 = ffiPushUnsignedShortin(intValue111, calloutState1);
							break;
						case 5:
							err1 = ffiPushSignedShortin(intValue111, calloutState1);
							break;
						case 7:
							err1 = ffiPushSignedIntin(intValue111, calloutState1);
							break;
						case 8:
							err1 = ffiPushUnsignedLongLongOopin(intValue111, calloutState1);
							break;
						case 9:
							err1 = ffiPushSignedLongLongOopin(intValue111, calloutState1);
							break;
						case 10:
							err1 = ffiPushUnsignedCharin(intValue111, calloutState1);
							break;
						case 11:
							err1 = ffiPushSignedCharin(intValue111, calloutState1);
							break;

						default:
							error("Case not found");
						}
						goto l40;
					}
					/* begin ffiFloatValueOf: */
					if (isFloatObject(handle41)) {
						floatValue111 = floatValueOf(handle41);
						goto l52;
					}
					floatValue111 = ((double) (ffiIntegerValueOf(handle41)) );
	l52:	/* end ffiFloatValueOf: */;
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					if (atomicType211 == FFITypeSingleFloat) {
						/* begin ffiPushSingleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
							if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
								((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue111;
								(calloutState1->backfillFloatRegisterIndex = 0);
							}
							else {
								((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue111;
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue111);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					else {
						/* begin ffiPushDoubleFloat:in: */
						if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
							if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
								(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
								(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
							}
							(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue111;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
						}
						else {
							if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							(calloutState1->floatRegisterIndex = NumFloatRegArgs);
							storeFloatAtPointerfrom((calloutState1->currentArg), floatValue111);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
						}
						err1 = 0;
						goto l40;
					}
				}
				if (!0) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				/* begin ffiArgByValue:in: */
				typeSpec311 = (calloutState1->ffiArgHeader);
				atomicType311 = ((usqInt)((typeSpec311 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((atomicType311 < 0)
				 || (atomicType311 > FFITypeDoubleFloat)) {
					err1 = FFIErrorBadAtomicType;
					goto l40;
				}
				if (atomicType311 < FFITypeSingleFloat) {

					/* integer types */
					if ((((usqInt)(atomicType311)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {

						/* ffi support code must coerce longlong */
						intValue21 = oop3;
					}
					else {
						/* begin ffiIntegerValueOf: */
						if (oop3 & (BytesPerWord - 1)) {
							if (isIntegerObject(oop3)) {
								intValue21 = integerValueOf(oop3);
								goto l39;
							}
							
#              if SPURVM
							if (isCharacterObject(oop3)) {

								/* Immediate in Spur */
								intValue21 = characterValueOf(oop3);
								goto l39;
							}
							if (isFloatObject(oop3)) {

								/* Immediate in 64-bit Spur */
								intValue21 = floatValueOf(oop3);
								goto l39;
							}
#              endif /* SPURVM */
						}
						else {
							
#              if SPURVM

							/* No non-immediate characters in Spur */
#              else /* SPURVM */
							if (isCharacterObject(oop3)) {
								intValue21 = characterValueOf(oop3);
								goto l39;
							}
#              endif /* SPURVM */
							if (isFloatObject(oop3)) {
								intValue21 = floatValueOf(oop3);
								goto l39;
							}
							if (oop3 == (nilObject())) {
								intValue21 = 0;
								goto l39;
							}
							if (oop3 == (falseObject())) {
								intValue21 = 0;
								goto l39;
							}
							if (oop3 == (trueObject())) {
								intValue21 = 1;
								goto l39;
							}
							if (isLargePositiveIntegerObject(oop3)) {
								
#                if BytesPerWord == 8

								/* Use cppIf: to get the return type of the function right.  Should be sqInt on 32-bits. */
								intValue21 = positive64BitValueOf(oop3);
								goto l39;
#                else /* BytesPerWord == 8 */
								intValue21 = positive32BitValueOf(oop3);
								goto l39;
#                endif /* BytesPerWord == 8 */
							}
						}
						intValue21 = signedMachineIntegerValueOf(oop3);
	l39:	/* end ffiIntegerValueOf: */;
					}
					if (failed()) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					switch (atomicType311) {
					case 0:
						err1 = FFIErrorAttemptToPassVoid;
						break;
					case 1:
					case 6:
						err1 = ffiPushUnsignedIntin(intValue21, calloutState1);
						break;
					case 2:
						err1 = ffiPushUnsignedBytein(intValue21, calloutState1);
						break;
					case 3:
						err1 = ffiPushSignedBytein(intValue21, calloutState1);
						break;
					case 4:
						err1 = ffiPushUnsignedShortin(intValue21, calloutState1);
						break;
					case 5:
						err1 = ffiPushSignedShortin(intValue21, calloutState1);
						break;
					case 7:
						err1 = ffiPushSignedIntin(intValue21, calloutState1);
						break;
					case 8:
						err1 = ffiPushUnsignedLongLongOopin(intValue21, calloutState1);
						break;
					case 9:
						err1 = ffiPushSignedLongLongOopin(intValue21, calloutState1);
						break;
					case 10:
						err1 = ffiPushUnsignedCharin(intValue21, calloutState1);
						break;
					case 11:
						err1 = ffiPushSignedCharin(intValue21, calloutState1);
						break;

					default:
						error("Case not found");
					}
					goto l40;
				}
				/* begin ffiFloatValueOf: */
				if (isFloatObject(oop3)) {
					floatValue21 = floatValueOf(oop3);
					goto l48;
				}
				floatValue21 = ((double) (ffiIntegerValueOf(oop3)) );
	l48:	/* end ffiFloatValueOf: */;
				if (failed()) {
					err1 = FFIErrorCoercionFailed;
					goto l40;
				}
				if (atomicType311 == FFITypeSingleFloat) {
					/* begin ffiPushSingleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < NumFloatRegArgs) {
						if (((calloutState1->backfillFloatRegisterIndex)) > 0) {
							((calloutState1->floatRegisters))[(calloutState1->backfillFloatRegisterIndex)] = floatValue21;
							(calloutState1->backfillFloatRegisterIndex = 0);
						}
						else {
							((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)] = floatValue21;
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						storeSingleFloatAtPointerfrom((calloutState1->currentArg), floatValue21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				else {
					/* begin ffiPushDoubleFloat:in: */
					if (((calloutState1->floatRegisterIndex)) < (NumFloatRegArgs - 1)) {
						if ((((calloutState1->floatRegisterIndex)) & 1) == 1) {
							(calloutState1->backfillFloatRegisterIndex = (calloutState1->floatRegisterIndex));
							(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 1);
						}
						(((double*) ((&(((calloutState1->floatRegisters))[(calloutState1->floatRegisterIndex)])))))[0] = floatValue21;
						(calloutState1->floatRegisterIndex = ((calloutState1->floatRegisterIndex)) + 2);
					}
					else {
						if ((((calloutState1->currentArg)) + 8) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						(calloutState1->floatRegisterIndex = NumFloatRegArgs);
						storeFloatAtPointerfrom((calloutState1->currentArg), floatValue21);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + 8);
					}
					err1 = 0;
					goto l40;
				}
				break;
			case FFIFlagAtomic + FFIFlagPointer:
				/* begin ffiPassAtomicArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type4 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type4))
						 && ((slotSizeOf(type4)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass4 = fetchPointerofObject(1, type4);
					if (!(includesBehaviorThatOf(referentClass4, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle11 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle11, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			case FFIFlagStructure:
				/* begin ffiPassStructureArgumentByValue:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* We passed an object of the expectedClass (or a subclass of it) - pass its handle by value */
					handle51 = fetchPointerofObject(0, oop3);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass31 = fetchClassOf(handle51);
					if (ptrClass31 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress21 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress21)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize3 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
						argSpec31 = (calloutState1->ffiArgSpec);
						argSpecSize3 = (calloutState1->ffiArgSpecSize);
						availableRegisterSpace3 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
						stackPartSize3 = structSize3;
						if (availableRegisterSpace3 > 0) {
							if (structSize3 <= availableRegisterSpace3) {

								/* all in registers */
								stackPartSize3 = 0;
								memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, structSize3);
								(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize3 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
									stackPartSize3 = structSize3 - availableRegisterSpace3;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, availableRegisterSpace3);
								}
								else {
									availableRegisterSpace3 = 0;
								}
								(calloutState1->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize3 > 0) {
							roundedSize3 = (((stackPartSize3 + 3) | 3) - 3);
							if ((((calloutState1->currentArg)) + roundedSize3) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							memcpy((calloutState1->currentArg), (&((((char *) ptrAddress21))[availableRegisterSpace3])), stackPartSize3);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize3);
						}
						err1 = 0;
						goto l40;
					}
					if (ptrClass31 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle51)) == (((calloutState1->ffiArgHeader)) & FFIStructSizeMask))) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress21 = firstIndexableField(handle51);
						if (!(((calloutState1->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle51))) {
								err1 = -PrimErrObjectMayMove;
								goto l40;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize12 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
							argSpec12 = (calloutState1->ffiArgSpec);
							argSpecSize12 = (calloutState1->ffiArgSpecSize);
							availableRegisterSpace12 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
							stackPartSize12 = structSize12;
							if (availableRegisterSpace12 > 0) {
								if (structSize12 <= availableRegisterSpace12) {

									/* all in registers */
									stackPartSize12 = 0;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, structSize12);
									(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize12 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
										stackPartSize12 = structSize12 - availableRegisterSpace12;
										memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress21, availableRegisterSpace12);
									}
									else {
										availableRegisterSpace12 = 0;
									}
									(calloutState1->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize12 > 0) {
								roundedSize12 = (((stackPartSize12 + 3) | 3) - 3);
								if ((((calloutState1->currentArg)) + roundedSize12) > ((calloutState1->limit))) {
									err1 = FFIErrorCallFrameTooBig;
									goto l40;
								}
								memcpy((calloutState1->currentArg), (&((((char *) ptrAddress21))[availableRegisterSpace12])), stackPartSize12);
								(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize12);
							}
							err1 = 0;
							goto l40;
						}
						if (!((((calloutState1->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress21 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress21)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress21));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), ptrAddress21);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					err1 = FFIErrorBadArg;
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type31 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type31))
						 && ((slotSizeOf(type31)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass31 = fetchPointerofObject(1, type31);
					if (!(includesBehaviorThatOf(referentClass31, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle51 = fetchPointerofObject(0, oop3);
					/* begin ffiPushStructureContentsOf:in: */
					ptrClass111 = fetchClassOf(handle51);
					if (ptrClass111 == (classExternalAddress())) {

						/* ExternalAddress is bytes */

						/* There is no way we can make sure the structure is valid.
						   But we can at least check for attempts to pass pointers to ST memory. */
						ptrAddress11 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress11)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
						structSize21 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
						argSpec21 = (calloutState1->ffiArgSpec);
						argSpecSize21 = (calloutState1->ffiArgSpecSize);
						availableRegisterSpace21 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
						stackPartSize21 = structSize21;
						if (availableRegisterSpace21 > 0) {
							if (structSize21 <= availableRegisterSpace21) {

								/* all in registers */
								stackPartSize21 = 0;
								memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, structSize21);
								(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize21 + 3))) >> 2)));
							}
							else {

								/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
								   Otherwise push entire struct on stack. */
								if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
									stackPartSize21 = structSize21 - availableRegisterSpace21;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, availableRegisterSpace21);
								}
								else {
									availableRegisterSpace21 = 0;
								}
								(calloutState1->integerRegisterIndex = NumIntRegArgs);
							}
						}
						if (stackPartSize21 > 0) {
							roundedSize21 = (((stackPartSize21 + 3) | 3) - 3);
							if ((((calloutState1->currentArg)) + roundedSize21) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							memcpy((calloutState1->currentArg), (&((((char *) ptrAddress11))[availableRegisterSpace21])), stackPartSize21);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize21);
						}
						err1 = 0;
						goto l40;
					}
					if (ptrClass111 == (classByteArray())) {

						/* The following is a somewhat pessimistic test but I like being sure... */
						if (!((byteSizeOf(handle51)) == (((calloutState1->ffiArgHeader)) & FFIStructSizeMask))) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress11 = firstIndexableField(handle51);
						if (!(((calloutState1->ffiArgHeader)) & FFIFlagPointer)) {

							/* Since this involves passing the address of the first indexable field we need to fail
							   the call if it is threaded and the object is young, since it may move during the call. */
							
#              if COGMTVM
							if ((((calloutState1->callFlags)) & FFICallFlagThreaded)
							 && (isYoung(handle51))) {
								err1 = -PrimErrObjectMayMove;
								goto l40;
							}
#              endif /* COGMTVM */
							/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
							structSize111 = ((calloutState1->ffiArgHeader)) & FFIStructSizeMask;
							argSpec111 = (calloutState1->ffiArgSpec);
							argSpecSize111 = (calloutState1->ffiArgSpecSize);
							availableRegisterSpace111 = (NumIntRegArgs - ((calloutState1->integerRegisterIndex))) * 4;
							stackPartSize111 = structSize111;
							if (availableRegisterSpace111 > 0) {
								if (structSize111 <= availableRegisterSpace111) {

									/* all in registers */
									stackPartSize111 = 0;
									memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, structSize111);
									(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + ((((usqInt)((structSize111 + 3))) >> 2)));
								}
								else {

									/* If no previous co-processor candidate arg has already been pushed on the stack, then split the struct between registers and stack.
									   Otherwise push entire struct on stack. */
									if (((calloutState1->currentArg)) == ((calloutState1->argVector))) {
										stackPartSize111 = structSize111 - availableRegisterSpace111;
										memcpy(((void *) ((&(((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)])))), ptrAddress11, availableRegisterSpace111);
									}
									else {
										availableRegisterSpace111 = 0;
									}
									(calloutState1->integerRegisterIndex = NumIntRegArgs);
								}
							}
							if (stackPartSize111 > 0) {
								roundedSize111 = (((stackPartSize111 + 3) | 3) - 3);
								if ((((calloutState1->currentArg)) + roundedSize111) > ((calloutState1->limit))) {
									err1 = FFIErrorCallFrameTooBig;
									goto l40;
								}
								memcpy((calloutState1->currentArg), (&((((char *) ptrAddress11))[availableRegisterSpace111])), stackPartSize111);
								(calloutState1->currentArg = ((calloutState1->currentArg)) + roundedSize111);
							}
							err1 = 0;
							goto l40;
						}
						if (!((((calloutState1->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
							err1 = FFIErrorStructSize;
							goto l40;
						}
						ptrAddress11 = ((void *)(fetchPointerofObject(0, handle51)));
						if (isInMemory(ptrAddress11)) {
							err1 = FFIErrorInvalidPointer;
							goto l40;
						}
						/* begin ffiPushPointer:in: */
						if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
							((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)ptrAddress11));
							(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
						}
						else {
							if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
								err1 = FFIErrorCallFrameTooBig;
								goto l40;
							}
							longAtput((calloutState1->currentArg), ptrAddress11);
							(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
						}
						err1 = 0;
						goto l40;
					}
					err1 = FFIErrorBadArg;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			case FFIFlagStructure + FFIFlagPointer:
				/* begin ffiPassStructureArgumentByReference:Class:expectedClass:In: */
				if (includesBehaviorThatOf(oopClass1, argClass1)) {

					/* Get the handle, retrieve the address to which it points, and pass it as a pointer */
					handle21 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle21, calloutState1);
					goto l40;
				}
				if (includesBehaviorThatOf(oopClass1, classExternalData())) {

					/* Fetch the type specification and check against expectedClass */
					type11 = fetchPointerofObject(1, oop3);
					if (!((isPointers(type11))
						 && ((slotSizeOf(type11)) >= 2))) {
						err1 = FFIErrorWrongType;
						goto l40;
					}
					referentClass11 = fetchPointerofObject(1, type11);
					if (!(includesBehaviorThatOf(referentClass11, argClass1))) {
						err1 = FFIErrorCoercionFailed;
						goto l40;
					}
					handle21 = fetchPointerofObject(0, oop3);
					err1 = ffiPushPointerContentsOfin(handle21, calloutState1);
					goto l40;
				}
				if (oop3 == (nilObject())) {
					/* begin ffiPushPointer:in: */
					if (((calloutState1->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState1->integerRegisters))[(calloutState1->integerRegisterIndex)] = (((sqInt)null));
						(calloutState1->integerRegisterIndex = ((calloutState1->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState1->currentArg)) + BytesPerWord) > ((calloutState1->limit))) {
							err1 = FFIErrorCallFrameTooBig;
							goto l40;
						}
						longAtput((calloutState1->currentArg), null);
						(calloutState1->currentArg = ((calloutState1->currentArg)) + BytesPerWord);
					}
					err1 = 0;
					goto l40;
				}
				err1 = FFIErrorCoercionFailed;
				goto l40;
				break;
			default:
				err1 = FFIErrorWrongType;
				goto l40;

			}
		}
	l40:	/* end ffiArgument:Spec:Class:in: */;
		if (err1 != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState1->stringArgIndex)) > 0) {
				free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
			}
			
#      if COGMTVM
			if (err1 == (-PrimErrObjectMayMove)) {
				goto l68;
			}
#      endif /* COGMTVM */
			ffiFail(err1);
			goto l68;
		}
	}
	assert(!(failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		functionName1 = fetchPointerofObject(externalFunctionInstSize, externalFunction);
		if (!(isBytes(functionName1))) {
			goto l62;
		}
		ffiLogCallOfLength(firstIndexableField(functionName1), byteSizeOf(functionName1));
	}
	l62:	/* end ffiLogCallout: */;
	if ((requiredStackSize1 < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize1 = ((calloutState1->currentArg)) - ((calloutState1->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize1);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	myThreadIndex1 = disownVM(
#  if COGMTVM
		(((calloutState1->callFlags)) & FFICallFlagThreaded
				? DisownVMForFFICall + DisownVMForThreading
				: DisownVMForFFICall)
#  else /* COGMTVM */
		DisownVMForFFICall
#  endif /* COGMTVM */
		);
	if (((calloutState1->floatRegisterIndex)) > 0) {
		loadFloatRegs((((double *) ((&(((calloutState1->floatRegisters))[0])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[2])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[4])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[6])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[8])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[10])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[12])))))[0], (((double *) ((&(((calloutState1->floatRegisters))[14])))))[0]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState1->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec6 = (calloutState1->ffiRetHeader);
	atomicType6 = ((usqInt)((typeSpec6 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType6)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType6 == FFITypeSingleFloat) {
			floatRet1 = dispatchFunctionPointerwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
		}
		else {

			/* atomicType = FFITypeDoubleFloat */
			floatRet1 = dispatchFunctionPointerwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
		}
		if (isCalleePopsConvention((calloutState1->callFlags))) {
			setsp((calloutState1->argVector));
		}
		ownVM(myThreadIndex1);
		result2 = floatObjectOf(floatRet1);
		goto l41;
	}

	/* undo any callee argument pops because it may confuse stack management with the alloca. */
	intRet1 = dispatchFunctionPointerwithwithwithwith(((usqIntptr_t (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address2))), ((calloutState1->integerRegisters))[0], ((calloutState1->integerRegisters))[1], ((calloutState1->integerRegisters))[2], ((calloutState1->integerRegisters))[3]);
	if (isCalleePopsConvention((calloutState1->callFlags))) {
		setsp((calloutState1->argVector));
	}
	ownVM(myThreadIndex1);
	if (((calloutState1->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		if (((calloutState1->ffiRetHeader)) & FFIFlagPointer) {
			/* begin ffiReturnPointer:ofType:in: */
			specLiteral2 = (argArray != null
				? stackValue(1)
				: literalofMethod(0, primitiveMethod()));
			argTypes2 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral2);
			retType1 = fetchPointerofObject(0, argTypes2);
			retClass21 = fetchPointerofObject(1, retType1);
			if (retClass21 == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec13 = (calloutState1->ffiRetHeader);
				atomicType13 = ((usqInt)((typeSpec13 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType13)) >> 1) == (((usqInt)(FFITypeSignedChar)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					cPointer1 = ((usqInt) intRet1);
					if (!(cPointer1)) {
						retOop2 = nilObject();
						goto l56;
					}
					cString1 = ((char *) cPointer1);
					strLen1 = 0;
					while (!((cString1[strLen1]) == 0)) {
						strLen1 += 1;
					}
					strOop1 = instantiateClassindexableSize(classString(), strLen1);
					strPtr1 = firstIndexableField(strOop1);
					for (i11 = 0; i11 < strLen1; i11 += 1) {
						strPtr1[i11] = (cString1[i11]);
					}
					retOop2 = strOop1;
	l56:	/* end ffiReturnCStringFrom: */;
					result2 = retOop2;
					goto l41;
				}
			}
			
#if SPURVM
			oop21 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr11 = firstIndexableField(oop21);
			ptr11[0] = (((sqInt) intRet1));
			retOop2 = instantiateClassindexableSize(classExternalData(), 0);
			storePointerofObjectwithValue(0, retOop2, oop21);

#else /* SPURVM */
			pushRemappableOop(retType1);
			oop21 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
			ptr11 = firstIndexableField(oop21);
			ptr11[0] = (((sqInt) intRet1));
						pushRemappableOop(oop21);
			retOop2 = instantiateClassindexableSize(classExternalData(), 0);
			oop21 = popRemappableOop();
			storePointerofObjectwithValue(0, retOop2, oop21);
			retType1 = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(1, retOop2, retType1);
			result2 = retOop2;
			goto l41;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr1 = (&intRet1);
		/* begin ffiReturnType: */
		specLiteral11 = (argArray != null
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes11 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral11);
		ffiRetType1 = fetchPointerofObject(0, argTypes11);
		retClass11 = fetchPointerofObject(1, ffiRetType1);
		retOop11 = instantiateClassindexableSize(retClass11, 0);
		
#if SPURVM
		oop11 = instantiateClassindexableSize(classByteArray(), (calloutState1->structReturnSize));

#else /* SPURVM */
		pushRemappableOop(retOop11);
		oop11 = instantiateClassindexableSize(classByteArray(), (calloutState1->structReturnSize));
		retOop11 = popRemappableOop()
#endif /* SPURVM */
;
		memcpy(firstIndexableField(oop11), ((calloutState1->structReturnType)
			? longLongRetPtr1
			: (calloutState1->limit)), (calloutState1->structReturnSize));
		storePointerofObjectwithValue(0, retOop11, oop11);
		result2 = retOop11;
		goto l41;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(atomicType6 < FFITypeSingleFloat);
	if (atomicType6 == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize1 = ((calloutState1->ffiRetHeader)) & FFIStructSizeMask;
		value1 = (byteSize1 == (sizeof(intRet1))
			? intRet1
			: intRet1 & (((((unsigned long long)1)) << (byteSize1 * 8)) - 1));
		if (value1 == 0) {
			result2 = falseObject();
		}
		else {
			result2 = trueObject();
		}
		goto l41;
	}
	if (atomicType6 <= FFITypeSignedInt) {

		/* these are all generall integer returns */
		if (atomicType6 <= ((BytesPerWord == 8
			? FFITypeSignedInt
			: FFITypeSignedShort))) {

			/* byte/short. first extract partial word, then sign extend */

			/* # of significant bits */
			shift1 = ((BytesPerWord == 8)
			 && (atomicType6 >= FFITypeUnsignedInt)
				? 32
				: (((usqInt)(atomicType6)) >> 1) * 8);
			value1 = intRet1 & (((((unsigned long long)1)) << shift1) - 1);
			if (atomicType6 & 1) {

				/* make the guy signed */
				mask1 = (((unsigned long long)1)) << (shift1 - 1);
				value1 = (value1 & (mask1 - 1)) - (value1 & mask1);
			}
			result2 = integerObjectOf(value1);
			goto l41;
		}
		if (atomicType6 & 1) {
			if (BytesPerWord == 8) {
				result2 = signed64BitIntegerFor(intRet1);
			}
			else {
				result2 = signed32BitIntegerFor(intRet1);
			}
		}
		else {
			if (BytesPerWord == 8) {
				result2 = positive64BitIntegerFor(intRet1);
			}
			else {
				result2 = positive32BitIntegerFor(intRet1);
			}
		}
		goto l41;
	}
	if ((((usqInt)(atomicType6)) >> 1) == (((usqInt)(FFITypeSignedLongLong)) >> 1)) {
		if (atomicType6 & 1) {
			result2 = signed64BitIntegerFor(intRet1);
		}
		else {
			result2 = positive64BitIntegerFor(intRet1);
		}
	}
	else {
		result2 = characterObjectOf(intRet1 & 0xFF);
	}
	l41:	/* end ffiCalloutTo:SpecOnStack:in: */;
	if (!(retClass3 == (nilObject()))) {
		if ((((calloutState1->ffiRetHeader)) & ((FFIFlagAtomic + FFIFlagPointer) + FFIFlagStructure)) == FFIFlagAtomic) {
			
#if SPURVM
			alias1 = instantiateClassindexableSize(retClass3, 0);

#else /* SPURVM */
			pushRemappableOop(result2);
			alias1 = instantiateClassindexableSize(retClass3, 0);
			result2 = popRemappableOop()
#endif /* SPURVM */
;
			storePointerofObjectwithValue(0, alias1, result2);
			result2 = alias1;
		}
	}
	/* begin cleanupCalloutState: */
	while (((calloutState1->stringArgIndex)) > 0) {
		free(((calloutState1->stringArgs))[(calloutState1->stringArgIndex = ((calloutState1->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs1 + 1, result2);
	l68:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
#  endif /* COGMTVM */
	return;
}


/*	arguments: name(type, stack offset)
	width(Integer, 4)
	height(Integer, 3)
	rowPitch(Integer, 2)
	depth(Integer, 1)
	isMSB(Boolean, 0) */

	/* ThreadedFFIPlugin>>#primitiveCreateManualSurface */
EXPORT(sqInt)
primitiveCreateManualSurface(void)
{
    sqInt depth;
    sqInt height;
    sqInt isMSB;
    sqInt result;
    sqInt rowPitch;
    sqInt width;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	width = stackIntegerValue(4);
	height = stackIntegerValue(3);
	rowPitch = stackIntegerValue(2);
	depth = stackIntegerValue(1);
	isMSB = stackObjectValue(0);
	isMSB = booleanValueOf(isMSB);
	if (failed()) {
		return null;
	}
	result = createManualSurface(width, height, rowPitch, depth, isMSB);
	if (result < 0) {
		return primitiveFail();
	}
	result = signed32BitIntegerFor(result);
	return popthenPush(6, result);
}

	/* ThreadedFFIPlugin>>#primitiveDestroyManualSurface */
EXPORT(sqInt)
primitiveDestroyManualSurface(void)
{
    sqInt surfaceID;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	surfaceID = stackIntegerValue(0);
	if (!(failed())) {
		if ((destroyManualSurface(surfaceID)) == 0) {
			primitiveFail();
		}
		else {
			pop(1);
		}
	}
	return 0;
}


/*	Primitive. Allocate an object on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIAllocate */
EXPORT(sqInt)
primitiveFFIAllocate(void)
{
    sqInt addr;
    sqInt byteSize;
    sqInt oop;
    sqIntptr_t *ptr;

	byteSize = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	addr = ffiAlloc(byteSize);
	if (addr == 0) {
		return primitiveFail();
	}
	oop = instantiateClassindexableSize(classExternalAddress(), sizeof(sqIntptr_t));
	ptr = firstIndexableField(oop);
	ptr[0] = addr;
	return popthenPush(2, oop);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAt */
EXPORT(sqInt)
primitiveFFIDoubleAt(void)
{
    void * addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;

	byteOffset = stackIntegerValue(0);
	rcvr = stackObjectValue(1);
	if (failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8);
	if (addr == 0) {
		return primitiveFail();
	}
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2);
	return pushFloat(floatValue);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAtPut */
EXPORT(sqInt)
primitiveFFIDoubleAtPut(void)
{
    void * addr;
    sqInt byteOffset;
    sqInt floatOop;
    double floatValue;
    sqInt rcvr;

	floatOop = stackValue(0);
	if (isIntegerObject(floatOop)) {
		floatValue = ((double) (integerValueOf(floatOop)));
	}
	else {
		floatValue = ((double) (floatValueOf(floatOop)));
	}
	byteOffset = stackIntegerValue(1);
	rcvr = stackObjectValue(2);
	if (failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 8);
	if (addr == 0) {
		return primitiveFail();
	}
	memcpy(addr, (&floatValue), sizeof(floatValue));
	return popthenPush(3, floatOop);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAt */
EXPORT(sqInt)
primitiveFFIFloatAt(void)
{
    void * addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;

	byteOffset = stackIntegerValue(0);
	rcvr = stackObjectValue(1);
	if (failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4);
	if (addr == 0) {
		return primitiveFail();
	}
	memcpy((&floatValue), addr, sizeof(floatValue));
	pop(2);
	return pushFloat(floatValue);
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAtPut */
EXPORT(sqInt)
primitiveFFIFloatAtPut(void)
{
    void * addr;
    sqInt byteOffset;
    sqInt floatOop;
    float floatValue;
    sqInt rcvr;

	floatOop = stackValue(0);
	if (isIntegerObject(floatOop)) {
		floatValue = ((float) (integerValueOf(floatOop)));
	}
	else {
		floatValue = ((float) (floatValueOf(floatOop)));
	}
	byteOffset = stackIntegerValue(1);
	rcvr = stackObjectValue(2);
	if (failed()) {
		return 0;
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, 4);
	if (addr == 0) {
		return primitiveFail();
	}
	memcpy(addr, (&floatValue), sizeof(floatValue));
	return popthenPush(3, floatOop);
}


/*	Primitive. Free the object pointed to on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIFree */
EXPORT(sqInt)
primitiveFFIFree(void)
{
    sqIntptr_t addr;
    sqInt oop;
    sqIntptr_t *ptr;

	oop = stackObjectValue(0);
	if (!(((fetchClassOf(oop)) == (classExternalAddress()))
		 && ((byteSizeOf(oop)) == (sizeof(sqIntptr_t))))) {
		return primitiveFail();
	}
	ptr = firstIndexableField(oop);

	/* Don't you dare to free Squeak's memory! */
	addr = ptr[0];
	if ((addr == 0)
	 || ((((((usqIntptr_t)addr)) & ((sizeof(sqIntptr_t)) - 1)) != 0)
	 || (isInMemory(addr)))) {
		return primitiveFail();
	}
	ffiFree(addr);
	return ptr[0] = 0;
}


/*	Primitive. Return the error code from a failed call to the foreign
	function interface.
	This is for backwards-compatibility. Thread-safe access to the error code
	is via the
	primitive error code. */

	/* ThreadedFFIPlugin>>#primitiveFFIGetLastError */
EXPORT(sqInt)
primitiveFFIGetLastError(void)
{
	methodReturnInteger(ffiLastError);
	return 0;
}


/*	Answer a (signed or unsigned) n byte integer from the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAt */
EXPORT(sqInt)
primitiveFFIIntegerAt(void)
{
    void * addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    usqLong mask;
    sqInt rcvr;
    usqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0));
	byteSize = stackIntegerValue(1);
	byteOffset = stackIntegerValue(2);
	rcvr = stackObjectValue(3);
	if (failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (addr == 0) {
		return primitiveFail();
	}
	if (byteSize <= 2) {
		if (byteSize == 1) {
			value = ((unsigned char) (byteAt(addr)));
		}
		else {
			value = ((unsigned short) (unalignedShortAt(addr)));
		}
	}
	else {
		if (byteSize == 4) {
			value = ((unsigned int) (unalignedLong32At(addr)));
		}
		else {
			value = unalignedLong64At(addr);
		}
	}
	if (byteSize < BytesPerWord) {
		if (isSigned) {

			/* sign extend value */
			mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
			value = (value & (mask - 1)) - (value & mask);
		}
		valueOop = integerObjectOf(value);
	}
	else {

		/* general 64 bit integer; note these never fail */
		if (isSigned) {
			if (byteSize < 8) {

				/* sign extend value */
				mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			valueOop = signed64BitIntegerFor(value);
		}
		else {
			valueOop = positive64BitIntegerFor(value);
		}
	}
	return popthenPush(4, valueOop);
}


/*	Store a (signed or unsigned) n byte integer at the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAtPut */
EXPORT(sqInt)
primitiveFFIIntegerAtPut(void)
{
    void * addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    sqLong max;
    sqInt rcvr;
    sqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0));
	byteSize = stackIntegerValue(1);
	valueOop = stackValue(2);
	byteOffset = stackIntegerValue(3);
	rcvr = stackObjectValue(4);
	if (failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (addr == 0) {
		return primitiveFail();
	}
	if (isSigned) {
		value = signed64BitValueOf(valueOop);
	}
	else {
		value = positive64BitValueOf(valueOop);
	}
	if (failed()) {
		return 0;
	}
	if (byteSize < 8) {
		if (isSigned) {
			max = (((unsigned long long)1)) << ((8 * byteSize) - 1);
			if (!((value >= (0 - max))
				 && (value < max))) {
				return primitiveFail();
			}
		}
		else {
			if (!((((unsigned long long)value)) < ((((unsigned long long)1)) << (8 * byteSize)))) {
				return primitiveFail();
			}
		}
	}
	if (byteSize <= 2) {
		if (byteSize == 1) {
			byteAtput(addr, value);
		}
		else {
			unalignedShortAtput(addr, value);
		}
	}
	else {
		if (byteSize == 4) {
			unalignedLong32Atput(addr, value);
		}
		else {
			unalignedLong64Atput(addr, value);
		}
	}
	return popthenPush(5, valueOop);
}


/*	Primitive. Force loading the receiver (an instance of ExternalLibrary). */

	/* ThreadedFFIPlugin>>#primitiveForceLoad */
EXPORT(sqInt)
primitiveForceLoad(void)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt *ptr;
    sqInt rcvr;

	if (!((methodArgumentCount()) == 0)) {
		return primitiveFail();
	}
	rcvr = stackValue(0);
	if (!(isKindOfClass(rcvr, classExternalLibrary()))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr))
		 && ((byteSizeOf(moduleHandlePtr)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		return 0;
	}
	ffiModuleName = fetchPointerofObject(1, rcvr);
	if (!(isBytes(ffiModuleName))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), byteSizeOf(ffiModuleName))));
	if (failed()) {
		return ffiFail(FFIErrorModuleNotFound);
	}
	ptr = firstIndexableField(moduleHandlePtr);
	ptr[0] = moduleHandle;
	return 0;
}


/*	Attempt to find the address of a symbol in a loaded library.
	loadSymbol: aSymbol fromModule: moduleName
	<primitive: 'primitiveLoadSymbolFromModule' error: errorCode module:
	'SqueakFFIPrims'>  */

	/* ThreadedFFIPlugin>>#primitiveLoadSymbolFromModule */
EXPORT(sqInt)
primitiveLoadSymbolFromModule(void)
{
    void *address;
    sqInt module;
    sqInt moduleHandle;
    sqInt oop;
    void **ptr;
    sqInt symbol;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	module = stackValue(0);
	symbol = stackValue(1);
	moduleHandle = (module != (nilObject())
		? ffiLoadCalloutModule(module)
		: 0);
	if (failed()) {
		return primitiveFailFor(PrimErrNotFound);
	}
	address = ioLoadSymbolOfLengthFromModule(((sqInt) (firstIndexableField(symbol))), byteSizeOf(symbol), moduleHandle);
	if ((failed())
	 || (address == 0)) {
		return primitiveFailFor(PrimErrNotFound);
	}
	oop = instantiateClassindexableSize(classExternalAddress(), sizeof(void *));
	ptr = firstIndexableField(oop);
	ptr[0] = address;
	return methodReturnValue(oop);
}


/*	Enable logging of FFI calls by providing it with a log file name. */

	/* ThreadedFFIPlugin>>#primitiveLogCallsTo */
EXPORT(sqInt)
primitiveLogCallsTo(void)
{
    sqInt logFile;
    sqInt ok;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	logFile = stackValue(0);
	if (logFile == (nilObject())) {

		/* disable logging */
		ok = ffiLogFileNameOfLength(null, 0);
		if (!ok) {
			return primitiveFail();
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		if (!(isBytes(logFile))) {
			return primitiveFail();
		}
		ok = ffiLogFileNameOfLength(firstIndexableField(logFile), byteSizeOf(logFile));
		if (!ok) {
			return primitiveFail();
		}
		ffiLogEnabled = 1;
	}
	return pop(1);
}


/*	Create a 'manual surface' data-structure. See the ExternalForm class in
	the FFI package for example usage. */
/*	arguments: name(type, stack offset)
	surfaceID(Integer, 1)
	ptr(uint32/uint64, 0) */

	/* ThreadedFFIPlugin>>#primitiveSetManualSurfacePointer */
EXPORT(sqInt)
primitiveSetManualSurfacePointer(void)
{
    usqIntptr_t ptr;
    sqInt result;
    sqInt surfaceID;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	surfaceID = stackIntegerValue(1);
	ptr = positiveMachineIntegerValueOf(stackValue(0));
	if (failed()) {
		return null;
	}
	result = setManualSurfacePointer(surfaceID, ((void *)ptr));
	if (result == 0) {
		return primitiveFail();
	}
	return pop(2);
}


/*	Answer the alignment of an element of an atomic type, or a structure,
	within a structure on the current platform.
 */

	/* ThreadedFFIPlugin>>#primitiveStructureElementAlignment */
EXPORT(sqInt)
primitiveStructureElementAlignment(void)
{
    sqInt alignment;
    sqInt typeCode;

	typeCode = stackValue(0);
	if (!((isIntegerObject(typeCode))
		 && ((((((typeCode = integerValueOf(typeCode))) >= FFITypeUnsignedByte) && (typeCode <= FFITypeDoubleFloat)))
		 || (typeCode == FFIFlagStructure)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	
	switch (typeCode) {
	case FFITypeUnsignedByte:
	case FFITypeSignedByte:
		alignment = (&(((((structByte *) 0))->element)));
		break;
	case FFITypeUnsignedShort:
	case FFITypeSignedShort:
		alignment = (&(((((structShort *) 0))->element)));
		break;
	case FFITypeUnsignedInt:
	case FFITypeSignedInt:
		alignment = (&(((((structInt *) 0))->element)));
		break;
	case FFITypeUnsignedLongLong:
	case FFITypeSignedLongLong:
		alignment = (&(((((structLongLong *) 0))->element)));
		break;
	case FFITypeSingleFloat:
		alignment = (&(((((structFloat *) 0))->element)));
		break;
	case FFITypeDoubleFloat:
		alignment = (&(((((structDouble *) 0))->element)));
		break;
	default:
		alignment = (&(((((structStruct *) 0))->element)));

	}
	return methodReturnInteger(alignment);
}


/*	Return thrue register if structReturnType is true */

	/* ThreadedARM32FFIPlugin>>#returnStructInRegisters: */
static sqInt
returnStructInRegisters(CalloutState *calloutState)
{
	return (calloutState->structReturnType);
}


/*	Note: This is coded so that it can be run in Squeak. */
/*	Initialization of the plugin in the simulator.
	The real routine is in the superclass. */

	/* ThreadedFFIPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterObjectOf = interpreterProxy->characterObjectOf;
#else
#if !defined(characterObjectOf)
		characterObjectOf = 0;
#endif
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterValueOf = interpreterProxy->characterValueOf;
#else
#if !defined(characterValueOf)
		characterValueOf = 0;
#endif
#endif
		classAlien = interpreterProxy->classAlien;
		classByteArray = interpreterProxy->classByteArray;
		classExternalAddress = interpreterProxy->classExternalAddress;
		classExternalData = interpreterProxy->classExternalData;
		classExternalFunction = interpreterProxy->classExternalFunction;
		classExternalLibrary = interpreterProxy->classExternalLibrary;
		classExternalStructure = interpreterProxy->classExternalStructure;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		disownVM = interpreterProxy->disownVM;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchLong32ofObject = interpreterProxy->fetchLong32ofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
		floatValueOf = interpreterProxy->floatValueOf;
		includesBehaviorThatOf = interpreterProxy->includesBehaviorThatOf;
		instanceSizeOf = interpreterProxy->instanceSizeOf;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
#if !defined(integerObjectOf)
		integerObjectOf = interpreterProxy->integerObjectOf;
#endif
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		ioLoadModuleOfLength = interpreterProxy->ioLoadModuleOfLength;
		ioLoadSymbolOfLengthFromModule = interpreterProxy->ioLoadSymbolOfLengthFromModule;
		isKindOfClass = interpreterProxy->isKindOfClass;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isCharacterObject = interpreterProxy->isCharacterObject;
#else
#if !defined(isCharacterObject)
		isCharacterObject = 0;
#endif
#endif
		isFloatObject = interpreterProxy->isFloatObject;
		isInMemory = interpreterProxy->isInMemory;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 17)
		isLong64s = interpreterProxy->isLong64s;
#else
#if !defined(isLong64s)
		isLong64s = 0;
#endif
#endif
		isPointers = interpreterProxy->isPointers;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 17)
		isShorts = interpreterProxy->isShorts;
#else
#if !defined(isShorts)
		isShorts = 0;
#endif
#endif
		isWords = interpreterProxy->isWords;
		isYoung = interpreterProxy->isYoung;
		literalofMethod = interpreterProxy->literalofMethod;
		literalCountOf = interpreterProxy->literalCountOf;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		ownVM = interpreterProxy->ownVM;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveErrorTable = interpreterProxy->primitiveErrorTable;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		primitiveMethod = interpreterProxy->primitiveMethod;
		pushFloat = interpreterProxy->pushFloat;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		signed64BitValueOf = interpreterProxy->signed64BitValueOf;
		signedMachineIntegerValueOf = interpreterProxy->signedMachineIntegerValueOf;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		tenuringIncrementalGC = interpreterProxy->tenuringIncrementalGC;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer the first field of oop which is assumed to be an Alien of at least
	8 bytes
 */

	/* ThreadedFFIPlugin>>#sizeField: */
static sqInt
sizeField(sqInt oop)
{
	return longAt(oop + BaseHeaderSize);
}


/*	<Alien oop> ^<Integer> */
/*	Answer the start of oop's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

	/* ThreadedFFIPlugin>>#startOfData: */
static sqInt
startOfData(sqInt oop)
{
	return ((longAt(oop + BaseHeaderSize)) > 0
		? (oop + BaseHeaderSize) + BytesPerOop
		: longAt((oop + BaseHeaderSize) + BytesPerOop));
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "SqueakFFIPrims";
void* ARM32FFIPlugin_exports[][3] = {
	{(void*)_m, "ffiLogCallsTo", (void*)ffiLogCallsTo},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveCallout\000\002", (void*)primitiveCallout},
	{(void*)_m, "primitiveCalloutWithArgs\000\004", (void*)primitiveCalloutWithArgs},
	{(void*)_m, "primitiveCreateManualSurface\000\000", (void*)primitiveCreateManualSurface},
	{(void*)_m, "primitiveDestroyManualSurface\000\000", (void*)primitiveDestroyManualSurface},
	{(void*)_m, "primitiveFFIAllocate\000\001", (void*)primitiveFFIAllocate},
	{(void*)_m, "primitiveFFIDoubleAt\000\001", (void*)primitiveFFIDoubleAt},
	{(void*)_m, "primitiveFFIDoubleAtPut\000\001", (void*)primitiveFFIDoubleAtPut},
	{(void*)_m, "primitiveFFIFloatAt\000\001", (void*)primitiveFFIFloatAt},
	{(void*)_m, "primitiveFFIFloatAtPut\000\001", (void*)primitiveFFIFloatAtPut},
	{(void*)_m, "primitiveFFIFree\000\001", (void*)primitiveFFIFree},
	{(void*)_m, "primitiveFFIGetLastError\000\377", (void*)primitiveFFIGetLastError},
	{(void*)_m, "primitiveFFIIntegerAt\000\001", (void*)primitiveFFIIntegerAt},
	{(void*)_m, "primitiveFFIIntegerAtPut\000\001", (void*)primitiveFFIIntegerAtPut},
	{(void*)_m, "primitiveForceLoad\000\002", (void*)primitiveForceLoad},
	{(void*)_m, "primitiveLoadSymbolFromModule\000\002", (void*)primitiveLoadSymbolFromModule},
	{(void*)_m, "primitiveLogCallsTo\000\000", (void*)primitiveLogCallsTo},
	{(void*)_m, "primitiveSetManualSurfacePointer\000\000", (void*)primitiveSetManualSurfacePointer},
	{(void*)_m, "primitiveStructureElementAlignment\000\000", (void*)primitiveStructureElementAlignment},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveCalloutAccessorDepth = 2;
signed char primitiveCalloutWithArgsAccessorDepth = 4;
signed char primitiveCreateManualSurfaceAccessorDepth = 0;
signed char primitiveDestroyManualSurfaceAccessorDepth = 0;
signed char primitiveFFIAllocateAccessorDepth = 1;
signed char primitiveFFIDoubleAtAccessorDepth = 1;
signed char primitiveFFIDoubleAtPutAccessorDepth = 1;
signed char primitiveFFIFloatAtAccessorDepth = 1;
signed char primitiveFFIFloatAtPutAccessorDepth = 1;
signed char primitiveFFIFreeAccessorDepth = 1;
signed char primitiveFFIIntegerAtAccessorDepth = 1;
signed char primitiveFFIIntegerAtPutAccessorDepth = 1;
signed char primitiveForceLoadAccessorDepth = 2;
signed char primitiveLoadSymbolFromModuleAccessorDepth = 2;
signed char primitiveLogCallsToAccessorDepth = 0;
signed char primitiveSetManualSurfacePointerAccessorDepth = 0;
signed char primitiveStructureElementAlignmentAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
